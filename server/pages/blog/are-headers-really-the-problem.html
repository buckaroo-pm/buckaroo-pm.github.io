<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><link rel="stylesheet" type="text/css" href="/prism.css"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/are-headers-really-the-problem-7d8b9a10f02e61b69704.js" as="script"/></head><body><div id="__next"><div class="site"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div style="width:100%;max-height:80vh;overflow:hidden"><img src="/posts/header-problem.jpeg" style="width:100%"/></div><div class="banner white"><div class="view"><div><h1>Are Headers Really the Problem?</h1><div class="post"><p>A huge barrier that newcomers to C++ face is that of undefined references. We create a project, include a few headers and <strong>BOOM</strong>, linker error.</p><p>In fact, searches for &quot;undefined reference&quot; do not trail that far behind searches for &quot;clang&quot;.</p><p><img src="/img/undefined-ref-trends.png" alt="Google Trends"/></p><p><em>Google Trends, &quot;clang&quot; (red) vs &quot;undefined reference&quot; (blue)</em></p><p>Why is this?</p><p>Well, unlike most languages, C++ splits code into <em>headers</em> and <em>implementations</em>. Public headers define the interface for your code - the types, memory layout, available functions, etc. The implementations define how it works.</p><pre class="language-cpp"><code class="language-cpp"><span class="token comment">/* foo.h */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">FOO_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOO_H</span></span>

<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><p><em>There is a function call foo, that returns an int</em></p><pre class="language-cpp"><code class="language-cpp"><span class="token comment">/* foo.cpp */</span>

<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><em>foo returns 1 + 2</em></p><p><em>Undefined references</em> occur when you depend on a header, but not on the corresponding translation-unit(s).</p><p>Some have argued that this is a reason not to have headers at all. Indeed, Java avoids the use of headers because it makes things simpler:</p><blockquote><p>Source code written in Java is simple. There is no preprocessor, no #define and related capabilities, no typedef, and absent those features, no longer any need for header files. Instead of header files, Java language source files provide the definitions of other classes and their methods.</p></blockquote><p><a href="http://java.sun.com/docs/white/langenv/">Section 2.2.1 of the Java Language Environment white paper</a></p><p>But maybe this isn&#x27;t a failure of the <em>language</em>, but a failure of our <em>build-systems</em>.</p><p>Using the compiler, a build-system can figure out the list of headers that your project uses. It&#x27;s not difficult, either.</p><p>Suppose we have a project like this:</p><pre class="language-bash"><code class="language-bash">$ tree <span class="token builtin class-name">.</span>
<span class="token builtin class-name">.</span>
├── foo
│   ├── bar.cpp
│   ├── bar.h
│   ├── baz
│   │   └── baz.h
│   ├── foo.cpp
│   └── foo.h
├── main.cpp
└── qux
    ├── qux.cpp
    └── qux.h

<span class="token number">3</span> directories, <span class="token number">7</span> files
</code></pre><p>Then we can find the include-graph for <code>main.cpp</code> like this:</p><pre class="language-bash"><code class="language-bash">$ gcc -I <span class="token builtin class-name">.</span> -MM ./main.cpp
main.o: main.cpp foo/foo.h foo/bar.h foo/baz/baz.h qux/qux.h
</code></pre><p>So we can figure out the set of headers that a given translation-unit depends on. Now, we need to ensure that if we depend on any header, we also link to the library target that it belongs to.</p><p>In this case, we depend on <code>foo/foo.h</code>, which is implemented by <code>foo/foo.cpp</code> in the target <code>foo</code>, and <code>qux/qux.h</code>, which is implemented by <code>qux/qux.cpp</code> in target <code>qux</code>.</p><table><thead><tr><th>Library Target</th><th>Header(s)</th><th>Translation-unit(s)</th></tr></thead><tbody><tr><td><code>foo</code></td><td><code>foo/bar.h</code></td><td><code>foo/bar.cpp</code></td></tr><tr><td></td><td><code>foo/baz/baz.h</code></td><td><code>foo/foo.cpp</code></td></tr><tr><td></td><td><code>foo/foo.h</code></td><td></td></tr><tr><td><code>qux</code></td><td><code>qux/qux.h</code></td><td><code>qux/qux.cpp</code></td></tr></tbody></table><p>So we need to introduce a rule:</p><blockquote><p>If you include header X then you must also link to the library target that X belongs to</p></blockquote><p>With this rule in place, we cannot just forget to link <code>bar.o</code>, <code>qux.o</code> or <code>foo.o</code>. If we try, then the build-system will detect this, and tell us where we went wrong.</p><p>To support this, targets in the build-system must declare every header-file that belongs to it. Otherwise, we have no way of knowing where a header should come from.</p><p>This is quite practical, if you use globs:</p><pre class="language-python"><code class="language-python">cxx_library<span class="token punctuation">(</span>
  name <span class="token operator">=</span> <span class="token string">&#x27;foo&#x27;</span><span class="token punctuation">,</span>
  exportd_headers <span class="token operator">=</span> subdir_glob<span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">&#x27;foo&#x27;</span><span class="token punctuation">,</span> <span class="token string">&#x27;**/*.h&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  srcs <span class="token operator">=</span> glob<span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token string">&#x27;foo/**/*.cpp&#x27;</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>

cxx_library<span class="token punctuation">(</span>
  name <span class="token operator">=</span> <span class="token string">&#x27;qux&#x27;</span><span class="token punctuation">,</span>
  exportd_headers <span class="token operator">=</span> subdir_glob<span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">&#x27;qux&#x27;</span><span class="token punctuation">,</span> <span class="token string">&#x27;**/*.h&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  srcs <span class="token operator">=</span> glob<span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token string">&#x27;qux/**/*.cpp&#x27;</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre><p>In summary:</p><ul><li>Headers are not necessarily evil.</li><li>We can query the compiler for actual header-usage.</li><li>Build targets should declare the header-files (not directories) they export.</li><li>The build-system should enforce that if you include a header-file, you must link to its corresponding library target.</li></ul><hr/><h2>Notes</h2><ol><li>Interestingly, CMake, the most popular C++ build-system, does not get this right. Where it could offer guarantees, it only offers conventions.</li><li>Another benefit is that if two targets export headers to the same include-path, we can detect and resolve this conflict. Otherwise the behavior is determined by the order of compiler flags, which is usually coincidental.</li><li>Sometimes there is more than one translation-unit for a given header. In this case, we need to ensure that all translation-units for the header are linked.</li><li>I made some updates to clear up the distinction between library targets and translation-units.</li></ol></div></div></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/are-headers-really-the-problem","query":{},"buildId":"zumqXaU5fk-68lIEJ-riC","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" async=""></script><script src="/_next/static/chunks/pages/blog/are-headers-really-the-problem-7d8b9a10f02e61b69704.js" async=""></script><script src="/_next/static/zumqXaU5fk-68lIEJ-riC/_buildManifest.js" async=""></script><script src="/_next/static/zumqXaU5fk-68lIEJ-riC/_ssgManifest.js" async=""></script></body></html>