<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><link rel="stylesheet" type="text/css" href="/prism.css"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/approaches-to-c-dependency-managment-dc6d4d714ae30d9a6cbe.js" as="script"/></head><body><div id="__next"><div class="site"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div style="width:100%;max-height:80vh;overflow:hidden"><img src="/posts/why-we-built-buckaroo.jpeg" style="width:100%"/></div><div class="banner white"><div class="view"><div><h1>Approaches to C++ Dependency Management, or Why We Built Buckaroo</h1><div class="post"><p>C++ is an unusual language in that it does not yet have a dominant package manager (<a href="https://buckaroo.pm/">we‚Äôre working on it</a>!). As a result, C++ developers have turned to a few different methods of re-using code across projects.</p><p>This lack of standardization has had negative effects on the ecosystem. There is a <a href="https://github.com/nothings/single_file_libs">cottage industry</a> of ‚Äúheader-only‚Äù C++ libraries ‚Äî tiny libraries of just a few files, ready to be copied directly into a project. Monolithic libraries such as <a href="https://github.com/boostorg">Boost</a> get larger and larger, since it‚Äôs easier to add ‚Äúone-more-feature‚Äù than it is to integrate further libraries. Can we really say that either of these extremes are the best way to organize code, or are they simply the result of a gap in the ecosystem?</p><blockquote><h1>Can we really say that either of these extremes are the best way to organize code, or are they simply the result of a gap in the ecosystem?</h1></blockquote><p>As a C++ developer, what dependency management methods are available? How do they differ and what is the best approach?</p><h2>Where are we trying to get to? ü§î</h2><p>OK, so before deciding on the best approach, and explaining why we built Buckaroo, it‚Äôs important to specify what we are trying to achieve. What is a dependency management solution, and what makes one good?</p><h3>What is Dependency Management?</h3><p>Dependency management is the process of maintaining links to external libraries used by your project. By adding dependencies, you can reuse code in your project, which has two advantages:</p><ol><li><p>You do not have to write that code yourself.</p></li><li><p>You benefit from a community of other users who test the code in production environments.</p></li></ol><p>A dependency manager makes it easier to maintain these external libraries by providing automated tooling.</p><h3>What Makes a Good Dependency Manager?</h3><p>For the majority use-case, we came up with a list of requirements that a good packaging solution must meet.</p><h3><strong>1. It should be easy to add new dependencies to a project.</strong></h3><p>It seems obvious, but this point is easily missed in the pursuit of other requirements. If it is difficult to add dependencies, then developers will be more likely to re-implement functionality. Their one-off implementation will be less well-tested than a community one, and the developer will have diverted time away from other features.</p><p>Because dependency graphs can be complicated, transitive dependencies should be fetched and resolved automatically as part of the installation procedure.</p><h3>2. Understanding the dependencies that a project uses should be trivial.</h3><p>Whilst making it easy to add dependencies encourages code re-use, the down-side is the accidental complexity that can be introduced by over-zealous imports. It is critical that developers can easily inspect the dependencies that are used, and prune them as requirements change. And to aid in debugging, the source-code of dependencies should be readily available.</p><h3>3. It should work on all major platforms. Cross-compilation should be easy, not just an after-thought.</h3><p>A common misconception of C++ is that unlike VM languages, such as Java, the code is not portable across platforms. The truth is that C++ is portable, but in a different way. Whilst Java compiles to a byte-code format, which is platform neutral and can be deployed anywhere, C++ is only portable <em>before compilation</em>. This means that to maintain portability, a C++ package manager must provide the source-code for every package, with binaries only as an optimization.</p><h3>4. Dependency installation should be reproducible. Every developer should be building the same code.</h3><p>Just as reproducibility is crucial in a build system, it is crucial in any package manager that builds on top. Reproducibility means that the developer can be confident that the code being testing and deployed is what they expected. This prevents subtle bugs from appearing only on some machines, causing production down-time and endless developer frustration!</p><h3>5. A dependency should be project-centric. In other words, installing a dependency should not modify your system.</h3><p>Project-centric solutions are important when writing software because they reduce friction when trying out different dependencies. If adding a dependency requires changing a machine‚Äôs configuration, then developers will be reluctant to try it; something might break and no one wants to have to remember how to reconfigure things afterwards. Even worse, a dependency may be incompatible with a requirement of some system component. A packaging solution should work entirely inside of a project.</p><h3>6. It should be easy to publish new packages.</h3><p>When developers contribute their work to the open-source community, or just to colleagues within their organization, they are multiplying the impact of their efforts. We should encourage this! The best way to do so is to make it incredibly easy to publish packages. The process should be self-service; there should be no need for additional infrastructure and you shouldn‚Äôt need to wait for approvals.</p><h3>7. Require the minimal amount of additional infrastructure, such as servers.</h3><p>Regardless of how easy it is to deploy, additional infrastructure creates extra costs and adds another point of failure. A good solution will use existing infrastructure wherever possible.</p><h2>Different Approaches</h2><p>OK, let‚Äôs start with a quick round-up of the different approaches.</p><h3>Copy-and-Paste</h3><p>This is the simplest method of dependency management, and it‚Äôs even <a href="https://github.com/SFML/SFML/tree/master/extlibs">used by some big projects</a>!</p><p>The problem with this method is that it provides very little actual management. The transitive dependencies of code must be resolved by hand, dependency upgrades are manual and, most crucially, the exact version that was copied must be tracked by the developer. If a binary has been copy-pasted, then cross-compilation is difficult.</p><p>Still, to it‚Äôs credit, the copy-and-paste approach requires no external tools, reproducibility comes for free and it is trivial to set-up.</p><h3>apt-get (And Similar)</h3><p>Some developers argue that C++ already has a package manager, and that it‚Äôs built into Linux. Using apt-get, many C++ libraries can be installed onto a target machine.</p><p>So why not use apt-get? Whilst apt-get is an excellent way to install applications onto your machine, problems occur when using a system package manager for project-level packages:</p><ul><li><p>It is tied to the operating system. apt-get only works cleanly on Linux, and usually only on Debian environments.</p></li><li><p>Installing binaries onto your system does not help with cross-compilation.</p></li><li><p>It modifies your system. What happens when you are working on two projects that require different versions of a dependency?</p></li><li><p>apt-get does not guarantee reproducibility, although <a href="https://nixos.org/nix/">other package managers</a> do. üëç</p></li><li><p>You have little control over the chosen ABI, build configuration or standard library used.</p></li></ul><h3>Docker &amp; apt-get üê≥</h3><p>One solution to the problems of apt-get is to do all of your development inside of a Docker container. Create a container for every project that you are working on, and simply install every project dependency as a system dependency in that container.</p><p>This certainly works, but it has a few limitations:</p><ul><li><p>Developing native Windows software is more or less a non-starter. Yes, you can Docker on Windows, but it is still a Linux environment. You will need to cross-compile and then run outside of Docker for testing.</p></li><li><p>You are still limited to the packages that apt-get provides, and these change over time.</p></li><li><p>Docker runs as root, which is questionable from a security perspective. <em>(Correction: <a href="http://www.infoworld.com/article/3030558/application-virtualization/docker-goes-rootless-and-thats-a-good-thing.html">Docker is now root-less</a>)</em></p></li><li><p>It requires significant disc-space, since Docker keeps a copy of system libraries.</p></li><li><p>You may need to install tooling for a second time inside of the Docker container.</p></li><li><p>Tooling is now tied to the project, so either everyone on the team must have exactly the same tooling or you will need to manage multiple images.</p></li></ul><h3>Git Submodules</h3><p>Submodules is a feature of Git that allows you to include another Git repository as a folder. If you‚Äôre already using Git, it‚Äôs a powerful addition with no extra tooling required.</p><p>The limitation of Submodules is that it does not offer dependency resolution. Why does this matter? Suppose you have a dependency graph like this:</p><pre><code>A v1 requires B v1
A v1 requires C v2
B v1 requires C v1‚Äì3
</code></pre><p>Clearly, we can resolve this to:</p><pre><code>A v1
B v1
C v2
</code></pre><p>However, Submodules does not allow you to express such requirements, and you therefore have to do the resolution by hand. This is not a problem for small projects, but as the list of dependencies grows it becomes one.</p><p>On top of that, Submodules provides no way to simplify the dependency graph. Suppose you have this system of projects:</p><pre><code>A requires B
A requires C
B requires D
C requires D
</code></pre><p>So B and C both require the library D. As such, we should only build D once, and reuse the result for building B and C. Submodules do not help us here. We have to manually ensure this happens by scripting our build system.</p><h3>CMake External Projects</h3><p>CMake has a feature for downloading external projects called ExternalProject_Add. It has <a href="https://cmake.org/cmake/help/v3.8/module/ExternalProject.html">a huge number of settings</a>, so there‚Äôs a good chance it can be configured to do what you need.</p><p>However:</p><ul><li><p>It‚Äôs not reproducible. ExternalProject_Add can download modules from unstable URLs and Git branches.</p></li><li><p>There‚Äôs little standardization. CMake relies on variable name conventions, which are rather brittle.</p></li><li><p>CMake syntax üò± is unpleasant to use, and has no advantages over alternative syntax choices.</p></li><li><p>Dependency resolution must still be done manually.</p></li></ul><h3>A Project-Centric Package Manager</h3><p>A project-centric package manager is one that installs dependencies into your project folder, rather than onto your system. Think of it this way: <em>project-centric packager managers are for building projects; system package managers are for installing software</em>.</p><p>There have been many attempts at building a project-centric package manager for several languages. The most successful of these is inarguably NPM, for the JavaScript ecosystem.</p><p><img src="/posts/npm-growth.png" alt="Source: [blog.npmjs.org](http://blog.npmjs.org/post/143451680695/how-many-npm-users-are-there)"/><em>Source: <a href="http://blog.npmjs.org/post/143451680695/how-many-npm-users-are-there">blog.npmjs.org</a></em></p><p>(As an aside, if you are using JavaScript, do yourself a favour and consider switching to <a href="https://yarnpkg.com/">Yarn</a>).</p><h2>Buckaroo</h2><p>We built Buckaroo to be a project-centric package manager for C++. <a href="https://github.com/pfultz2/cget">There</a> <a href="https://github.com/ruslo/hunter">are</a> <a href="https://www.conan.io/">alternatives</a>, and we will do a full comparison in another article, but none of the existing solutions quite matched our requirements. Here is an overview of how Buckaroo stacks up.</p><h3>1. It should be easy to add new dependencies to a project.</h3><p>Buckaroo dependencies are installed in one command, for example:</p><pre><code>buckaroo install boost/asio
</code></pre><h3>2. Understanding the dependencies that a project uses should be trivial.</h3><p>Every project contains a buckaroo.json file that specifies the dependencies of the project. Additionally, there is a buckaroo.lock.json file that specifies exactly how the versions were resolved.</p><h3>3. It should work on all major platforms. Cross-compilation should be easy, not just an after-thought.</h3><p>Buckaroo supports macOS, Windows (preview) and Linux. All Buckaroo packages build from source using <a href="https://buckbuild.com/">Buck</a> as a build system, which enables cross-compilation using ‚Äúbuild flavors‚Äù.</p><h3>4. Installing dependencies should be reproducible. Every developer should be building the same code.</h3><p>Like Yarn, Buckaroo saves the exact result of dependency resolution to a lock file, which ensures that every deployment uses exactly the same dependencies.</p><p>Additionally, since all Buckaroo packages build with Buck, it can give reproducible builds. This would not be guaranteed with CMake.</p><h3>5. A dependency should be project-centric. In other words, installing a dependency should not modify your system.</h3><p>Buckaroo is entirely project-local. Only a download cache and some user-settings live outside of your project folder. This guarantees that your <a href="https://hackernoon.com/getting-started-with-buck-build-on-travis-ci-d1208d363023">CI server</a> builds exactly the same code that you do.</p><h3>6. It should be easy to publish new packages.</h3><p>Publishing a Buckaroo package is trivial:</p><ol><li>Write a Buck build file to your project</li><li>Add a buckaroo.json file</li><li>Create a GitHub release</li></ol><p>That‚Äôs it! See <a href="http://buckaroo.readthedocs.io/en/latest/github-package-guide.html">this guide</a> for more information.</p><h3>7. Require the minimal amount of additional infrastructure, such as servers.</h3><p>Buckaroo leverages existing infrastructure, such as GitHub, so that you don‚Äôt need to host your own server.</p><h2>Conclusion</h2><p>Hopefully this article has explained some of the motivations behind Buckaroo. To summarize:</p><ul><li><p>There are many advantages to using a project-centric package manager, such as Buckaroo, in your project.</p></li><li><p>Use the system package manager to install tooling and for deployments.</p></li><li><p>Git sub-modules is a reasonable option if you have a requirement of minimal tooling.</p></li><li><p>Copy-and-paste is viable for tiny dependencies, such as <a href="https://github.com/philsquared/Catch">Catch</a>, but it is still more convenient to use a package manager.</p></li></ul><h3>Ready to Get Started? ü§†</h3><p>If you would like try <a href="http://buckaroo.pm/">Buckaroo</a>, the best place to start is <a href="https://buckaroo.readthedocs.io/en/latest/">the documentation</a>. You can browse the existing packages on <a href="http://buckaroo.pm/">Buckaroo.pm</a> or request more over on <a href="https://github.com/LoopPerfect/buckaroo-wishlist">the wishlist</a>.</p></div></div></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/approaches-to-c-dependency-managment","query":{},"buildId":"zumqXaU5fk-68lIEJ-riC","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" async=""></script><script src="/_next/static/chunks/pages/blog/approaches-to-c-dependency-managment-dc6d4d714ae30d9a6cbe.js" async=""></script><script src="/_next/static/zumqXaU5fk-68lIEJ-riC/_buildManifest.js" async=""></script><script src="/_next/static/zumqXaU5fk-68lIEJ-riC/_ssgManifest.js" async=""></script></body></html>