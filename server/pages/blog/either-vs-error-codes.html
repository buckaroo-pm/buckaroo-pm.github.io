<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><link rel="stylesheet" type="text/css" href="/prism.css"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/either-vs-error-codes-58330708a9243f09a0dd.js" as="script"/></head><body><div id="__next"><div class="site"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div style="width:100%;max-height:80vh;overflow:hidden"><img src="/posts/forrest.jpeg" style="width:100%"/></div><div class="banner white"><div class="view"><div><h1>Error Handling in C++ or: Why You Should Use Eithers in Favor of Exceptions and Error-codes</h1><div class="post"><h2>TL;DR</h2><p>Consider using an Either type to handle errors as they lift the error into the type-system and have the same performance characteristics as error-codes.</p><h3>Either Implementations</h3><ul><li><p><a href="https://github.com/loopperfect/neither">loopperfect/neither</a></p></li><li><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4109.pdf">std::expected</a></p></li><li><p><a href="https://ned14.github.io/boost.outcome/md_doc_md_02-tutorial_a.html">boost::expected</a></p></li><li><p><a href="https://github.com/beark/ftl">beark/ftl</a></p></li></ul><h2>Introduction</h2><p>Programming language design is always a matter of trade-offs. In the case of C++, the designers optimized for two things: <em>runtime efficiency</em> and <em>high-level abstraction</em>. This gives the C++ programmer huge flexibility in many areas, one of which is error handling.</p><h2>Exceptions &amp; Try-Catch</h2><p>Try-catch is traditionally seen as the most idomatic error-handling method in C++.</p><pre class="language-cpp"><code class="language-cpp">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;Divide by zero&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;4/2 &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;3/0 &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3>Exception Overhead</h3><p>The try-catch language feature is not zero-cost and the exact price is determined by the compiler implementation. Implementers can choose between increased code-size and increased run-time overhead, both in the success branch and the failure branch.</p><p>In most C++ implementations, an interesting choice has been made: code in the try block runs as fast as any other code. However, dispatching to the catch block is orders of magnitude slower. This penalty grows linearly with the depth of the call-stack.</p><p>If exceptions make sense for your project will depend on the frequency at which exceptions will be thrown. If the error rate is above 1%, then the overhead will likely be greater than that of alternative approaches. (<a href="https://youtu.be/XVofgKH-uu4?t=1h2m24s">Source</a>)</p><p>Exceptions are not supported by all platforms, and methods that throw cannot be easily understood by C.</p><h3>Ergonomics</h3><p>Exceptions are very easy to use and fairly easy to reason about. You can throw and catch exceptions at any point in your code, and the exception can even be an arbitrary type.</p><p>The biggest drawback is that handling exceptions is not enforced by the type-system. Unlike, Java, for example, where exceptions must be caught by the caller, catching a C++ exception is optional. This means spotting all the unhandled exceptions during a code review will be challenging, and requires deep knowledge of all of the functions called.</p><h3>But what about noexcept and throw?</h3><p>A common misconception is that annotating functions with noexcept or throw can help.</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">int</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token operator">::</span>exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Unfortunately, noexcept and throw simply dictate that a call to std::terminate is made in the case where an unmentioned exception is thrown. <em>This does not enforce any exception-handling at compile-time.</em></p><p>For example, these will compile and throw a run-time error!</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// These compile fine, but on execution std::terminate is called and the program exits</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h2>Error-codes</h2><p>Error-codes are ancient and used <em>everywhere</em>. For simplicity, let’s assume error-codes are just integers, but they could be implemented as type-safe enums or even complex objects. For this discussion it won’t really matter.</p><p>There are 3 common forms of error-code implementations.</p><h3>1. Error-codes as Return Values</h3><p>This pattern is found in many C APIs as it is easy to implement and has no performance overhead, besides the error-handling itself.</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ERROR <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> SUCCESS <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">int</span> input<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> output<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cond</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>output <span class="token operator">=</span> <span class="token function">computeOutput</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> SUCCESS<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Usage</span>
<span class="token keyword">int</span> output<span class="token punctuation">;</span>
<span class="token keyword">int</span> input<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token function">compute</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token operator">&amp;</span>output<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">error_handler</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>This pattern can be followed very dogmatically and it is easy to verify that all cases have been taken care of in a code-review. It is easy to write a C-friendly API using error-codes.</p><p>Unfortunately it has some drawbacks:</p><ul><li><p>Functional composition is hard. The return value is occupied by the error-code, so the result must be an out-variable, which makes the function impure.</p></li><li><p>Out-parameters enforce a memory layout which is not optimizer friendly.</p></li><li><p>Separating error-handling from the computation is difficult.</p></li><li><p>Postponing error-handling requires the programmer to thread the error-code through the call-graph.</p></li></ul><h3>2. Error-code as out-parameter</h3><p>Swapping the semantics of the out-parameter and return value has no significant advantages, except perhaps a slightly cleaner API. In the case where the error-code can be omitted, the API usage is simplified and functional compositionality is made easier.</p><p>This approach can be found in boost::asio (in fact boost::asio even makes it optional and falls back to throwing exceptions if no out-parameter is provided).</p><h3>3. Error Singletons</h3><p>Error singletons have completely different ergonomics. They are mostly found in low-level libraries that are implementing a system-global state-machine, such as a driver. One prominent example is OpenGL.</p><p>Using an error singleton looks like this:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">compute1</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result2 <span class="token operator">=</span> <span class="token function">compute2</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">has_errors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">pop_error_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>In this paradigm, the status of the driver must be queried at run-time through a separate function. This appears to give you more freedom since you can query for errors when it is most appropriate, enabling you to better separate concerns. This allows the user to write code that resembles exception-based code, but without the cost of automatic stack unwinding.</p><p>Benefits for the API consumer:</p><ul><li><p>Error-handling can be reduced over time to a minimum</p></li><li><p>Having fewer error-handling branches yields better performance</p></li><li><p>No out-parameters are required, which increases functional compositionality</p></li><li><p>Finalization can be performed manually when errors are found</p></li></ul><p>But there are some big caveats:</p><ul><li><p>Singletons by design have shared state, thus writing thread-safe code is very hard</p></li><li><p>No shortcutting of computation pipelines as no stack-unwinding occurs</p></li><li><p>It is not clear which errors may be fired on which api-calls. The programmer must check the documentation.</p></li><li><p>The severity of errors, and to recover from them, might be unclear</p></li></ul><h2>So what about Eithers?</h2><p>An Either type is a container which takes a single value of one of two different types. A simple implementation might look like this:</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Left</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Right</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Either</span> <span class="token punctuation">{</span>
  <span class="token keyword">union</span> <span class="token punctuation">{</span>
    Left leftValue<span class="token punctuation">;</span>
    Right rightValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">bool</span> isLeft<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>To run computations on the wrapped value, an Either can provide some useful methods: leftMap, rightMap and join.</p><ul><li><p>leftMap transforms the leftValue to a new value if present, leaving a rightValue unchanged.</p></li><li><p>rightMap transforms the rightValueto a new value if present, leaving a leftValue unchanged.</p></li><li><p>join takes a transformation for both sides of the Either where both transformations result in the same type. This allows an Either to be unified and unwrapped.</p></li></ul><p>This is much easier to understand in code!</p><pre class="language-cpp"><code class="language-cpp">Either<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> myEither <span class="token operator">=</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// constructs a either containing a leftValue;</span>

<span class="token keyword">int</span> count <span class="token operator">=</span> myEither
  <span class="token punctuation">.</span><span class="token function">rightMap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// adds 1 if rightValue is present</span>
  <span class="token punctuation">.</span><span class="token function">leftMap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> str <span class="token operator">+</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// appends &quot;world&quot; if leftValue is present</span>
  <span class="token punctuation">.</span><span class="token function">leftMap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// both sides have now the same type, lets join...</span>
</code></pre><p>Now we are able to lift the exceptions into the type-system:</p><pre class="language-cpp"><code class="language-cpp"><span class="token comment">// This... </span>
<span class="token keyword">float</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;x should be &gt;= 0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">computeSqrt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ... can be transformed into this... </span>
Either<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token string">&quot;x should be &gt;=0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token function">computeSqrt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre class="language-cpp"><code class="language-cpp">
<span class="token comment">// And for the caller, the usage changes from this... </span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;sqrt(x) = &quot;</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;error occurred: &quot;</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ... to this... </span>
std<span class="token operator">::</span>string msg <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">leftMap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">&quot;error occurred: &quot;</span> <span class="token operator">+</span> msg<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">rightMap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">&quot;sqrt(x) = &quot;</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
</code></pre><h3>So what have we gained through this simple change?</h3><p>We no longer need to pay for the overhead of exceptions and we have also encoded the exception-type into the function signature. This documents the error in the source-code and now the compiler will ensure that we handle the types properly.</p><p>This is a big deal, and it illustrates how powerful the C++ language is.</p><h3>So what are the drawbacks?</h3><p>First, you will need to add an Either type to you project. It is best not to reinvent the wheel here, and fortunately there are <a href="https://github.com/loopperfect/neither">many</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4109.pdf">open-source</a> <a href="https://ned14.github.io/boost.outcome/md_doc_md_02-tutorial_a.html">implementations</a> <a href="https://github.com/beark/ftl">available</a>.</p><p>But what about performance? At first glance, it seems that every call to leftMap and rightMap will add a branch to the executable. In practice, the compiler is smart enough to optimize these away!</p><p>Take a look at <a href="https://godbolt.org/g/5f6mT9">this Compiler Explorer project</a>; the branches of the various map calls dissappear.</p><p>For example, you might have noticed the following identity:</p><pre class="language-cpp"><code class="language-cpp">e<span class="token punctuation">.</span><span class="token function">leftMap</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">leftMap</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span> <span class="token operator">==</span> e<span class="token punctuation">.</span><span class="token function">leftmap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>And it turns out that the compiler does too. It combines both lambdas to inline the whole expression. After the optimization step, all abstractions are collapsed. Once complied, there is no significant difference between the error-code implementations and the either-based implementations.</p><h2>Conclusion</h2><p>Consider using an Either type to handle errors. They lift the error into the type-system, making them safer than exceptions whilst yielding the same performance characteristics as error-codes.</p><h2>Resources</h2><h3>Either Implementations</h3><ul><li><p><a href="https://github.com/loopperfect/neither">loopperfect/neither</a></p></li><li><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4109.pdf">std::expected</a></p></li><li><p><a href="https://ned14.github.io/boost.outcome/md_doc_md_02-tutorial_a.html">boost::expected</a></p></li><li><p><a href="https://github.com/beark/ftl">beark/ftl</a></p></li></ul><h3>Benchmarking Error-codes vs Exceptions vs Eithers</h3><center><iframe width="560" height="315" src="https://www.youtube.com/embed/XVofgKH-uu4" frameborder="0"></iframe></center><h3>Return Values vs Out-Parameters</h3><center><iframe width="560" height="315" src="https://www.youtube.com/embed/eR34r7HOU14" frameborder="0"></iframe></center><h3>Some Code Samples</h3><ul><li><p>Gist: <a href="https://gist.github.com/nikhedonia/db401285d9f3816e2a74d78c68dd4c6c">https://gist.github.com/nikhedonia/db401285d9f3816e2a74d78c68dd4c6c</a></p></li><li><p>Assembly: <a href="https://godbolt.org/g/5f6mT9">https://godbolt.org/g/5f6mT9</a></p></li></ul></div></div></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/either-vs-error-codes","query":{},"buildId":"zumqXaU5fk-68lIEJ-riC","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" async=""></script><script src="/_next/static/chunks/pages/blog/either-vs-error-codes-58330708a9243f09a0dd.js" async=""></script><script src="/_next/static/zumqXaU5fk-68lIEJ-riC/_buildManifest.js" async=""></script><script src="/_next/static/zumqXaU5fk-68lIEJ-riC/_ssgManifest.js" async=""></script></body></html>