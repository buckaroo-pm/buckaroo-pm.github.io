<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><link rel="stylesheet" type="text/css" href="/prism.css"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/c-coroutine-ts-its-about-inversion-of-control-d655f91b9b92c6edd8ac.js" as="script"/></head><body><div id="__next"><div class="site"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div style="width:100%;max-height:80vh;overflow:hidden"><img src="/posts/coroutine.jpeg" style="width:100%"/></div><div class="banner white"><div class="view"><div><h1>C++ Coroutine TS — It’s about inversion of control!</h1><div class="post"><p>C++ Coroutine TS — It’s about inversion of control!</p><p>Many people look at the Coroutines TS and wonder, what is all of the fuss about?</p><p>This article gives you one motivating example where lazy sequences enable you to <em>seperate your concerns</em> and maximize code reuse without increasing complexity.</p><h2><strong>Example: Approximating the Golden Ratio</strong></h2><p>Every Math student knows how to approximate the golden ratio via the Fibonacci series:</p><pre><code>fib(n+1) / fib(n) -&gt; φ = 1.6180… 
</code></pre><p>Or using C++…</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">golden</span><span class="token punctuation">(</span><span class="token keyword">double</span> epsilon<span class="token operator">=</span><span class="token number">0.00001</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> ratio <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">tie</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> tuple<span class="token punctuation">{</span>b<span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> delta <span class="token operator">=</span> b <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a <span class="token operator">-</span> ratio<span class="token punctuation">;</span>
    ratio <span class="token operator">=</span> b <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">abs</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token operator">&lt;</span> epsilon <span class="token punctuation">)</span> 
      <span class="token keyword">return</span> ratio<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token function">golden</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>The function golden computes the golden ratio to a given approximation. On each iteration we get a little bit closer to the golden ratio, and the function returns once we are close enough.</p><p>This was straightforward, but what if we have some additional use-cases for golden?</p><ul><li><p>Maybe we want to limit the maximum number of iterations</p></li><li><p>Or maybe we want to print after every iteration</p></li><li><p>Or maybe we want to return a tuple of { fib(n+1), fib(n) }</p></li><li><p>Or maybe there is a use-case we haven’t thought of yet, but someone might have down the line</p></li></ul><p>In order to satisfy all of these, we would need to modify the algorithm and provide some customization points. We could add a set of configuration options or perhaps use generic functions:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">TestF</span> <span class="token keyword">class</span> <span class="token class-name">Map</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">golden</span><span class="token punctuation">(</span>TestF test<span class="token punctuation">,</span> Map f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> ratio <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
 
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">tie</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> tuple<span class="token punctuation">{</span>b<span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> delta <span class="token operator">=</span> b<span class="token operator">/</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a <span class="token operator">-</span> ratio<span class="token punctuation">;</span>
    ratio <span class="token operator">=</span> b<span class="token operator">/</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> ratio<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> 
      <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span><span class="token punctuation">,</span> ratio<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> test <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> delta<span class="token punctuation">,</span> …<span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token operator">&gt;</span><span class="token number">100</span> <span class="token operator">||</span> delta<span class="token operator">&lt;</span><span class="token number">0.0001</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 
    cout <span class="token operator">&lt;&lt;</span> ratio <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
 
  <span class="token keyword">auto</span> map <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">,</span> <span class="token keyword">auto</span><span class="token punctuation">,</span> <span class="token keyword">auto</span> a<span class="token punctuation">,</span> <span class="token keyword">auto</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> tuple<span class="token punctuation">{</span>b<span class="token punctuation">,</span> a<span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
 
  <span class="token keyword">auto</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">golden</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>We can see that the complexity of this function increased as we generalized it to handle more use-cases. This version of golden is much less readable than the original!</p><p>An alternative approach would have been to write a variant of this function for each specific use-case. Here’s a version that prints each iteration:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">golden</span><span class="token punctuation">(</span><span class="token keyword">double</span> epsilon<span class="token operator">=</span><span class="token number">0.00001</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> ratio <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">tie</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> tuple<span class="token punctuation">{</span>b<span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> delta <span class="token operator">=</span> b <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a <span class="token operator">-</span> ratio<span class="token punctuation">;</span>
    ratio <span class="token operator">=</span> b <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ratio <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">abs</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token operator">&lt;</span> epsilon <span class="token punctuation">)</span> 
      <span class="token keyword">return</span> ratio<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  
</code></pre><p>This would be readable, but now we have to maintain multiple functions!</p><blockquote><h1>How can we achieve reusability and simplicity?</h1></blockquote><p>Here’s the problem. The templated version is flexible, but it is not simple. The function variants are simple, but not flexible. How can we achieve reusability and simplicity?</p><h3>Why do we have to choose between them at all?</h3><p>This issue is caused by the fact that the algorithm controls the <em>iteration of the sequence</em> and <em>representation of the sequence</em>. These concerns should be separated.</p><p>So what kind of abstraction do we need to have the get the best of both worlds?</p><h2>Inversion of Control via Coroutines TS</h2><p>The Coroutines TS enables you to define lazy sequences. A lazy sequence is just an ordered set of values, where each value is only computes as it is requested.</p><p>You might think of a lazy sequence as a container with two properties:</p><ul><li><p>bool hasNext() is there another value in this sequence?</p></li><li><p>T takeNext() return the next value in the sequence, and advance by 1.</p></li></ul><p>As a result, we are able to decouple computation and representation, while maintaining full control over the sequence.</p><p>The Coroutine TS is quite low-level, so the following examples are built using our <a href="https://github.com/loopperfect/conduit">Conduit</a> library. This library gives us various primitives that we can use to create lazy sequences. We won’t dive into the implementation details here (there is full <a href="https://github.com/LoopPerfect/conduit">source-code over on GitHub</a>), but instead look at how all of this is useful!</p><p>OK. So using <a href="https://github.com/loopperfect/conduit">Conduit</a> we can define a lazy sequence for Fibonacci:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> seq<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
 
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">co_yield</span> a<span class="token punctuation">;</span>
    <span class="token function">tie</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> tuple<span class="token punctuation">{</span>b<span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Since the golden ratios are a transformation of the Fibonacci numbers, we can compute them using a scan:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fibRatios <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token function">scan</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">,</span> <span class="token keyword">auto</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">return</span> b<span class="token operator">/</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>Here we use the sequence to print the first 10 Fibonacci-ratios:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token operator">:</span> <span class="token function">fibRatios</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Now that we have an iterable, we can control the iteration by computing a delta as before:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> prevRatio <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ratio<span class="token operator">:</span> <span class="token function">fibRatios</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> ratio <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> delta <span class="token operator">=</span>  ratio <span class="token operator">-</span> prevRatio<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> delta <span class="token operator">&lt;</span> <span class="token number">0.0001</span><span class="token punctuation">)</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    prevRatio <span class="token operator">=</span> ratio<span class="token punctuation">;</span>
    n<span class="token operator">-</span> <span class="token operator">-</span> <span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>The beauty of this is that we can take just one definition of the sequence, but use it in multiple places. Unlike the templated solution we saw earlier, the code still maps closely to the mathematical definition.</p><p>If you are curious how to implement lazy sequences using the Coroutine TS,
checkout our <a href="https://github.com/loopperfect/conduit">GitHub</a>.</p><h2>Conclusion</h2><p>The Coroutines TS allows us to give control back to the consumer of an algorithm. This frees the implementer from providing customization hooks to the end-user to modify the behaviour of the algorithm.</p><h2>Since You’re Here…</h2><p>We recently announced <a href="https://buildinfer.loopperfect.com/">BuildInfer</a>, a new tool to optimize your C/C++ build scripts. <a href="https://buildinfer.loopperfect.com/">Take a look</a>!</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*pkwieX1RSK5S0LXbFyaEJg.png"/></p><h2>You might also be interested in…</h2><p><a href="https://hackernoon.com/error-handling-in-c-or-why-you-should-use-eithers-in-favor-of-exceptions-and-error-codes-f0640912eb45"><strong>Error Handling in C++ or: Why You Should Use Eithers in Favor of Exceptions and Error-codes</strong><em>TL;DR</em>hackernoon.com</a>
<a href="https://hackernoon.com/value-ptr-the-missing-c-smart-pointer-1f515664153e"><strong>value_ptr — The Missing C++ Smart-pointer</strong><em>TL;DR</em>hackernoon.com</a></p></div></div></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/c-coroutine-ts-its-about-inversion-of-control","query":{},"buildId":"zumqXaU5fk-68lIEJ-riC","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" async=""></script><script src="/_next/static/chunks/pages/blog/c-coroutine-ts-its-about-inversion-of-control-d655f91b9b92c6edd8ac.js" async=""></script><script src="/_next/static/zumqXaU5fk-68lIEJ-riC/_buildManifest.js" async=""></script><script src="/_next/static/zumqXaU5fk-68lIEJ-riC/_ssgManifest.js" async=""></script></body></html>