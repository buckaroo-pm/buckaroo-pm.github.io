_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[19],{VbIA:function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/even-more-reasons-to-use-buck",function(){return a("x4X5")}])},x4X5:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"default",(function(){return p}));var n=a("rePB"),o=a("Ff2n"),r=(a("q1tI"),a("7ljp")),s=a("ZDfL");function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){Object(n.a)(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}var l={title:"(Even) More Reasons to use Buck Build",banner:"/posts/even-more-reasons-to-use-buck.jpeg",author:"Team Buckaroo",created:"2018-10-12T11:00:00.000Z",attribution:"\u201cWhy? signage near grass during daytime\u201d by Ken Treloar on Unsplash",__resourcePath:"blog/even-more-reasons-to-use-buck.md",__scans:{},layout:"index"},u={frontMatter:l},h=s.a;function p(e){var t=e.components,a=Object(o.a)(e,["components"]);return Object(r.a)(h,i(i(i({},u),a),{},{components:t,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"Excellent Precompiled Header Support"),Object(r.a)("p",null,"Most people have a love-hate relationship with precompiled headers (PCH). On the one hand, they can dramatically accelerate your build-times from scratch (30% is not unheard of), but on the other hand, they ",Object(r.a)("em",{parentName:"p"},"can")," have devastating effects on your incremental build-times."),Object(r.a)("p",null,"Once in use, precompiled headers must be updated every time an included header changes. Now, every translation-unit that uses the PCH will also need to be recompiled, which may be far more often than necessary. PCHs effectively make every translation-unit depend on every header file in the PCH."),Object(r.a)("p",null,"However, with Buck you can have the best of both worlds. By switching enable_pch for your builds from scratch (e.g. CI builds) and then disabling it for incremental builds (e.g. for development) you can use PCHs only when appropriate. Buck encodes PCHs as a high-level abstraction, so no boiler-plate code in your build scripts is required to implement this."),Object(r.a)("p",null,"Furthermore, Buck ensures that all PCHs, libraries and executables use the same set of compiler and preprocessor flags."),Object(r.a)("h2",null,"Cache Sharing is Built-in"),Object(r.a)("p",null,"Have you ever hesitated to switch branch when reviewing a PR because it might trigger a full rebuild? Buck can share your cache via your file-system or a HTTP. This means that you can switch to a different branch and return back, whilst maintaining your build cache."),Object(r.a)("h2",null,"Builds are Reproducible"),Object(r.a)("p",null,"Build steps can be very complex, with identical builds resulting in slight differences on a binary level. As a result the hash of artefacts is not reproducible, causing many unnecessary rebuilds due to cache misses. Buck orchestrates common tools such as GCC so as to ensure that the artefact hash only changes with its inputs. With Buck you will rebuild less often."),Object(r.a)("h2",null,"Good Support for Custom Build-scripts"),Object(r.a)("p",null,"Unlike most build-systems, Buck caches every artefact, including generated files. Each artefact is only rebuilt if the hash of its dependencies change. This is more comprehensive than solutions that only cache C++ compiler artefacts, such as CCache."),Object(r.a)("h2",null,"Robust Toolchain Support"),Object(r.a)("p",null,"Build-systems without many abstractions, such as Make, depend on conventions to define your toolchain. For example, the C++ compiler might be defined as $CXX. This is brittle, because it requires everyone to follow the same convention, and can prove to be a nightmare when you have many dependencies. Buck works at a higher level of abstraction, so you define your toolchain once and it guarantees that it is respected across your entire project."),Object(r.a)("h2",null,"Extra: Experimental Support for Skylark"),Object(r.a)("p",null,"Buck and Bazel are converging to the same build description language: Skylark. Skylark is a subset of Python that offers faster parsing time, among other things. In some large projects, this reduces the parsing time from a couple of minutes to just a couple of seconds."),Object(r.a)("h2",null,"You may also be interested in\u2026"),Object(r.a)("p",null,Object(r.a)("a",i({parentName:"p"},{href:"https://hackernoon.com/7-reasons-to-use-buck-build-5b44d7413585"}),Object(r.a)("strong",{parentName:"a"},"7 Reasons to Use Buck Build"),Object(r.a)("em",{parentName:"a"},"Buck is a cross-platform, cross-language build system made for large scale compilation at Facebook. All Buckaroo\u2026"),"hackernoon.com"),"\n",Object(r.a)("a",i({parentName:"p"},{href:"https://hackernoon.com/lessons-learned-from-porting-300-projects-to-buck-build-ff6463b65142"}),Object(r.a)("strong",{parentName:"a"},"Lessons Learned from Porting 300 C/C++ Projects to Buck Build"),Object(r.a)("em",{parentName:"a"},"With Buckaroo we are turning the huge ecosystem of C/C++ projects into a collection of easily composable building\u2026"),"hackernoon.com")))}p.isMDXComponent=!0}},[["VbIA",0,2,1,3,4]]]);