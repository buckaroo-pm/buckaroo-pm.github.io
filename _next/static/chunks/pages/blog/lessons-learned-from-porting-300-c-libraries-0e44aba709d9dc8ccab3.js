_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[27],{"9Bp5":function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/lessons-learned-from-porting-300-c-libraries",function(){return a("tJm5")}])},tJm5:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"default",(function(){return h}));var o=a("rePB"),r=a("Ff2n"),i=(a("q1tI"),a("7ljp")),n=a("ZDfL");function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){Object(o.a)(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}var c={title:"Lessons Learned from Porting 300 C/C++ Projects to Buck Build",banner:"/posts/300packages.jpeg",author:"Team Buckaroo",created:"2017-05-16T11:00:00.000Z",__resourcePath:"blog/lessons-learned-from-porting-300-c-libraries.md",__scans:{},layout:"index"},p={frontMatter:c},u=n.a;function h(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.a)(u,l(l(l({},p),a),{},{components:t,mdxType:"MDXLayout"}),Object(i.a)("p",null,"With ",Object(i.a)("a",l({parentName:"p"},{href:"https://www.buckaroo.pm/"}),"Buckaroo")," we are turning the huge ecosystem of C/C++ projects into a collection of easily composable building blocks. We can\u2019t do this alone, but to kickstart the community we took it upon ourselves to port 300 projects to the ",Object(i.a)("a",l({parentName:"p"},{href:"https://buckbuild.com/"}),"Buck build system"),"."),Object(i.a)("p",null,"The libraries we chose were based on their popularity on GitHub, StackOverflow and requests from our mailing list. They ranged from ",Object(i.a)("a",l({parentName:"p"},{href:"https://www.buckaroo.pm/project/philsquared/catch"}),"tiny header-only libraries")," to ",Object(i.a)("a",l({parentName:"p"},{href:"https://www.buckaroo.pm/project/boost/graph"}),"monolithic C++ projects")," to ",Object(i.a)("a",l({parentName:"p"},{href:"https://www.buckaroo.pm/project/openssl/openssl"}),"old, but critical, C libraries"),"."),Object(i.a)("p",null,"For every library we tried to do a complete port to Buck. There were a few cases where this didn\u2019t work out; sometimes the project structure was so convoluted that we decided it was more practical to wrap the existing build system. We can revisit those projects later, but for the most part, the porting effort was successful."),Object(i.a)("p",null,"Having studied so many projects, we thought it would be good to compile a list of DOs and DON\u2019Ts for architecting clean C/C++ libraries."),Object(i.a)("h2",null,"DON\u2019T: Concatenate .cpp files into a single translation-unit"),Object(i.a)("p",null,"An anti-pattern found in many C/C++ projects is the practice of combining multiple C/C++ files into a single translation-unit for compilation. The theory goes that this improves compilation times because the preprocessor and parsing steps only need to be performed once for the entire build. This is true for a single build, but it destroys your ability to do incremental builds. With a single translation-unit, the compiler must perform the entire build from scratch whenever any of the project files change!"),Object(i.a)("h2",null,"DO: Make your dependencies clear"),Object(i.a)("p",null,"Using existing libraries is a net-positive for everyone. The library code gets better tested, which is great for the community, and less work is repeated, which is great for you! However, the lack of a dominant C/C++ package manager means that multiple approaches to this \u2014 some sub-optimal \u2014 are being used."),Object(i.a)("p",null,"When writing your library, make sure you document its dependencies clearly. Here are some reasonable ways to do it:"),Object(i.a)("ul",null,Object(i.a)("li",{parentName:"ul"},Object(i.a)("p",{parentName:"li"},"Git submodules")),Object(i.a)("li",{parentName:"ul"},Object(i.a)("p",{parentName:"li"},"A list of apt-get or brew install commands \u2014 although users of your library may be annoyed if they have to modify their system to use it!")),Object(i.a)("li",{parentName:"ul"},Object(i.a)("p",{parentName:"li"},"A good ",Object(i.a)("a",l({parentName:"p"},{href:"https://buckaroo.pm/"}),"package manager")))),Object(i.a)("h2",null,"DON\u2019T: Use include_next, unless you really have to"),Object(i.a)("p",null,"#include_next is an obscure feature of the preprocessor that allows the user to include a file inside itself. It is intended to allow for patching of system headers; the ",Object(i.a)("a",l({parentName:"p"},{href:"https://gcc.gnu.org/onlinedocs/cpp/Wrapper-Headers.html"}),"GCC docs")," explain it as follows:"),Object(i.a)("blockquote",null,Object(i.a)("p",{parentName:"blockquote"},"Sometimes it is necessary to adjust the contents of a system-provided header file without editing it directly. GCC\u2019s fixincludes operation does this, for example. One way to do that would be to create a new header file with the same name and insert it in the search path before the original header. That works fine as long as you\u2019re willing to replace the old header entirely. But what if you want to refer to the old header from the new one?")),Object(i.a)("p",null,"In practice, this feature can lead to very confusing outcomes; many programmers aren\u2019t familiar with it; and its behaviour can be difficult to trace. Avoid using this feature unless you really have to."),Object(i.a)("h2",null,"DO: Keep private headers and exported headers separate"),Object(i.a)("p",null,"Maintaining a well-defined API for your library is a really good idea. It allows you to make under-the-hood tweaks without breaking downstream consumers and it provides a clear surface for unit-testing."),Object(i.a)("p",null,"Ideally, you should separate the private and exported headers into their own folders. I quite like this convention:"),Object(i.a)("ul",null,Object(i.a)("li",{parentName:"ul"},Object(i.a)("p",{parentName:"li"},"include\u2014 Headers that are made available to users of the library")),Object(i.a)("li",{parentName:"ul"},Object(i.a)("p",{parentName:"li"},"private\u2014 Headers that are required to compile the library, but should not be made available to consumers of the library"))),Object(i.a)("h2",null,"DON\u2019T: Include .cpp files"),Object(i.a)("p",null,"The C/C++ preprocessor is incredibly flexible and allows you do things you probably shouldn\u2019t. One example is including .cpp files. This is extremely confusing as the file extension no longer matches the intent. Is this file meant to be a header? Then give it a .h or .hpp extension. Is this file meant to be compiled? Then don\u2019t include it."),Object(i.a)("h2",null,"DO: In your examples, use the library how it is intended to be used"),Object(i.a)("p",null,"Many times I found examples that were written as if they are in the source directory of the library:"),Object(i.a)("pre",null,Object(i.a)("code",l({parentName:"pre"},{}),"#include \u201c../../things.h\u201d\n")),Object(i.a)("p",null,"Examples should be show-case of the intended usage of your library. This means including the headers as they are meant to be used downstream:"),Object(i.a)("pre",null,Object(i.a)("code",l({parentName:"pre"},{}),"#include <my-library/things.h>\n")),Object(i.a)("p",null,"Of course, this requires that you set your include paths correctly, but a ",Object(i.a)("a",l({parentName:"p"},{href:"https://www.buckbuild.com"}),"good build system")," should make this trivial."),Object(i.a)("h2",null,"DON\u2019T: Copy your dependencies into your project"),Object(i.a)("p",null,"If you are not using a ",Object(i.a)("a",l({parentName:"p"},{href:"https://buckaroo.pm/"}),"package manager"),", it can be tempting to just copy the projects that you depend on into source-control. This has the advantage that everyone is building the same code, but it can be a nightmare for consumers of your library."),Object(i.a)("p",null,"For example, suppose you are the author of library A, which depends on library Bv1. However, one of your users is writing library C, which depends on A and Bv2. Now, when they try to build your project they get symbol collisions and must either downgrade to Bv1 or submit a PR on A! A much better approach is to use a package manager that can resolve B to a version that works for all dependencies in the project. At the very least, using Git submodules can make such upgrades more manageable."),Object(i.a)("p",null,"An exception to this rule is the inclusion of tiny header-only libraries that are used for development tasks, such as the ",Object(i.a)("a",l({parentName:"p"},{href:"https://github.com/philsquared/Catch"}),"Catch testing framework"),"."),Object(i.a)("h2",null,"DO: Namespace your header files"),Object(i.a)("p",null,"You should choose a unique name for your library \u2014 use ",Object(i.a)("a",l({parentName:"p"},{href:"http://mrsharpoblunto.github.io/foswig.js/"}),"a generator")," if you get stuck \u2014 then place all of your exported headers into a folder with that name. This makes name collisions with other libraries far less likely."),Object(i.a)("h2",null,"DON\u2019T: Overuse the preprocessor"),Object(i.a)("p",null,"The C/C++ preprocessor is itself a ",Object(i.a)("a",l({parentName:"p"},{href:"http://www.ioccc.org/2001/herrmann1.hint"}),"programming language"),", enabling all kinds of compile-time magic and code-generation. The problem is that the preprocessor can be very hard to debug since the tooling is not as good as that available for C/C++."),Object(i.a)("p",null,"So why use the preprocessor? In the past, the logic went that the preprocessor is guaranteed to execute at compile-time and therefore to gain maximum performance, logic should be implemented there where possible. Compilers have improved greatly since then, and will now ",Object(i.a)("a",l({parentName:"p"},{href:"https://godbolt.org/g/90NjyJ"}),"do much of this work for you"),". As such, with modern tooling it is best to avoid implementing logic in the preprocessor when it could be implemented in C/C++. Trust your compiler!"),Object(i.a)("p",null,"If you must use the preprocessor, for example to implement ",Object(i.a)("a",l({parentName:"p"},{href:"https://github.com/jamboree/co2"}),"stackless coroutines"),", then aim to minimize its usage. Hopefully these cases will be incorporated into the C++ language in the future, much like templates were in the past."),Object(i.a)("h2",null,"DO: Abstract platform differences using files"),Object(i.a)("p",null,"It might be tempting to sprinkle a couple #ifdef ",Object(i.a)("strong",{parentName:"p"},"MACOS")," #endif commands in your source-code, but the truth is that it makes it very hard to read the code. If you split your platform-specific implementations into separate files, then your build system can include, compile and link the appropriate files. This makes the code more maintainable and approachable for new readers."),Object(i.a)("h2",null,"DON\u2019T: Depend on compiler specific features (unless you really have to)"),Object(i.a)("p",null,"The big three C++ compilers (Clang, VC++, GCC) all have their quirks and it is possible to write code that compiles in one but not the others. This is usually avoidable by sticking to the language standard (or a subset in the case of VC++)."),Object(i.a)("p",null,"I get it \u2014 some of these vendor-specific features can be convenient (#pragma once) \u2014 but by not making your library portable you\u2019re reducing the impact of your work. You lose the satisfaction of making a big impact on the C++ community and the community lose what could have been a great, portable library."),Object(i.a)("p",null,"If you need specific features, such as __builtin_popcount, write an abstraction over the built-in version and also a portable version. Then, split the implementations into separate files and let your build system know about your intent. Better yet, reuse ",Object(i.a)("a",l({parentName:"p"},{href:"http://buckaroo.pm/project/boost/thread"}),"an abstraction that has already been written"),"."),Object(i.a)("h2",null,"DO: Use folders to partition categories of files"),Object(i.a)("p",null,"Listing project files by hand is quite tedious. A common solution is to use a ",Object(i.a)("a",l({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Glob_(programming)"}),"glob")," command. Glob is a very powerful tool, but you can make things much easier by laying out your files in a glob friendly way. This means partitioning files into logical folders based on their purpose."),Object(i.a)("h3",null,"A poorly arranged project"),Object(i.a)("pre",null,Object(i.a)("code",l({parentName:"pre"},{}),"    .\n    \u251c\u2500\u2500 common.cpp\n    \u251c\u2500\u2500 foo.cpp\n    \u251c\u2500\u2500 pthread.cpp\n    \u2514\u2500\u2500 win_thread.cpp\n")),Object(i.a)("h3",null,"A tidily arranged project"),Object(i.a)("pre",null,Object(i.a)("code",l({parentName:"pre"},{}),"    .\n    \u251c\u2500\u2500 common\n    \u2502   \u251c\u2500\u2500 common.cpp\n    \u2502   \u2514\u2500\u2500 foo.cpp\n    \u251c\u2500\u2500 linux\n    \u2502   \u2514\u2500\u2500 pthread.cpp\n    \u2514\u2500\u2500 windows\n        \u2514\u2500\u2500 win_thread.cpp\n")),Object(i.a)("h2",null,"That\u2019s it! \ud83d\ude4c"),Object(i.a)("p",null,"The Buckaroo packages are ",Object(i.a)("a",l({parentName:"p"},{href:"https://buckaroo.readthedocs.io/en/latest/installation.html"}),"ready to use right now"),", and we are hard at work ",Object(i.a)("a",l({parentName:"p"},{href:"https://github.com/LoopPerfect/buckaroo-wishlist"}),"porting more"),". If you require a particular library, ",Object(i.a)("a",l({parentName:"p"},{href:"https://github.com/LoopPerfect/buckaroo-wishlist/issues/new"}),"create an issue on the wishlist"),". Or (even better) if you would like to contribute, ",Object(i.a)("a",l({parentName:"p"},{href:"https://github.com/LoopPerfect/buckaroo-recipes"}),"PRs are always welcome"),"!"))}h.isMDXComponent=!0}},[["9Bp5",0,2,1,3,4]]]);