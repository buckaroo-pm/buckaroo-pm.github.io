{"pageProps":{"data":{"packageName":"buckaroo-pm/draco","name":"google/draco","licence":"Apache-2.0","description":"Draco is a library for compressing and decompressing 3D geometric meshes and point clouds. It is intended to improve the storage and transmission of 3D graphics.","readme":"\n<p align=\"center\">\n<img src=\"docs/DracoLogo.jpeg\" />\n</p>\n\nNews\n=======\n### Version 1.3.4 release\n* Released Draco Animation code\n* Fixes for Unity\n* Various file location and name changes\n\n### Version 1.3.3 release\n* Added ExpertEncoder to the Javascript API\n  * Allows developers to set quantization options per attribute id\n* Bug fixes\n\n### Version 1.3.2 release\n* Bug fixes\n\n### Version 1.3.1 release\n* Fix issue with multiple attributes when skipping an attribute transform\n\n### Version 1.3.0 release\n* Improved kD-tree based point cloud encoding\n  * Now applicable to point clouds with any number of attributes\n  * Support for all integer attribute types and quantized floating point types\n* Improved mesh compression up to 10% (on average ~2%)\n  * For meshes, the 1.3.0 bitstream is fully compatible with 1.2.x decoders\n* Improved Javascript API\n  * Added support for all signed and unsigned integer types\n  * Added support for point clouds to our Javascript encoder API\n* Added support for integer properties to the PLY decoder\n* Bug fixes\n\n### Previous releases\nhttps://github.com/google/draco/releases\n\nDescription\n===========\n\nDraco is a library for compressing and decompressing 3D geometric [meshes] and\n[point clouds]. It is intended to improve the storage and transmission of 3D\ngraphics.\n\nDraco was designed and built for compression efficiency and speed. The code\nsupports compressing points, connectivity information, texture coordinates,\ncolor information, normals, and any other generic attributes associated with\ngeometry. With Draco, applications using 3D graphics can be significantly\nsmaller without compromising visual fidelity. For users, this means apps can\nnow be downloaded faster, 3D graphics in the browser can load quicker, and VR\nand AR scenes can now be transmitted with a fraction of the bandwidth and\nrendered quickly.\n\nDraco is released as C++ source code that can be used to compress 3D graphics\nas well as C++ and Javascript decoders for the encoded data.\n\n\n_**Contents**_\n\n  * [Building](#building)\n    * [CMake Basics](#cmake-basics)\n    * [Mac OS X](#mac-os-x)\n    * [Windows](#windows)\n    * [CMake Build Configuration](#cmake-build-configuration)\n      * [Debugging and Optimization](#debugging-and-optimization)\n      * [Googletest Integration](#googletest-integration)\n      * [Javascript Encoder/Decoder](#javascript-encoderdecoder)\n    * [Android Studio Project Integration](#android-studio-project-integration)\n    * [Native Android Builds](#native-android-builds)\n  * [Usage](#usage)\n    * [Command Line Applications](#command-line-applications)\n    * [Encoding Tool](#encoding-tool)\n    * [Encoding Point Clouds](#encoding-point-clouds)\n    * [Decoding Tool](#decoding-tool)\n    * [C++ Decoder API](#c-decoder-api)\n    * [Javascript Encoder API](#javascript-encoder-api)\n    * [Javascript Decoder API](#javascript-decoder-api)\n    * [Javascript Decoder Performance](#javascript-decoder-performance)\n    * [Metadata API](#metadata-api)\n    * [NPM Package](#npm-package)\n    * [three.js Renderer Example](#threejs-renderer-example)\n  * [Support](#support)\n  * [License](#license)\n  * [References](#references)\n\n\nBuilding\n========\nFor all platforms, you must first generate the project/make files and then\ncompile the examples.\n\nCMake Basics\n------------\n\nTo generate project/make files for the default toolchain on your system, run\n`cmake` from a directory where you would like to generate build files, and pass\nit the path to your Draco repository.\n\n~~~~~ bash\n$ cmake path/to/draco\n~~~~~\n\nOn Windows, the above command will produce Visual Studio project files for the\nnewest Visual Studio detected on the system. On Mac OS X and Linux systems,\nthe above command will produce a `makefile`.\n\nTo control what types of projects are generated, add the `-G` parameter to the\n`cmake` command. This argument must be followed by the name of a generator.\nRunning `cmake` with the `--help` argument will list the available\ngenerators for your system.\n\nMac OS X\n---------\n\nOn Mac OS X, run the following command to generate Xcode projects:\n\n~~~~~ bash\n$ cmake path/to/draco -G Xcode\n~~~~~\n\nWindows\n-------\n\nOn a Windows box you would run the following command to generate Visual Studio\n2015 projects:\n\n~~~~~ bash\nC:\\Users\\nobody> cmake path/to/draco -G \"Visual Studio 14 2015\"\n~~~~~\n\nTo generate 64-bit Windows Visual Studio 2015 projects:\n\n~~~~~ bash\nC:\\Users\\nobody> cmake path/to/draco -G \"Visual Studio 14 2015 Win64\"\n~~~~~\n\n\nCMake Build Configuration\n-------------------------\n\nDebugging and Optimization\n--------------------------\n\nUnlike Visual Studio and Xcode projects, the build configuration for make\nbuilds is controlled when you run `cmake`. The following examples demonstrate\nvarious build configurations.\n\nOmitting the build type produces makefiles that use release build flags\nby default:\n\n~~~~~ bash\n$ cmake path/to/draco\n~~~~~\n\nA makefile using release (optimized) flags is produced like this:\n\n~~~~~ bash\n$ cmake path/to/draco -DCMAKE_BUILD_TYPE=release\n~~~~~\n\nA release build with debug info can be produced as well:\n\n~~~~~ bash\n$ cmake path/to/draco -DCMAKE_BUILD_TYPE=relwithdebinfo\n~~~~~\n\nAnd your standard debug build will be produced using:\n\n~~~~~ bash\n$ cmake path/to/draco -DCMAKE_BUILD_TYPE=debug\n~~~~~\n\nTo enable the use of sanitizers when the compiler in use supports them, set the\nsanitizer type when running CMake:\n\n~~~~~ bash\n$ cmake path/to/draco -DSANITIZE=address\n~~~~~\n\nGoogletest Integration\n----------------------\n\nDraco includes testing support built using Googletest. To enable Googletest unit\ntest support the ENABLE_TESTS cmake variable must be turned on at cmake\ngeneration time:\n\n~~~~~ bash\n$ cmake path/to/draco -DENABLE_TESTS=ON\n~~~~~\n\nWhen cmake is used as shown in the above example the Draco cmake file assumes\nthat the Googletest source directory is a sibling of the Draco repository. To\nchange the location to something else use the GTEST_SOURCE_DIR cmake variable:\n\n~~~~~ bash\n$ cmake path/to/draco -DENABLE_TESTS=ON -DGTEST_SOURCE_DIR=path/to/googletest\n~~~~~\n\nTo run the tests just execute `draco_tests` from your toolchain's build output\ndirectory.\n\n\nJavascript Encoder/Decoder\n------------------\n\nThe javascript encoder and decoder can be built using the existing cmake build\nfile by passing the path the Emscripten's cmake toolchain file at cmake\ngeneration time in the CMAKE_TOOLCHAIN_FILE variable.\nIn addition, the EMSCRIPTEN environment variable must be set to the local path\nof the parent directory of the Emscripten tools directory.\n\n~~~~~ bash\n# Make the path to emscripten available to cmake.\n$ export EMSCRIPTEN=/path/to/emscripten/tools/parent\n\n# Emscripten.cmake can be found within your Emscripten installation directory,\n# it should be the subdir: cmake/Modules/Platform/Emscripten.cmake\n$ cmake path/to/draco -DCMAKE_TOOLCHAIN_FILE=/path/to/Emscripten.cmake\n\n# Build the Javascript encoder and decoder.\n$ make\n~~~~~\n\nWebAssembly Decoder\n-------------------\n\nThe WebAssembly decoder can be built using the existing cmake build file by\npassing the path the Emscripten's cmake toolchain file at cmake generation time\nin the CMAKE_TOOLCHAIN_FILE variable and enabling the WASM build option.\nIn addition, the EMSCRIPTEN environment variable must be set to the local path\nof the parent directory of the Emscripten tools directory.\n\nMake sure to have the correct version of Emscripten installed for WebAssembly\nbuilds. See https://developer.mozilla.org/en-US/docs/WebAssembly.\n\n~~~~~ bash\n# Make the path to emscripten available to cmake.\n$ export EMSCRIPTEN=/path/to/emscripten/tools/parent\n\n# Emscripten.cmake can be found within your Emscripten installation directory,\n# it should be the subdir: cmake/Modules/Platform/Emscripten.cmake\n$ cmake path/to/draco -DCMAKE_TOOLCHAIN_FILE=/path/to/Emscripten.cmake -DENABLE_WASM=ON\n\n# Build the WebAssembly decoder.\n$ make\n\n# Run the Javascript wrapper through Closure.\n$ java -jar closure.jar --compilation_level SIMPLE --js draco_decoder.js --js_output_file draco_wasm_wrapper.js\n\n~~~~~\n\nWebAssembly Mesh Only Decoder\n-----------------------------\n\n~~~~~ bash\n\n# cmake command line for mesh only WebAssembly decoder.\n$ cmake path/to/draco -DCMAKE_TOOLCHAIN_FILE=/path/to/Emscripten.cmake -DENABLE_WASM=ON -DENABLE_POINT_CLOUD_COMPRESSION=OFF\n\n~~~~~\n\nWebAssembly Point Cloud Only Decoder\n-----------------------------\n\n~~~~~ bash\n\n# cmake command line for point cloud only WebAssembly decoder.\n$ cmake path/to/draco -DCMAKE_TOOLCHAIN_FILE=/path/to/Emscripten.cmake -DENABLE_WASM=ON -DENABLE_MESH_COMPRESSION=OFF\n\n~~~~~\n\n\nAndroid Studio Project Integration\n----------------------------------\n\nTo include Draco in an existing or new Android Studio project, reference it\nfrom the `cmake` file of an existing native project that has a minimum SDK\nversion of 18 or higher. The project must support C++11.\nTo add Draco to your project:\n\n  1. Add the following somewhere within the `CMakeLists.txt` for your project\n     before the `add_library()` for your project's native-lib:\n\n     ~~~~~ cmake\n     # Note \"/path/to/draco\" must be changed to the path where you have cloned\n     # the Draco sources.\n\n     add_subdirectory(/path/to/draco\n                      ${CMAKE_BINARY_DIR}/draco_build)\n     include_directories(\"${CMAKE_BINARY_DIR}\" /path/to/draco)\n     ~~~~~\n\n  2. Add the library target \"draco\" to the `target_link_libraries()` call for\n     your project's native-lib. The `target_link_libraries()` call for an\n     empty activity native project looks like this after the addition of\n     Draco:\n\n     ~~~~~ cmake\n     target_link_libraries( # Specifies the target library.\n                            native-lib\n\n                            # Tells cmake this build depends on libdraco.\n                            draco\n\n                            # Links the target library to the log library\n                            # included in the NDK.\n                            ${log-lib} )\n     ~~~~~\n  3. Add macro to build.gradle for the features you need:\n     ~~~~~ cmake\n     android {\n         ...\n         defaultConfig {\n             ...\n             externalNativeBuild {\n                 cmake {\n                     cppFlags \"-std=c++11\"\n                     arguments \"-DANDROID_STL=c++_shared\"\n                 }\n             }\n         }\n         externalNativeBuild {\n             cmake {\n                 path \"CMakeLists.txt\"\n             }\n         }\n     }\n\nNative Android Builds\n---------------------\n\nIt's sometimes useful to build Draco command line tools and run them directly on\nAndroid devices via adb.\n\n~~~~~ bash\n# All targets require CMAKE_ANDROID_NDK. It must be set in the environment.\n$ export CMAKE_ANDROID_NDK=path/to/ndk\n\n# arm\n$ cmake path/to/draco -DCMAKE_TOOLCHAIN_FILE=path/to/draco/cmake/toolchains/armv7-android-ndk-libcpp.cmake\n$ make\n\n# arm64\n$ cmake path/to/draco -DCMAKE_TOOLCHAIN_FILE=path/to/draco/cmake/toolchains/arm64-android-ndk-libcpp.cmake\n$ make\n\n# x86\n$ cmake path/to/draco -DCMAKE_TOOLCHAIN_FILE=path/to/draco/cmake/toolchains/x86-android-ndk-libcpp.cmake\n$ make\n\n# x86_64\n$ cmake path/to/draco -DCMAKE_TOOLCHAIN_FILE=path/to/draco/cmake/toolchains/x86_64-android-ndk-libcpp.cmake\n$ make\n~~~~~\n\nAfter building the tools they can be moved to an android device via the use of\n`adb push`, and then run within an `adb shell` instance.\n\n\nUsage\n======\n\nCommand Line Applications\n------------------------\n\nThe default target created from the build files will be the `draco_encoder`\nand `draco_decoder` command line applications. For both applications, if you\nrun them without any arguments or `-h`, the applications will output usage and\noptions.\n\nEncoding Tool\n-------------\n\n`draco_encoder` will read OBJ or PLY files as input, and output Draco-encoded\nfiles. We have included Stanford's [Bunny] mesh for testing. The basic command\nline looks like this:\n\n~~~~~ bash\n./draco_encoder -i testdata/bun_zipper.ply -o out.drc\n~~~~~\n\nA value of `0` for the quantization parameter will not perform any quantization\non the specified attribute. Any value other than `0` will quantize the input\nvalues for the specified attribute to that number of bits. For example:\n\n~~~~~ bash\n./draco_encoder -i testdata/bun_zipper.ply -o out.drc -qp 14\n~~~~~\n\nwill quantize the positions to 14 bits (default for the position coordinates).\n\nIn general, the more you quantize your attributes the better compression rate\nyou will get. It is up to your project to decide how much deviation it will\ntolerate. In general, most projects can set quantization values of about `14`\nwithout any noticeable difference in quality.\n\nThe compression level (`-cl`) parameter turns on/off different compression\nfeatures.\n\n~~~~~ bash\n./draco_encoder -i testdata/bun_zipper.ply -o out.drc -cl 8\n~~~~~\n\nIn general, the highest setting, `10`, will have the most compression but\nworst decompression speed. `0` will have the least compression, but best\ndecompression speed. The default setting is `7`.\n\nEncoding Point Clouds\n---------------------\n\nYou can encode point cloud data with `draco_encoder` by specifying the\n`-point_cloud` parameter. If you specify the `-point_cloud` parameter with a\nmesh input file, `draco_encoder` will ignore the connectivity data and encode\nthe positions from the mesh file.\n\n~~~~~ bash\n./draco_encoder -point_cloud -i testdata/bun_zipper.ply -o out.drc\n~~~~~\n\nThis command line will encode the mesh input as a point cloud, even though the\ninput might not produce compression that is representative of other point\nclouds. Specifically, one can expect much better compression rates for larger\nand denser point clouds.\n\nDecoding Tool\n-------------\n\n`draco_decoder` will read Draco files as input, and output OBJ or PLY files.\nThe basic command line looks like this:\n\n~~~~~ bash\n./draco_decoder -i in.drc -o out.obj\n~~~~~\n\nC++ Decoder API\n-------------\n\nIf you'd like to add decoding to your applications you will need to include\nthe `draco_dec` library. In order to use the Draco decoder you need to\ninitialize a `DecoderBuffer` with the compressed data. Then call\n`DecodeMeshFromBuffer()` to return a decoded mesh object or call\n`DecodePointCloudFromBuffer()` to return a decoded `PointCloud` object. For\nexample:\n\n~~~~~ cpp\ndraco::DecoderBuffer buffer;\nbuffer.Init(data.data(), data.size());\n\nconst draco::EncodedGeometryType geom_type =\n    draco::GetEncodedGeometryType(&buffer);\nif (geom_type == draco::TRIANGULAR_MESH) {\n  unique_ptr<draco::Mesh> mesh = draco::DecodeMeshFromBuffer(&buffer);\n} else if (geom_type == draco::POINT_CLOUD) {\n  unique_ptr<draco::PointCloud> pc = draco::DecodePointCloudFromBuffer(&buffer);\n}\n~~~~~\n\nPlease see [src/draco/mesh/mesh.h](src/draco/mesh/mesh.h) for the full `Mesh` class interface and\n[src/draco/point_cloud/point_cloud.h](src/draco/point_cloud/point_cloud.h) for the full `PointCloud` class interface.\n\n\nJavascript Encoder API\n----------------------\nThe Javascript encoder is located in `javascript/draco_encoder.js`. The encoder\nAPI can be used to compress mesh and point cloud. In order to use the encoder,\nyou need to first create an instance of `DracoEncoderModule`. Then use this\ninstance to create `MeshBuilder` and `Encoder` objects. `MeshBuilder` is used\nto construct a mesh from geometry data that could be later compressed by\n`Encoder`. First create a mesh object using `new encoderModule.Mesh()` . Then,\nuse `AddFacesToMesh()` to add indices to the mesh and use\n`AddFloatAttributeToMesh()` to add attribute data to the mesh, e.g. position,\nnormal, color and texture coordinates. After a mesh is constructed, you could\nthen use `EncodeMeshToDracoBuffer()` to compress the mesh. For example:\n\n~~~~~ js\nconst mesh = {\n  indices : new Uint32Array(indices),\n  vertices : new Float32Array(vertices),\n  normals : new Float32Array(normals)\n};\n\nconst encoderModule = DracoEncoderModule();\nconst encoder = new encoderModule.Encoder();\nconst meshBuilder = new encoderModule.MeshBuilder();\nconst dracoMesh = new encoderModule.Mesh();\n\nconst numFaces = mesh.indices.length / 3;\nconst numPoints = mesh.vertices.length;\nmeshBuilder.AddFacesToMesh(dracoMesh, numFaces, mesh.indices);\n\nmeshBuilder.AddFloatAttributeToMesh(dracoMesh, encoderModule.POSITION,\n  numPoints, 3, mesh.vertices);\nif (mesh.hasOwnProperty('normals')) {\n  meshBuilder.AddFloatAttributeToMesh(\n    dracoMesh, encoderModule.NORMAL, numPoints, 3, mesh.normals);\n}\nif (mesh.hasOwnProperty('colors')) {\n  meshBuilder.AddFloatAttributeToMesh(\n    dracoMesh, encoderModule.COLOR, numPoints, 3, mesh.colors);\n}\nif (mesh.hasOwnProperty('texcoords')) {\n  meshBuilder.AddFloatAttributeToMesh(\n    dracoMesh, encoderModule.TEX_COORD, numPoints, 3, mesh.texcoords);\n}\n\nif (method === \"edgebreaker\") {\n  encoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);\n} else if (method === \"sequential\") {\n  encoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);\n}\n\nconst encodedData = new encoderModule.DracoInt8Array();\n// Use default encoding setting.\nconst encodedLen = encoder.EncodeMeshToDracoBuffer(dracoMesh,\n                                                   encodedData);\nencoderModule.destroy(dracoMesh);\nencoderModule.destroy(encoder);\nencoderModule.destroy(meshBuilder);\n\n~~~~~\nPlease see [src/draco/javascript/emscripten/draco_web_encoder.idl](src/draco/javascript/emscripten/draco_web_encoder.idl) for the full API.\n\nJavascript Decoder API\n----------------------\n\nThe Javascript decoder is located in [javascript/draco_decoder.js](javascript/draco_decoder.js). The\nJavascript decoder can decode mesh and point cloud. In order to use the\ndecoder, you must first create an instance of `DracoDecoderModule`. The\ninstance is then used to create `DecoderBuffer` and `Decoder` objects. Set\nthe encoded data in the `DecoderBuffer`. Then call `GetEncodedGeometryType()`\nto identify the type of geometry, e.g. mesh or point cloud. Then call either\n`DecodeBufferToMesh()` or `DecodeBufferToPointCloud()`, which will return\na Mesh object or a point cloud. For example:\n\n~~~~~ js\n// Create the Draco decoder.\nconst decoderModule = DracoDecoderModule();\nconst buffer = new decoderModule.DecoderBuffer();\nbuffer.Init(byteArray, byteArray.length);\n\n// Create a buffer to hold the encoded data.\nconst decoder = new decoderModule.Decoder();\nconst geometryType = decoder.GetEncodedGeometryType(buffer);\n\n// Decode the encoded geometry.\nlet outputGeometry;\nlet status;\nif (geometryType == decoderModule.TRIANGULAR_MESH) {\n  outputGeometry = new decoderModule.Mesh();\n  status = decoder.DecodeBufferToMesh(buffer, outputGeometry);\n} else {\n  outputGeometry = new decoderModule.PointCloud();\n  status = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);\n}\n\n// You must explicitly delete objects created from the DracoDecoderModule\n// or Decoder.\ndecoderModule.destroy(outputGeometry);\ndecoderModule.destroy(decoder);\ndecoderModule.destroy(buffer);\n~~~~~\n\nPlease see [src/draco/javascript/emscripten/draco_web_decoder.idl](src/draco/javascript/emscripten/draco_web_decoder.idl) for the full API.\n\nJavascript Decoder Performance\n------------------------------\n\nThe Javascript decoder is built with dynamic memory. This will let the decoder\nwork with all of the compressed data. But this option is not the fastest.\nPre-allocating the memory sees about a 2x decoder speed improvement. If you\nknow all of your project's memory requirements, you can turn on static memory\nby changing `CMakeLists.txt` accordingly.\n\nMetadata API\n------------\nStarting from v1.0, Draco provides metadata functionality for encoding data\nother than geometry. It could be used to encode any custom data along with the\ngeometry. For example, we can enable metadata functionality to encode the name\nof attributes, name of sub-objects and customized information.\nFor one mesh and point cloud, it can have one top-level geometry metadata class.\nThe top-level metadata then can have hierarchical metadata. Other than that,\nthe top-level metadata can have metadata for each attribute which is called\nattribute metadata. The attribute metadata should be initialized with the\ncorrespondent attribute id within the mesh. The metadata API is provided both\nin C++ and Javascript.\nFor example, to add metadata in C++:\n\n~~~~~ cpp\ndraco::PointCloud pc;\n// Add metadata for the geometry.\nstd::unique_ptr<draco::GeometryMetadata> metadata =\n  std::unique_ptr<draco::GeometryMetadata>(new draco::GeometryMetadata());\nmetadata->AddEntryString(\"description\", \"This is an example.\");\npc.AddMetadata(std::move(metadata));\n\n// Add metadata for attributes.\ndraco::GeometryAttribute pos_att;\npos_att.Init(draco::GeometryAttribute::POSITION, nullptr, 3,\n             draco::DT_FLOAT32, false, 12, 0);\nconst uint32_t pos_att_id = pc.AddAttribute(pos_att, false, 0);\n\nstd::unique_ptr<draco::AttributeMetadata> pos_metadata =\n    std::unique_ptr<draco::AttributeMetadata>(\n        new draco::AttributeMetadata(pos_att_id));\npos_metadata->AddEntryString(\"name\", \"position\");\n\n// Directly add attribute metadata to geometry.\n// You can do this without explicitly add |GeometryMetadata| to mesh.\npc.AddAttributeMetadata(pos_att_id, std::move(pos_metadata));\n~~~~~\n\nTo read metadata from a geometry in C++:\n\n~~~~~ cpp\n// Get metadata for the geometry.\nconst draco::GeometryMetadata *pc_metadata = pc.GetMetadata();\n\n// Request metadata for a specific attribute.\nconst draco::AttributeMetadata *requested_pos_metadata =\n  pc.GetAttributeMetadataByStringEntry(\"name\", \"position\");\n~~~~~\n\nPlease see [src/draco/metadata](src/draco/metadata) and [src/draco/point_cloud](src/draco/point_cloud) for the full API.\n\nNPM Package\n-----------\nDraco NPM NodeJS package is located in [javascript/npm/draco3d](javascript/npm/draco3d). Please see the\ndoc in the folder for detailed usage.\n\nthree.js Renderer Example\n-------------------------\n\nHere's an [example] of a geometric compressed with Draco loaded via a\nJavascript decoder using the `three.js` renderer.\n\nPlease see the [javascript/example/README.md](javascript/example/README.md) file for more information.\n\nSupport\n=======\n\nFor questions/comments please email <draco-3d-discuss@googlegroups.com>\n\nIf you have found an error in this library, please file an issue at\n<https://github.com/google/draco/issues>\n\nPatches are encouraged, and may be submitted by forking this project and\nsubmitting a pull request through GitHub. See [CONTRIBUTING] for more detail.\n\nLicense\n=======\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n<http://www.apache.org/licenses/LICENSE-2.0>\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n\nReferences\n==========\n[example]:https://storage.googleapis.com/demos.webmproject.org/draco/draco_loader_throw.html\n[meshes]: https://en.wikipedia.org/wiki/Polygon_mesh\n[point clouds]: https://en.wikipedia.org/wiki/Point_cloud\n[Bunny]: https://graphics.stanford.edu/data/3Dscanrep/\n[CONTRIBUTING]: https://raw.githubusercontent.com/google/draco/master/CONTRIBUTING.md\n\nBunny model from Stanford's graphic department <https://graphics.stanford.edu/data/3Dscanrep/>\n","versions":[{"ref":"master","manifest":"targets = [ \"//:draco\" ]\n","lockFile":"manifest = \"00e9dec8c0e19748bddcb07c3c2e678733fb00efd9cdfad9ac72db490685531c\"\n\n","buck":"load('//:subdir_glob.bzl', 'subdir_glob')\n\ncxx_library(\n  name = 'draco',\n  header_namespace = '',\n  exported_headers = subdir_glob([\n    ('src', 'draco/**/*.h'),\n  ]),\n  srcs = glob([\n    'src/**/*.cc'  \n  ], exclude = glob([\n    'src/**/*_test.cc',\n    'src/**/*_test_*.cc',\n    'src/**/*_tests.cc',\n    'src/**/*_plugin.cc',\n    'src/**/tools/*.cc',\n    'src/draco/javascript/**/*.cc',\n  ])),\n  compiler_flags = [\n    '-std=c++14',\n  ],\n  visibility = [\n    'PUBLIC',\n  ],\n)\n\ncxx_binary(\n  name = 'draco-decoder',\n  srcs = ['src/draco/tools/draco_decoder.cc'],\n  deps = [':draco'],\n  visibility = ['PUBLIC'],\n)\n\ncxx_binary(\n  name = 'draco-encoder',\n  srcs = ['src/draco/tools/draco_encoder.cc'],\n  deps = [':draco'],\n  visibility = ['PUBLIC'],\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-31T15:33:59Z","updatedUpstream":"2021-01-13T19:51:40Z","contributors":[{"login":"louquillio","avatarUrl":"https://avatars0.githubusercontent.com/u/30157?v=4"},{"login":"gero3","avatarUrl":"https://avatars3.githubusercontent.com/u/155535?v=4"},{"login":"cdibona","avatarUrl":"https://avatars1.githubusercontent.com/u/165353?v=4"},{"login":"KindDragon","avatarUrl":"https://avatars3.githubusercontent.com/u/224272?v=4"},{"login":"dberlin","avatarUrl":"https://avatars3.githubusercontent.com/u/324715?v=4"},{"login":"eile","avatarUrl":"https://avatars0.githubusercontent.com/u/354947?v=4"},{"login":"nyue","avatarUrl":"https://avatars3.githubusercontent.com/u/486172?u=da0467f56a801429f5f82485c7856f7d5803badf&v=4"},{"login":"tomfinegan","avatarUrl":"https://avatars2.githubusercontent.com/u/593657?u=f5732fe78fb7c503d1133f15ba1748a632a33e5f&v=4"},{"login":"shshaw","avatarUrl":"https://avatars1.githubusercontent.com/u/777155?v=4"},{"login":"edent","avatarUrl":"https://avatars1.githubusercontent.com/u/837136?u=8f2d06ca5b35d195d9eaddc054578d7c24fe99a2&v=4"},{"login":"dscherba","avatarUrl":"https://avatars3.githubusercontent.com/u/954571?v=4"},{"login":"customlogic","avatarUrl":"https://avatars3.githubusercontent.com/u/1166244?v=4"},{"login":"jherico","avatarUrl":"https://avatars0.githubusercontent.com/u/1533642?u=f0a838ca1bfeccbca1f7b1ddd5d4fb81231e886d&v=4"},{"login":"pps83","avatarUrl":"https://avatars2.githubusercontent.com/u/1614246?v=4"},{"login":"thibault-p","avatarUrl":"https://avatars3.githubusercontent.com/u/1842368?v=4"},{"login":"donmccurdy","avatarUrl":"https://avatars0.githubusercontent.com/u/1848368?u=eef2f5dba9180474d4e330d15a8989a853f57685&v=4"},{"login":"gsimone","avatarUrl":"https://avatars0.githubusercontent.com/u/1862172?u=a17bf63548905dff4b9ea8b2206394d5ea8f4248&v=4"},{"login":"asluk","avatarUrl":"https://avatars1.githubusercontent.com/u/2095974?u=24f9a194d189de455dc5f8ba71a14d272fefc176&v=4"},{"login":"shehzan10","avatarUrl":"https://avatars2.githubusercontent.com/u/2288659?u=95fa14cc0387d3b6a6164b12de48510c34a2aace&v=4"},{"login":"Jiloc","avatarUrl":"https://avatars2.githubusercontent.com/u/2530388?u=9803a8792f075c52929f3a23fcdc083db7cfe6a7&v=4"},{"login":"atteneder","avatarUrl":"https://avatars0.githubusercontent.com/u/2593014?u=b7af60bfcaaee653f20bf3f771b9593a985b9333&v=4"},{"login":"EvgenyRodygin","avatarUrl":"https://avatars2.githubusercontent.com/u/2855321?u=dbe868dd927d66b2aeb07b44c1dde7a94f1680f7&v=4"},{"login":"google-admin","avatarUrl":"https://avatars3.githubusercontent.com/u/3605123?u=cbaa690ef0ae81e5c1bd47bdfaed42fc66161792&v=4"},{"login":"kiwipxl","avatarUrl":"https://avatars0.githubusercontent.com/u/4355075?u=3e639640ee31245ada02295c4f0d863d04a8e232&v=4"},{"login":"ggetz","avatarUrl":"https://avatars3.githubusercontent.com/u/4439461?u=e929b027ab4b3feb66585c4efeb23dd3f21822fb&v=4"}],"fundingLinks":[],"contactLinks":[],"stars":3902,"forks":652,"topics":["point-cloud","3d-graphics","compression","mesh"]}},"__N_SSG":true}