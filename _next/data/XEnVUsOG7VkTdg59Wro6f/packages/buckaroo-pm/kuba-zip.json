{"pageProps":{"data":{"packageName":"buckaroo-pm/kuba-zip","name":"kuba--/zip","licence":"Unlicense","description":"A portable, simple zip library written in C","readme":"### A portable (OSX/Linux/Windows), simple zip library written in C\nThis is done by hacking awesome [miniz](https://code.google.com/p/miniz) library and layering functions on top of the miniz v1.15 API.\n\n[![Windows](https://ci.appveyor.com/api/projects/status/bph8dr3jacgmjv32/branch/master?svg=true&label=windows)](https://ci.appveyor.com/project/kuba--/zip)\n[![Linux](https://travis-ci.org/kuba--/zip.svg?branch=master&label=linux%2fosx)](https://travis-ci.org/kuba--/zip)\n[![Version](https://badge.fury.io/gh/kuba--%2Fzip.svg)](https://github.com/kuba--/zip/releases)\n[![Codecov](https://codecov.io/gh/kuba--/zip/branch/master/graph/badge.svg)](https://codecov.io/gh/kuba--/zip)\n\n\n# The Idea\n<img src=\"zip.png\" name=\"zip\" />\n... Some day, I was looking for zip library written in C for my project, but I could not find anything simple enough and lightweight.\nEverything what I tried required 'crazy mental gymnastics' to integrate or had some limitations or was too heavy.\nI hate frameworks, factories and adding new dependencies. If I must to install all those dependencies and link new library, I'm getting almost sick.\nI wanted something powerfull and small enough, so I could add just a few files and compile them into my project.\nAnd finally I found miniz.\nMiniz is a lossless, high performance data compression library in a single source file. I only needed simple interface to append buffers or files to the current zip-entry. Thanks to this feature I'm able to merge many files/buffers and compress them on-the-fly.\n\nIt was the reason, why I decided to write zip module on top of the miniz. It required a little bit hacking and wrapping some functions, but I kept simplicity. So, you can grab these 3 files and compile them into your project. I hope that interface is also extremely simple, so you will not have any problems to understand it.\n\n# Examples\n\n* Create a new zip archive with default compression level.\n```c\nstruct zip_t *zip = zip_open(\"foo.zip\", ZIP_DEFAULT_COMPRESSION_LEVEL, 'w');\n{\n    zip_entry_open(zip, \"foo-1.txt\");\n    {\n        const char *buf = \"Some data here...\\0\";\n        zip_entry_write(zip, buf, strlen(buf));\n    }\n    zip_entry_close(zip);\n\n    zip_entry_open(zip, \"foo-2.txt\");\n    {\n        // merge 3 files into one entry and compress them on-the-fly.\n        zip_entry_fwrite(zip, \"foo-2.1.txt\");\n        zip_entry_fwrite(zip, \"foo-2.2.txt\");\n        zip_entry_fwrite(zip, \"foo-2.3.txt\");\n    }\n    zip_entry_close(zip);\n}\nzip_close(zip);\n```\n\n* Append to the existing zip archive.\n```c\nstruct zip_t *zip = zip_open(\"foo.zip\", ZIP_DEFAULT_COMPRESSION_LEVEL, 'a');\n{\n    zip_entry_open(zip, \"foo-3.txt\");\n    {\n        const char *buf = \"Append some data here...\\0\";\n        zip_entry_write(zip, buf, strlen(buf));\n    }\n    zip_entry_close(zip);\n}\nzip_close(zip);\n```\n\n* Extract a zip archive into a folder.\n```c\nint on_extract_entry(const char *filename, void *arg) {\n    static int i = 0;\n    int n = *(int *)arg;\n    printf(\"Extracted: %s (%d of %d)\\n\", filename, ++i, n);\n\n    return 0;\n}\n\nint arg = 2;\nzip_extract(\"foo.zip\", \"/tmp\", on_extract_entry, &arg);\n```\n\n* Extract a zip entry into memory.\n```c\nvoid *buf = NULL;\nsize_t bufsize;\n\nstruct zip_t *zip = zip_open(\"foo.zip\", 0, 'r');\n{\n    zip_entry_open(zip, \"foo-1.txt\");\n    {\n        zip_entry_read(zip, &buf, &bufsize);\n    }\n    zip_entry_close(zip);\n}\nzip_close(zip);\n\nfree(buf);\n```\n\n* Extract a zip entry into memory (no internal allocation).\n```c\nunsigned char *buf;\nsize_t bufsize;\n\nstruct zip_t *zip = zip_open(\"foo.zip\", 0, 'r');\n{\n    zip_entry_open(zip, \"foo-1.txt\");\n    {\n        bufsize = zip_entry_size(zip);\n        buf = calloc(sizeof(unsigned char), bufsize);\n\n        zip_entry_noallocread(zip, (void *)buf, bufsize);\n    }\n    zip_entry_close(zip);\n}\nzip_close(zip);\n\nfree(buf);\n```\n\n* Extract a zip entry into memory using callback.\n```c\nstruct buffer_t {\n    char *data;\n    size_t size;\n};\n\nstatic size_t on_extract(void *arg, unsigned long long offset, const void *data, size_t size) {\n    struct buffer_t *buf = (struct buffer_t *)arg;\n    buf->data = realloc(buf->data, buf->size + size + 1);\n    assert(NULL != buf->data);\n\n    memcpy(&(buf->data[buf->size]), data, size);\n    buf->size += size;\n    buf->data[buf->size] = 0;\n\n    return size;\n}\n\nstruct buffer_t buf = {0};\nstruct zip_t *zip = zip_open(\"foo.zip\", 0, 'r');\n{\n    zip_entry_open(zip, \"foo-1.txt\");\n    {\n        zip_entry_extract(zip, on_extract, &buf);\n    }\n    zip_entry_close(zip);\n}\nzip_close(zip);\n\nfree(buf.data);\n```\n\n\n* Extract a zip entry into a file.\n```c\nstruct zip_t *zip = zip_open(\"foo.zip\", 0, 'r');\n{\n    zip_entry_open(zip, \"foo-2.txt\");\n    {\n        zip_entry_fread(zip, \"foo-2.txt\");\n    }\n    zip_entry_close(zip);\n}\nzip_close(zip);\n```\n\n* List of all zip entries\n```c\nstruct zip_t *zip = zip_open(\"foo.zip\", 0, 'r');\nint i, n = zip_total_entries(zip);\nfor (i = 0; i < n; ++i) {\n    zip_entry_openbyindex(zip, i);\n    {\n        const char *name = zip_entry_name(zip);\n        int isdir = zip_entry_isdir(zip);\n        unsigned long long size = zip_entry_size(zip);\n        unsigned int crc32 = zip_entry_crc32(zip);\n    }\n    zip_entry_close(zip);\n}\nzip_close(zip);\n```\n\n# Bindings\nCompile zip library as a dynamic library.\n```shell\n$ mkdir build\n$ cd build\n$ cmake -DBUILD_SHARED_LIBS=true ..\n$ make\n```\n\n### Go (cgo)\n```go\npackage main\n\n/*\n#cgo CFLAGS: -I../src\n#cgo LDFLAGS: -L. -lzip\n#include <zip.h>\n*/\nimport \"C\"\nimport \"unsafe\"\n\nfunc main() {\n\tpath := C.CString(\"/tmp/go.zip\")\n\tzip := C.zip_open(path, 6, 'w')\n\n\tentryname := C.CString(\"test\")\n\tC.zip_entry_open(zip, entryname)\n\n\tcontent := \"test content\"\n\tbuf := unsafe.Pointer(C.CString(content))\n\tbufsize := C.size_t(len(content))\n\tC.zip_entry_write(zip, buf, bufsize)\n\n\tC.zip_entry_close(zip)\n\n\tC.zip_close(zip)\n}\n```\n\n### Ruby (ffi)\nInstall _ffi_ gem.\n```shell\n$ gem install ffi\n```\n\nBind in your module.\n```ruby\nrequire 'ffi'\n\nmodule Zip\n  extend FFI::Library\n  ffi_lib \"./libzip.#{::FFI::Platform::LIBSUFFIX}\"\n\n  attach_function :zip_open, [:string, :int, :char], :pointer\n  attach_function :zip_close, [:pointer], :void\n\n  attach_function :zip_entry_open, [:pointer, :string], :int\n  attach_function :zip_entry_close, [:pointer], :void\n  attach_function :zip_entry_write, [:pointer, :string, :int], :int\nend\n\nptr = Zip.zip_open(\"/tmp/ruby.zip\", 6, \"w\".bytes()[0])\n\nstatus = Zip.zip_entry_open(ptr, \"test\")\n\ncontent = \"test content\"\nstatus = Zip.zip_entry_write(ptr, content, content.size())\n\nZip.zip_entry_close(ptr)\nZip.zip_close(ptr)\n```\n\n### Python (cffi)\nInstall _cffi_ package\n```shell\n$ pip install cffi\n```\n\nBind in your package.\n```python\nimport ctypes.util\nfrom cffi import FFI\n\nffi = FFI()\nffi.cdef(\"\"\"\n    struct zip_t *zip_open(const char *zipname, int level, char mode);\n    void zip_close(struct zip_t *zip);\n\n    int zip_entry_open(struct zip_t *zip, const char *entryname);\n    int zip_entry_close(struct zip_t *zip);\n    int zip_entry_write(struct zip_t *zip, const void *buf, size_t bufsize);\n\"\"\")\n\nZip = ffi.dlopen(ctypes.util.find_library(\"zip\"))\n\nptr = Zip.zip_open(\"/tmp/python.zip\", 6, 'w')\n\nstatus = Zip.zip_entry_open(ptr, \"test\")\n\ncontent = \"test content\"\nstatus = Zip.zip_entry_write(ptr, content, len(content))\n\nZip.zip_entry_close(ptr)\nZip.zip_close(ptr)\n```\n\n### Ring\nThe language comes with RingZip based on this library\n```ring\nload \"ziplib.ring\"\n\nnew Zip {\n    setFileName(\"myfile.zip\")\n    open(\"w\")\n    newEntry() {\n        open(\"test.c\")\n        writefile(\"test.c\")\n        close()\n    }\n    close()\n}\n```\n\n# Contribution Rules/Coding Standards\nNo need to throw away your coding style, just do your best to follow default clang-format style.\nApply `clang-format` to the source files before commit:\n```sh\nfor file in $(git ls-files | \\grep -E '\\.(c|h)$' | \\grep -v -- '#')\ndo\n    clang-format -i $file\ndone\n```\n\n","versions":[{"ref":"master","manifest":"targets = [ \"//:miniz\" ]\n","lockFile":"manifest = \"1e2c172b3b7da10640f14d76872d4c3b2acfbd841665631531f3dac2594390fa\"\n\n","buck":"load('//:subdir_glob.bzl', 'subdir_glob')\n\ncxx_library(\n  name = 'miniz',\n  exported_headers = subdir_glob([\n    ('src', '*.h')\n  ]),\n  visibility = ['PUBLIC']\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-25T17:54:24Z","updatedUpstream":"2021-01-13T22:30:58Z","contributors":[{"login":"drizt","avatarUrl":"https://avatars1.githubusercontent.com/u/534665?u=d2b06fa87ed842eeb0e03e3c338727dd6709b4a9&v=4"},{"login":"rbsheth","avatarUrl":"https://avatars3.githubusercontent.com/u/583212?u=13b551bc699fbb23cfe649033e43bfc10a5ed932&v=4"},{"login":"nesbox","avatarUrl":"https://avatars2.githubusercontent.com/u/1101448?u=0eca70a6c88f2c8fbfa2cb2fa4e1f19fa1a630e7&v=4"},{"login":"bvgastel","avatarUrl":"https://avatars3.githubusercontent.com/u/1301653?v=4"},{"login":"haozhun","avatarUrl":"https://avatars3.githubusercontent.com/u/2020503?v=4"},{"login":"kimkulling","avatarUrl":"https://avatars3.githubusercontent.com/u/2323156?u=b9dbe9412e050771885a4438b0bbacf4850b217c&v=4"},{"login":"avp","avatarUrl":"https://avatars1.githubusercontent.com/u/2388586?u=07c8b12fd836734613cf6cd585158f231e3da97d&v=4"},{"login":"Cgettys","avatarUrl":"https://avatars3.githubusercontent.com/u/3117273?v=4"},{"login":"kuba--","avatarUrl":"https://avatars1.githubusercontent.com/u/4056521?v=4"},{"login":"alihardan","avatarUrl":"https://avatars3.githubusercontent.com/u/4679877?v=4"},{"login":"jamesathey","avatarUrl":"https://avatars1.githubusercontent.com/u/5478953?u=bee141aff481cd4813e20e69f1425912848960db&v=4"},{"login":"ForgottenTales","avatarUrl":"https://avatars2.githubusercontent.com/u/7306985?v=4"},{"login":"MahmoudFayed","avatarUrl":"https://avatars2.githubusercontent.com/u/9929374?u=60e7dece25ffc2042dda7c521b97d5155f0febf2&v=4"},{"login":"mohe2015","avatarUrl":"https://avatars0.githubusercontent.com/u/13287984?v=4"},{"login":"mykhailopylyp","avatarUrl":"https://avatars3.githubusercontent.com/u/17161067?v=4"},{"login":"cpupreme","avatarUrl":"https://avatars0.githubusercontent.com/u/30322380?v=4"},{"login":"amiremohamadi","avatarUrl":"https://avatars0.githubusercontent.com/u/31338382?u=f60ed3a125596d0fe8ccae258363a67e121dd339&v=4"},{"login":"jinfeihan57","avatarUrl":"https://avatars2.githubusercontent.com/u/38484902?v=4"},{"login":"timgates42","avatarUrl":"https://avatars1.githubusercontent.com/u/47873678?u=5979ac643b54da99a384068c6aa23fa56296b87e&v=4"}],"fundingLinks":[],"contactLinks":[],"stars":555,"forks":136,"topics":["zip","compression","c","miniz","portable","hacking"]}},"__N_SSG":true}