{"pageProps":{"data":{"packageName":"buckaroo-pm/google-cityhash","name":"google/cityhash","licence":"NOASSERTION","description":"Automatically exported from code.google.com/p/cityhash","readme":"CityHash, a family of hash functions for strings.\n\n\nIntroduction\n============\n\nCityHash provides hash functions for strings.  The functions mix the\ninput bits thoroughly but are not suitable for cryptography.  See\n\"Hash Quality,\" below, for details on how CityHash was tested and so on.\n\nWe provide reference implementations in C++, with a friendly MIT license.\n\nCityHash32() returns a 32-bit hash.\n\nCityHash64() and similar return a 64-bit hash.\n\nCityHash128() and similar return a 128-bit hash and are tuned for\nstrings of at least a few hundred bytes.  Depending on your compiler\nand hardware, it's likely faster than CityHash64() on sufficiently long\nstrings.  It's slower than necessary on shorter strings, but we expect\nthat case to be relatively unimportant.\n\nCityHashCrc128() and similar are variants of CityHash128() that depend\non _mm_crc32_u64(), an intrinsic that compiles to a CRC32 instruction\non some CPUs.  However, none of the functions we provide are CRCs.\n\nCityHashCrc256() is a variant of CityHashCrc128() that also depends\non _mm_crc32_u64().  It returns a 256-bit hash.\n\nAll members of the CityHash family were designed with heavy reliance\non previous work by Austin Appleby, Bob Jenkins, and others.\nFor example, CityHash32 has many similarities with Murmur3a.\n\nPerformance on long strings: 64-bit CPUs\n========================================\n \nWe are most excited by the performance of CityHash64() and its variants on\nshort strings, but long strings are interesting as well.\n\nCityHash is intended to be fast, under the constraint that it hash very\nwell.  For CPUs with the CRC32 instruction, CRC is speedy, but CRC wasn't\ndesigned as a hash function and shouldn't be used as one.  CityHashCrc128()\nis not a CRC, but it uses the CRC32 machinery.\n\nOn a single core of a 2.67GHz Intel Xeon X5550, CityHashCrc256 peaks at about\n5 to 5.5 bytes/cycle.  The other CityHashCrc functions are wrappers around\nCityHashCrc256 and should have similar performance on long strings.\n(CityHashCrc256 in v1.0.3 was even faster, but we decided it wasn't as thorough\nas it should be.)  CityHash128 peaks at about 4.3 bytes/cycle.  The fastest\nMurmur variant on that hardware, Murmur3F, peaks at about 2.4 bytes/cycle.\nWe expect the peak speed of CityHash128 to dominate CityHash64, which is\naimed more toward short strings or use in hash tables.\n\nFor long strings, a new function by Bob Jenkins, SpookyHash, is just\nslightly slower than CityHash128 on Intel x86-64 CPUs, but noticeably\nfaster on AMD x86-64 CPUs.  For hashing long strings on AMD CPUs\nand/or CPUs without the CRC instruction, SpookyHash may be just as\ngood or better than any of the CityHash variants.\n\nPerformance on short strings: 64-bit CPUs\n=========================================\n\nFor short strings, e.g., most hash table keys, CityHash64 is faster than\nCityHash128, and probably faster than all the aforementioned functions,\ndepending on the mix of string lengths.  Here are a few results from that\nsame hardware, where we (unrealistically) tested a single string length over\nand over again:\n\nHash              Results\n------------------------------------------------------------------------------\nCityHash64 v1.0.3 7ns for 1 byte, or 6ns for 8 bytes, or 9ns for 64 bytes\nMurmur2 (64-bit)  6ns for 1 byte, or 6ns for 8 bytes, or 15ns for 64 bytes\nMurmur3F          14ns for 1 byte, or 15ns for 8 bytes, or 23ns for 64 bytes\n\nWe don't have CityHash64 benchmarks results for v1.1, but we expect the\nnumbers to be similar.\n\nPerformance: 32-bit CPUs\n========================\n\nCityHash32 is the newest variant of CityHash.  It is intended for\n32-bit hardware in general but has been mostly tested on x86.  Our benchmarks\nsuggest that Murmur3 is the nearest competitor to CityHash32 on x86.\nWe don't know of anything faster that has comparable quality.  The speed rankings\nin our testing: CityHash32 > Murmur3f > Murmur3a (for long strings), and\nCityHash32 > Murmur3a > Murmur3f (for short strings).\n\nInstallation\n============\n\nWe provide reference implementations of several CityHash functions, written\nin C++.  The build system is based on autoconf.  It defaults the C++\ncompiler flags to \"-g -O2\", which is probably slower than -O3 if you are\nusing gcc.  YMMV.\n\nOn systems with gcc, we generally recommend:\n\n./configure\nmake all check CXXFLAGS=\"-g -O3\"\nsudo make install\n\nOr, if your system has the CRC32 instruction, and you want to build everything:\n\n./configure --enable-sse4.2\nmake all check CXXFLAGS=\"-g -O3 -msse4.2\"\nsudo make install\n\nNote that our build system doesn't try to determine the appropriate compiler\nflag for enabling SSE4.2.  For gcc it is \"-msse4.2\".  The --enable-sse4.2\nflag to the configure script controls whether citycrc.h is installed when\nyou \"make install.\"  In general, picking the right compiler flags can be\ntricky, and may depend on your compiler, your hardware, and even how you\nplan to use the library.\n\nFor generic information about how to configure this software, please try:\n\n./configure --help\n\nFailing that, please work from city.cc and city*.h, as they contain all the\nnecessary code.\n\n\nUsage\n=====\n\nThe above installation instructions will produce a single library.  It will\ncontain CityHash32(), CityHash64(), and CityHash128(), and their variants,\nand possibly CityHashCrc128(), CityHashCrc128WithSeed(), and\nCityHashCrc256().  The functions with Crc in the name are declared in\ncitycrc.h; the rest are declared in city.h.\n\n\nLimitations\n===========\n\n1) CityHash32 is intended for little-endian 32-bit code, and everything else in\nthe current version of CityHash is intended for little-endian 64-bit CPUs.\n\nAll functions that don't use the CRC32 instruction should work in\nlittle-endian 32-bit or 64-bit code.  CityHash should work on big-endian CPUs\nas well, but we haven't tested that very thoroughly yet.\n\n2) CityHash is fairly complex.  As a result of its complexity, it may not\nperform as expected on some compilers.  For example, preliminary reports\nsuggest that some Microsoft compilers compile CityHash to assembly that's\n10-20% slower than it could be.\n\n\nHash Quality\n============\n\nWe like to test hash functions with SMHasher, among other things.\nSMHasher isn't perfect, but it seems to find almost any significant flaw.\nSMHasher is available at http://code.google.com/p/smhasher/\n\nSMHasher is designed to pass a 32-bit seed to the hash functions it tests.\nNo CityHash function is designed to work that way, so we adapt as follows:\nFor our functions that accept a seed, we use the given seed directly (padded\nwith zeroes); for our functions that don't accept a seed, we hash the\nconcatenation of the given seed and the input string.\n\nThe CityHash functions have the following flaws according to SMHasher:\n\n(1) CityHash64: none\n\n(2) CityHash64WithSeed: none\n\n(3) CityHash64WithSeeds: did not test\n\n(4) CityHash128: none\n\n(5) CityHash128WithSeed: none\n\n(6) CityHashCrc128: none\n\n(7) CityHashCrc128WithSeed: none\n\n(8) CityHashCrc256: none\n\n(9) CityHash32: none\n\nSome minor flaws in 32-bit and 64-bit functions are harmless, as we\nexpect the primary use of these functions will be in hash tables.  We\nmay have gone slightly overboard in trying to please SMHasher and other\nsimilar tests, but we don't want anyone to choose a different hash function\nbecause of some minor issue reported by a quality test.\n\n\nFor more information\n====================\n\nhttp://code.google.com/p/cityhash/\n\ncityhash-discuss@googlegroups.com\n\nPlease feel free to send us comments, questions, bug reports, or patches.\n","versions":[{"ref":"master","manifest":"targets = [ \"//:cityhash\" ]\n","lockFile":"manifest = \"acbb1c915b976fa3e373b3434ec017d51215af31b1d3f009caab041bf6d390d8\"\n\n","buck":"load('//:subdir_glob.bzl', 'subdir_glob')\n\ngenrule(\n  name = 'config',\n  out = 'config.h',\n  cmd = 'touch $OUT'\n) \n\ncxx_library(\n  name = 'cityhash',\n  header_namespace = '',\n  srcs = glob(['src/city.cc']),\n  exported_headers = subdir_glob([\n    ('src', '*.h')\n  ]),\n  headers = [':config'],\n  visibility = [\"PUBLIC\"]\n)\n\ncxx_binary(\n  name = 'test',\n  srcs = ['src/city-test.cc'],\n  deps = [':cityhash']\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-24T11:33:31Z","updatedUpstream":"2021-01-13T17:50:23Z","contributors":[{"login":"cdibona","avatarUrl":"https://avatars1.githubusercontent.com/u/165353?v=4"},{"login":"dberlin","avatarUrl":"https://avatars3.githubusercontent.com/u/324715?v=4"},{"login":"google-admin","avatarUrl":"https://avatars3.githubusercontent.com/u/3605123?u=cbaa690ef0ae81e5c1bd47bdfaed42fc66161792&v=4"},{"login":"googlebot","avatarUrl":"https://avatars1.githubusercontent.com/u/5384588?u=b2b68981375faf7e582e8bf043e4d16f9bff44dd&v=4"},{"login":"jyrkialakuijala","avatarUrl":"https://avatars3.githubusercontent.com/u/9086028?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":708,"forks":136,"topics":[]}},"__N_SSG":true}