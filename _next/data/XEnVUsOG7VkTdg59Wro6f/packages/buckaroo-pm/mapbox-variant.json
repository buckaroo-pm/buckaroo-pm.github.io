{"pageProps":{"data":{"packageName":"buckaroo-pm/mapbox-variant","name":"mapbox/variant","licence":"NOASSERTION","description":"C++11/C++14 Variant","readme":"# Mapbox Variant\n\nAn header-only alternative to `boost::variant` for C++11 and C++14\n\n[![Build Status](https://secure.travis-ci.org/mapbox/variant.svg)](https://travis-ci.org/mapbox/variant)\n[![Build status](https://ci.appveyor.com/api/projects/status/v9tatx21j1k0fcgy)](https://ci.appveyor.com/project/Mapbox/variant)\n[![Coverage Status](https://coveralls.io/repos/mapbox/variant/badge.svg?branch=master&service=github)](https://coveralls.io/r/mapbox/variant?branch=master)\n\n## Introduction\n\nVariant's basic building blocks are:\n\n- `variant<Ts...>` - a type-safe representation for sum-types / discriminated unions\n- `recursive_wrapper<T>` - a helper type to represent recursive \"tree-like\" variants\n- `apply_visitor(visitor, myVariant)` - to invoke a custom visitor on the variant's underlying type\n- `get<T>()` - a function to directly unwrap a variant's underlying type\n- `.match([](Type){})` - a variant convenience member function taking an arbitrary number of lambdas creating a visitor behind the scenes and applying it to the variant\n\n### Basic Usage - HTTP API Example\n\nSuppose you want to represent a HTTP API response which is either a JSON result or an error:\n\n```c++\nstruct Result {\n  Json object;\n};\n\nstruct Error {\n  int32_t code;\n  string message;\n};\n```\n\nYou can represent this at type level using a variant which is either an `Error` or a `Result`:\n\n```c++\nusing Response = variant<Error, Result>;\n\nResponse makeRequest() {\n  return Error{501, \"Not Implemented\"};\n}\n\nResponse ret = makeRequest();\n```\n\nTo see which type the `Response` holds you pattern match on the variant unwrapping the underlying value:\n\n```c++\nret.match([] (Result r) { print(r.object); },\n          [] (Error e)  { print(e.message); });\n```\n\nInstead of using the variant's convenience `.match` pattern matching function you can create a type visitor functor and use `apply_visitor` manually:\n\n```c++\nstruct ResponseVisitor {\n  void operator()(Result r) const {\n    print(r.object);\n  }\n\n  void operator()(Error e) const {\n    print(e.message);\n  }\n};\n\nResponseVisitor visitor;\napply_visitor(visitor, ret);\n```\n\nIn both cases the compiler makes sure you handle all types the variant can represent at compile.\n\n### Recursive Variants - JSON Example\n\n[JSON](http://www.json.org/) consists of types `String`, `Number`, `True`, `False`, `Null`, `Array` and `Object`.\n\n```c++\nstruct String { string value; };\nstruct Number { double value; };\nstruct True   { };\nstruct False  { };\nstruct Null   { };\nstruct Array  { vector<?> values; };\nstruct Object { unordered_map<string, ?> values; };\n```\n\nThis works for primitive types but how do we represent recursive types such as `Array` which can hold multiple elements and `Array` itself, too?\n\nFor these use cases Variant provides a `recursive_wrapper` helper type which lets you express recursive Variants.\n\n```c++\nstruct String { string value; };\nstruct Number { double value; };\nstruct True   { };\nstruct False  { };\nstruct Null   { };\n\n// Forward declarations only\nstruct Array;\nstruct Object;\n\nusing Value = variant<String, Number, True, False, Null, recursive_wrapper<Array>, recursive_wrapper<Object>>;\n\nstruct Array {\n  vector<Value> values;\n};\n\nstruct Object {\n  unordered_map<string, Value> values;\n};\n```\n\nFor walking the JSON representation you can again either create a `JSONVisitor`:\n\n```c++\nstruct JSONVisitor {\n\n  void operator()(Null) const {\n    print(\"null\");\n  }\n\n  // same for all other JSON types\n};\n\nJSONVisitor visitor;\napply_visitor(visitor, json);\n```\n\nOr use the convenience `.match` pattern matching function:\n\n```c++\njson.match([] (Null) { print(\"null\"); },\n           ...);\n```\n\nTo summarize: use `recursive_wrapper` to represent recursive \"tree-like\" representations:\n\n```c++\nstruct Empty { };\nstruct Node;\n\nusing Tree = variant<Empty, recursive_wrapper<Node>>;\n\nstruct Node {\n  uint64_t value;\n}\n```\n\n### Advanced Usage Tips\n\nCreating type aliases for variants is a great way to reduce repetition.\nKeep in mind those type aliases are not checked at type level, though.\nWe recommend creating a new type for all but basic variant usage:\n\n```c++\n// the compiler can't tell the following two apart\nusing APIResult = variant<Error, Result>;\nusing FilesystemResult = variant<Error, Result>;\n\n// new type\nstruct APIResult : variant<Error, Result> {\n  using Base = variant<Error, Result>;\n  using Base::Base;\n}\n```\n\n## Why use Mapbox Variant?\n\nMapbox variant has the same speedy performance of `boost::variant` but is\nfaster to compile, results in smaller binaries, and has no dependencies.\n\nFor example on OS X 10.9 with clang++ and libc++:\n\nTest | Mapbox Variant | Boost Variant\n---- | -------------- | -------------\nSize of pre-compiled header (release / debug) | 2.8/2.8 MB         | 12/15 MB\nSize of simple program linking variant (release / debug)     | 8/24 K             | 12/40 K\nTime to compile header     | 185 ms             |  675 ms\n\n(Numbers from an older version of Mapbox variant.)\n\n## Goals\n\nMapbox `variant` has been a very valuable, lightweight alternative for apps\nthat can use c++11 or c++14 but that do not want a boost dependency.\nMapbox `variant` has also been useful in apps that do depend on boost, like\nmapnik, to help (slightly) with compile times and to majorly lessen dependence\non boost in core headers. The original goal and near term goal is to maintain\nexternal API compatibility with `boost::variant` such that Mapbox `variant`\ncan be a \"drop in\". At the same time the goal is to stay minimal: Only\nimplement the features that are actually needed in existing software. So being\nan \"incomplete\" implementation is just fine.\n\nCurrently Mapbox variant doesn't try to be API compatible with the upcoming\nvariant standard, because the standard is not finished and it would be too much\nwork. But we'll revisit this decision in the future if needed.\n\nIf Mapbox variant is not for you, have a look at [these other\nimplementations](doc/other_implementations.md).\n\nWant to know more about the upcoming standard? Have a look at our\n[overview](doc/standards_effort.md).\n\nMost modern high-level languages provide ways to express sum types directly.\nIf you're curious have a look at Haskell's pattern matching or Rust's and Swift's enums.\n\n## Depends\n\n- Compiler supporting `-std=c++11` or `-std=c++14`\n\nTested with:\n\n- g++-4.7\n- g++-4.8\n- g++-4.9\n- g++-5.2\n- clang++-3.5\n- clang++-3.6\n- clang++-3.7\n- clang++-3.8\n- clang++-3.9\n- Visual Studio 2015\n\n## Unit Tests\n\nOn Unix systems compile and run the unit tests with `make test`.\n\nOn Windows run `scripts/build-local.bat`.\n\n## Limitations\n\n- The `variant` can not hold references (something like `variant<int&>` is\n  not possible). You might want to try `std::reference_wrapper` instead.\n\n## Deprecations\n\n- The included implementation of `optional` is deprecated and will be removed\n  in a future version. See [issue #64](https://github.com/mapbox/variant/issues/64).\n- Old versions of the code needed visitors to derive from `static_visitor`.\n  This is not needed any more and marked as deprecated. The `static_visitor`\n  class will be removed in future versions.\n\n## Benchmarks\n\n    make bench\n\n## Check object sizes\n\n    make sizes /path/to/boost/variant.hpp\n","versions":[{"ref":"master","manifest":"targets = [ \"//:variant\" ]\n","lockFile":"manifest = \"365e5aaf42b3c1e4a9feb65c09afd6e70c767992892c7b11ecff344eda9e8a41\"\n\n","buck":"load('//:subdir_glob.bzl', 'subdir_glob')\n\nprebuilt_cxx_library(\n  name = 'variant',\n  header_namespace = 'mapbox',\n  header_only = True,\n  exported_headers = subdir_glob([\n    ('include/mapbox', '**/*.hpp'),\n  ]),\n  visibility = [\n    'PUBLIC',\n  ],\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-16T10:14:46Z","updatedUpstream":"2021-01-07T08:01:53Z","contributors":[{"login":"zugaldia","avatarUrl":"https://avatars1.githubusercontent.com/u/6964?u=e17bd7e9c8e0d4ca1df6956596cffc4ef10176de&v=4"},{"login":"bookest","avatarUrl":"https://avatars1.githubusercontent.com/u/14640?u=75e815f366d32a63b0d223fe47182a1570a96bb3&v=4"},{"login":"springmeyer","avatarUrl":"https://avatars1.githubusercontent.com/u/20300?v=4"},{"login":"mikelmaron","avatarUrl":"https://avatars1.githubusercontent.com/u/22896?u=f22126445e688b260ca316709407189f669c2083&v=4"},{"login":"mourner","avatarUrl":"https://avatars2.githubusercontent.com/u/25395?u=6f04fa0e30ee06ee7ef8d13dd6c166d0ca70aeea&v=4"},{"login":"sbma44","avatarUrl":"https://avatars2.githubusercontent.com/u/31717?v=4"},{"login":"sgillies","avatarUrl":"https://avatars3.githubusercontent.com/u/33697?u=518c359114c548926c56fef4b51a123e9a4a5d47&v=4"},{"login":"kkaefer","avatarUrl":"https://avatars1.githubusercontent.com/u/52399?u=7b3a53dfef51246b5c1342108a664842b4ea3571&v=4"},{"login":"alfwatt","avatarUrl":"https://avatars1.githubusercontent.com/u/53469?u=ff9e35352887e919bfd74b6ad0bee578af80e165&v=4"},{"login":"anderco","avatarUrl":"https://avatars1.githubusercontent.com/u/55106?v=4"},{"login":"yuletide","avatarUrl":"https://avatars3.githubusercontent.com/u/58695?u=6322adc3fcbff377e32f0e6299d7aaddd841dc6e&v=4"},{"login":"artemp","avatarUrl":"https://avatars1.githubusercontent.com/u/59056?u=84b41abea2ca9e9c6e5a6af9277ee06e8376c68f&v=4"},{"login":"tristen","avatarUrl":"https://avatars1.githubusercontent.com/u/61150?u=40b52d083ac2c6f414ef35c79271c776787e7bd0&v=4"},{"login":"ivovandongen","avatarUrl":"https://avatars1.githubusercontent.com/u/64527?u=e284cc763f7ca8765196fc0f6279e7538742cdfd&v=4"},{"login":"brunoabinader","avatarUrl":"https://avatars2.githubusercontent.com/u/76133?v=4"},{"login":"apendleton","avatarUrl":"https://avatars3.githubusercontent.com/u/78930?u=911348d600e91c721685538a958ee4252a854589&v=4"},{"login":"yhahn","avatarUrl":"https://avatars1.githubusercontent.com/u/83384?u=b2c1ca34e763ba420f510b5a1d62201c1d9624eb&v=4"},{"login":"PureW","avatarUrl":"https://avatars0.githubusercontent.com/u/85910?v=4"},{"login":"AlekseiCherkes","avatarUrl":"https://avatars3.githubusercontent.com/u/87640?u=f75d2bf7fd442db59db853feab57a208761fddef&v=4"},{"login":"ianshward","avatarUrl":"https://avatars2.githubusercontent.com/u/91258?u=5e631aa4328b540f955d9c2e9e2588fcc1bd0d0d&v=4"},{"login":"gundersen","avatarUrl":"https://avatars0.githubusercontent.com/u/93353?v=4"},{"login":"willwhite","avatarUrl":"https://avatars1.githubusercontent.com/u/93564?u=3e17a4a45e3ce686ca811d9ed79257db04ff345f&v=4"},{"login":"lxbarth","avatarUrl":"https://avatars2.githubusercontent.com/u/98233?u=3ca609d2f417501e961958c5bef2f99327b3f84e&v=4"},{"login":"jfirebaugh","avatarUrl":"https://avatars0.githubusercontent.com/u/98601?u=5b527e69ac7e93e41d9a9518e805e99bd4a08389&v=4"},{"login":"kshehadeh","avatarUrl":"https://avatars0.githubusercontent.com/u/107061?u=d5e994f10868eb85c21bc5b8793da960f3044ed6&v=4"}],"fundingLinks":[],"contactLinks":[],"stars":310,"forks":79,"topics":["c-plus-plus"]}},"__N_SSG":true}