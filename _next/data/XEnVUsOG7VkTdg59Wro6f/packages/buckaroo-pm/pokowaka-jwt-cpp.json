{"pageProps":{"data":{"packageName":"buckaroo-pm/pokowaka-jwt-cpp","name":"pokowaka/jwt-cpp","licence":"MIT","description":"A C++ library for handling JWT tokens","readme":"Jwt-cpp\n=======\n\n![Build status](https://travis-ci.org/pokowaka/jwt-cpp.svg?branch=master)\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/pokowaka/jwt-cpp/master/LICENSE.MIT)\n[![Github Issues](https://img.shields.io/github/issues/pokowaka/jwt-cpp.svg)](http://github.com/pokowaka/jwt-cpp/issues)\n\n\nA C++11 implementation of the [JSON Web\nToken](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html)\nstandard.\n\njwt-cpp is licensed under the [MIT license](http://opensource.org/licenses/mit-license.php);\nsee LICENSE in the source distribution for details.\n\nCurrently it supports the following:\n\nSign, Verify JWS:\n\n- HS256, HS384, HS512\n- RS256, RS384, RS512\n- *none*\n\nPayload validators:\n\n- iss check\n- sub check\n- aud check\n- exp check\n- nbf check\n- iat check\n\n**NOTE**: We keep private and public keys unencrypted in memory for the duration of the\nexistence of any of the validators.\n\n## Compilation and Installation\n\nJwt-cpp uses the [CMake](http://www.cmake.org/) cross platform build tools to\nbuild. Once you have installed the proper dependencies you can do the following:\n\nFor release:\n\n```\nmkdir release\ncd release\ncmake -DCMAKE_BUILD_TYPE=Release ..\nmake install\n```\n\nFor debug:\n```\nmkdir debug\ncd debug\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake\n```\n\nRunning the tests with code coverage:\n```\nmkdir debug\ncd debug\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake cov_all_tests\n```\n\n\n### Dependencies in linux\n\nYou will need to install the following dependencies:\n```\nsudo apt-get install libssl-dev cmake lcov\n```\n\n\n### How to build in Mac OS\n\nFirst make sure you have the proper dependencies. The easiest way is to use\n[Homebrew](http://brew.sh/).\n\n```\nbrew install cmake lcov openssl@1.1\n```\n\n### How to build in Windows\nBeside cmake and Visual Studio, you need to install OpenSSL binaries:\n[Win32 OpenSSL](https://slproweb.com/products/Win32OpenSSL.html)\n\nAfter installation, configure cmake for your Visual Studio and set openssl folders:\n```\nMD build\nCD build\ncmake -G \"Visual Studio 14\" -DCMAKE_INSTALL_PREFIX=..\\install -DOPENSSL_INCLUDE_DIRS=C:\\OpenSSL-Win32\\include -DOPENSSL_LIBRARY_DIRS=C:\\OpenSSL-Win32\\lib ..\ncmake --build . --clean-first --target install\n```\nFind your binaries at `install` folder.\n\nTo run tests on Windows, add openssl bins to your path:\n```\nset \"PATH=C:\\OpenSSL-Win32\\bin;%PATH%\"\nctest\n```\n\n## Usage\n\nYou can find detailed [samples](test/token/sample.cpp) that are executed as part\nof the tests.  We make use of [JSON for Modern C++](https://github.com/nlohmann/json) library\nto create json payload.\n\n### Signing tokens\n\nFor example we can create a signed token with HS256 as follows:\n\n```cpp\n#include <iostream>\n#include \"jwt/jwt_all.h\"\nusing json = nlohmann::json;\n\nint main() {\n    // Setup a signer\n    HS256Validator signer(\"secret!\");\n\n    // Create the json payload that expires 01/01/2017 @ 12:00am (UTC)\n    json payload = {{\"sub\", \"subject\"}, {\"exp\", 1483228800}};\n\n    // Let's encode the token to a string\n    auto token = JWT::Encode(signer, payload);\n\n    std::cout << token << std::endl;\n}\n```\n\nOn my mac with homebrew installed at ~/homebrew (it is usually in /usr/local) it can be compiled as follows:\n\n```bash\ng++ -std=c++11 \\\n-I ~/homebrew/include \\\n-I ~/homebrew/opt/openssl@1.1/include \\\n-L ~/homebrew/opt/openssl@1.1/lib \\\n-L ~/homebrew/lib -lcrypto -ljwt \\\nsign.cpp -o sign\n```\n\nExecuting this should result in something like:\n\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJzdWJqZWN0IiwiZXhwIjoxNDgzMjI4ODAwfQ.4Vjr_Htx4oBy9cHFNbpLsVC_YgIA4_hrUIV1unApUUs\n\n### Validating tokens\nValidation is straightforward:\n\n```cpp\n#include <iostream>\n#include \"jwt/jwt_all.h\"\nusing json = nlohmann::json;\n\nint main() {\n    ExpValidator exp;\n    HS256Validator signer(\"secret!\");\n\n    // Now let's use these validators to parse and verify the token we created\n    // in the previous example\n    std::string str_token =\n        \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n        \"eyJpc3MiOiJmb28iLCJleHAiOjE0ODMyMjg4MDB9.\"\n        \"u3JTUx1tJDo601olQv0rHk4kGkKadIj3cvy-DDZKVRo\";\n    try {\n        // Decode and validate the token\n        ::json header, payload;\n\n        std::tie(header, payload) = JWT::Decode(str_token, &signer, &exp);\n        std::cout << \"Header: \" << header << std::endl;\n        std::cout << \"Payload: \" << payload << std::endl;\n    } catch (InvalidTokenError &tfe) {\n        // An invalid token\n        std::cout << \"Validation failed: \" << tfe.what() << std::endl;\n    }\n}\n```\n\nAgain we compile it:\n\n```bash\ng++ -std=c++11  \\\n-I ~/homebrew/include \\\n-I ~/homebrew/opt/openssl@1.1/include \\\n-L ~/homebrew/opt/openssl@1.1/lib \\\n-L ~/homebrew/lib -lcrypto -ljwt -lssl \\\nvalidate.cpp -o validate\n```\n\n#### An example using factories\nUsually your validators will be a little more complex than just validating one\nproperty. The easiest way to use more complex verifiers and validators is by\nusing ``ClaimValidatorFactory::Build`` or ``MessageValidatorFactory::Build``.\nBoth methods accept a json string or a json object, and produce a claim validator or message\nvalidator.\n\n```cpp\n#include <iostream>\n#include \"jwt/jwt_all.h\"\nusing json = nlohmann::json;\n\nint main() {\n    // Let's setup a claim validator where we will accept tokens that\n    // are have been issues by either foo or bar\n    // and have an optional expiration claim with a leeway of 32s.\n    std::string json_claim =\n        \"{ \\\"all\\\" : \"\n        \"  [ \"\n        \"    { \\\"optional\\\" : { \\\"exp\\\" : { \\\"leeway\\\" : 32} } },\"\n        \"    { \\\"iss\\\" : [\\\"foo\\\", \\\"bar\\\"] }\"\n        \"  ]\"\n        \"}\";\n\n    // Lets build the claim validator\n    claim_ptr claim_validator(ClaimValidatorFactory::Build(json_claim));\n\n    // Next we are going to setup the message validators. We will accept\n    // the HS256 & HS512 validators with the given secrets.\n    std::string json_validators =\n        \"{ \\\"set\\\" : [ \"\n        \"  { \\\"HS256\\\" : { \\\"secret\\\" : \\\"secret!\\\" } }, \"\n        \"  { \\\"HS512\\\" : { \\\"secret\\\" : \\\"supersafe\\\" } }\"\n        \" ]\"\n        \"}\";\n    validator_ptr message_validator(\n        MessageValidatorFactory::Build(json_validators));\n\n    // Now let's use these validators to parse and verify the token we created\n    // with a previous sample.\n    std::string str_token =\n        \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n        \"eyJpc3MiOiJmb28iLCJleHAiOjE0ODMyMjg4MDB9.\"\n        \"u3JTUx1tJDo601olQv0rHk4kGkKadIj3cvy-DDZKVRo\";\n    try {\n        ::json header, payload;\n        std::tie(header, payload) = JWT::Decode(\n            str_token, message_validator.get(), claim_validator.get());\n        std::cout << \"Header: \" << header << std::endl;\n        std::cout << \"Payload: \" << payload << std::endl;\n    } catch (InvalidTokenError &tfe) {\n        std::cout << tfe.what() << std::endl;\n    }\n}\n```\n\nAgain compile and run it:\n\n```bash\ng++ -std=c++11  \\\n-I ~/homebrew/include \\\n-I ~/homebrew/opt/openssl@1.1/include \\\n-L ~/homebrew/opt/openssl@1.1/lib \\\n-L ~/homebrew/lib -lcrypto -ljwt -lssl \\\nfactories.cpp -o factories\n```\n#### Dealing with failures\nThere will come a time when tokens are not valid. When tokens fail to validate exceptions will be thrown:\n\n- **InvalidTokenError**: base class for token errors\n- **TokenFormatError**: the token is wrongly encoded. No information can be retrieved.\n- **InvalidSignatureError**: failed to verify the signature. You can still retrieve the token by disabling verification.\n- **InvalidClaimError**: failed to verify the claims. You can still retrieve the token by disabling validation\n- **std::logic_error**: you should never see this. If you do a bug needs to be fixed.\n\nThe sample below shows how you can deal with errors:\n\n```cpp\n#include <iostream>\n#include \"jwt/jwt_all.h\"\nusing json = nlohmann::json;\n\nint main() {\n    ExpValidator exp;\n    HS256Validator signer(\"secret\");\n\n    // Now we use these validators to parse and verify the token we created\n    // in the previous example\n    std::string token =\n        \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n        \"eyJpc3MiOiJmb28iLCJleHAiOjE0ODMyMjg4MDB9.\"\n        \"u3JTUx1tJDo601olQv0rHk4kGkKadIj3cvy-DDZKVRo\";\n    try {\n        json header, payload;\n        std::tie(header, payload) = JWT::Decode(token, &signer, &exp);\n        std::cout << \"You should not see this line\" << std::endl;\n    } catch (TokenFormatError &tfe) {\n        // No data can be recovered..\n    } catch (InvalidTokenError &tfe) {\n        json header, payload;\n        std::tie(header, payload) = JWT::Decode(token);\n        std::cout << \"Payload: \" << payload << std::endl;\n    }\n}\n```\n\nAgain compile and run it:\n\n```bash\ng++ -std=c++11  \\\n-I ~/homebrew/include \\\n-I ~/homebrew/opt/openssl@1.1/include \\\n-L ~/homebrew/opt/openssl@1.1/lib \\\n-L ~/homebrew/lib -lcrypto -ljwt -lssl \\\nfailed.cpp -o failed\n```\n\nShould result in something like this:\n\n```\nPayload: {\"exp\":1483228800,\"iss\":\"foo\"}\n```\n\n## The JSON Factories\nThe json factories make it easier to construct signers and validators. The BNF schemas below show you how you can construct signers. Note that signers can also be used as validators as well.\n\n```\nsigner ::=\n  \"none\"  : null |\n  \"HS256\" : { \"secret\" : \"*your actual secret*} |\n  \"HS384\" : { \"secret\" : \"*your actual secret*} |\n  \"HS512\" : { \"secret\" : \"*your actual secret*\" } |\n  \"RS256\" : { \"public\"  : (\"PEM block with key\" | { \"fromfile\" : \"/path/to/file/with/pem\" }),\n              \"private\" : (\"PEM...\" | { \"fromfile\" : \"....\" }) } |\n  \"RS384\" : { \"public\"  : (\"PEM...\" | { \"fromfile\" : \"....\" }),\n              \"private\" : (\"PEM...\" | { \"fromfile\" : \"....\" }) } |\n  \"RS512\" : { \"public\"  : (\"PEM...\" | { \"fromfile\" : \"....\" }),\n              \"private\" : (\"PEM...\" | { \"fromfile\" : \"....\" }) } |\n```\n\nThe BNF used to construct validators looks as follows:\n\n```\nvalidator ::=\n  \"none\"  : null |\n  \"HS256\" : { \"secret\" : \"....\" } |\n  \"HS384\" : { \"secret\" : \"....\" } |\n  \"HS512\" : { \"secret\" : \"....\" } |\n  \"RS256\" : { \"public\" : (\"PEM...\" | { \"fromfile\" : \"....\" }) } |\n  \"RS384\" : { \"public\" : (\"PEM...\" | { \"fromfile\" : \"....\" }) } |\n  \"RS512\" : { \"public\" : (\"PEM...\" | { \"fromfile\" : \"....\" }) } |\n  \"set\"   : [ validator+ ] |\n  \"kid\"   : ( { id : validator } )+\n```\n\n- A **set** validator will accept the token if any of the validators in the set accepts the token.\n- A **kid** validator will accept the token if the kid field of the token is\n  validated by the given validator. For example if the validator is declared as follows:\n\n  ```json\n  {\n    \"kid\" : { \"id1\" : { \"HS256\" : { \"secret\" : \"f13rc3\" } },\n              \"id2\" : { \"HS256\" : { \"secret\" : \"d0ntt3llmama\" } },\n              \"id3\" : { \"HS256\" : { \"secret\" : \"longlama\" } }\n            }\n  }\n\n  ```\n\n  and a token is being validated with the following JOSE header:\n\n  ```json\n  {\n    \"kid\" : \"id2\",\n    \"alg\" : \"HS256\",\n    \"typ\" : \"JWT\"\n  }\n  ```\n\n  it will try to validate the token using the validator with \"id2\". In the example above it is the HMAC256 validator with the secret \"d0ntt3llmama\".\n\n  See the [sample](test/token/sample.cpp) for more details on how this works.\n\nYou can build a MessageValidator by invoking the factory:\n``MessageValidator* MessageValidatorFactory::Build(std::string toBuild)``\n``MessageSigner* MessageValidatorFactory::BuildSigner(std::string toBuild)``\n\n*Note: Never include the none validator alongside other validators! See this\n[blog post](https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/)\nfor details.*\n\nClaimvalidators:\n\n```\nclaims ::=\n  single_claim |\n  \"optional\" : { (single_claim) } |\n  \"any\" : [ (claim)+ ] |\n  \"all\" : [ (claim)+ ]\n single_claim ::=\n  \"exp\" : (null | { \"leeway\" : .... }) |\n  \"nbf\" : (null | { \"leeway\" : .... }) |\n  \"iat\" : (null | { \"leeway\" : .... }) |\n  \"iss\" : [ \"...\"+ ] |\n  \"sub\" : [ \"...\"+ ] |\n  \"aud\" : [ \"...\"+ ] |\n```\n\nFor example:\n\n```\n{\r\n   \"all\":[\r\n      {\r\n         \"optional\":{ \"exp\":{ \"leeway\":32 } }\r\n      },\r\n      {\r\n         \"iss\":[ \"foo\", \"bar\" ]\r\n      }\r\n   ]\r\n}\n```\n\nIndicates that the claims set has the following:\n\n- If an expiration is set, its expiration should be no later than the current time + 32 seconds\n- It has been issued by either *foo*, or *bar*\n","versions":[{"ref":"master","manifest":"targets = [ \"//:jwt-cpp\" ]\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/host-dl\"\nversion = \"*\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/openssl\"\nversion = \"*\"\n","lockFile":"manifest = \"b2ad311c397c6652e25ba09a7a20ffe20948b197f51e30832d662bc1d0727bf4\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/host-dl\"\ntarget = \"//:dl\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/openssl\"\ntarget = \"//:openssl\"\n\n[lock.\"github.com/buckaroo-pm/host-dl\"]\nversions = [ \"branch=master\" ]\nrevision = \"69a239353756c2ef5c97e5a56a0964fb7ac6eb49\"\n\n[lock.\"github.com/buckaroo-pm/openssl\"]\nversions = [ \"tag=1.0.2j\" ]\nrevision = \"e61671249ee5dfa59b663d135b64dd6fe9efe9d0\"\n","buck":"load('//:subdir_glob.bzl', 'subdir_glob')\nload('//:buckaroo_macros.bzl', 'buckaroo_deps_from_package')\n\nlinux_deps = \\\n  buckaroo_deps_from_package('github.com/buckaroo-pm/openssl') + \\\n  buckaroo_deps_from_package('github.com/buckaroo-pm/host-dl')\n\nmacos_deps = \\\n  buckaroo_deps_from_package('github.com/buckaroo-pm/openssl')\n\ncxx_library(\n  name = 'jwt-cpp',\n  header_namespace = '',\n  exported_headers = subdir_glob([\n    ('src/include', 'jwt/**/*.hpp'),\n    ('src/include', 'jwt/**/*.h'),\n  ]),\n  headers = subdir_glob([\n    ('src/include', 'private/**/*.h'),\n  ]),\n  srcs = glob([\n    'src/**/*.cpp',\n  ]),\n  platform_deps = [\n    ('linux.*', linux_deps),\n    ('macos.*', macos_deps),\n  ],\n  visibility = [\n    'PUBLIC',\n  ],\n)\n","bazel":"","deps":[{"uri":"github.com/buckaroo-pm/host-dl","name":"buckaroo-pm/host-dl","version":"*"},{"uri":"github.com/buckaroo-pm/openssl","name":"buckaroo-pm/openssl","version":"*"}],"lock":[{"uri":"github.com/buckaroo-pm/host-dl","name":"buckaroo-pm/host-dl","spec":{"versions":["branch=master"],"revision":"69a239353756c2ef5c97e5a56a0964fb7ac6eb49"}},{"uri":"github.com/buckaroo-pm/openssl","name":"buckaroo-pm/openssl","spec":{"versions":["tag=1.0.2j"],"revision":"e61671249ee5dfa59b663d135b64dd6fe9efe9d0"}}]}],"updated":"2019-02-01T16:05:01Z","updatedUpstream":"2021-01-05T15:30:29Z","contributors":[{"login":"martindederer","avatarUrl":"https://avatars3.githubusercontent.com/u/156674?v=4"},{"login":"faragon","avatarUrl":"https://avatars0.githubusercontent.com/u/518864?u=2ab5b83540e82d6b7923575c59d2753884894929&v=4"},{"login":"GSIO01","avatarUrl":"https://avatars2.githubusercontent.com/u/1201965?v=4"},{"login":"pokowaka","avatarUrl":"https://avatars0.githubusercontent.com/u/4935150?u=7510fd2628d6d5ff45abd27b8a69ea39ea42a937&v=4"},{"login":"winfriedd","avatarUrl":"https://avatars3.githubusercontent.com/u/6376326?v=4"},{"login":"dyremeen","avatarUrl":"https://avatars1.githubusercontent.com/u/7857593?v=4"},{"login":"sdamm","avatarUrl":"https://avatars2.githubusercontent.com/u/11834140?v=4"},{"login":"jiri-novotny","avatarUrl":"https://avatars2.githubusercontent.com/u/13260918?v=4"},{"login":"wdobbe","avatarUrl":"https://avatars2.githubusercontent.com/u/19475596?v=4"},{"login":"DanFTRX","avatarUrl":"https://avatars1.githubusercontent.com/u/22240134?v=4"},{"login":"fvarose","avatarUrl":"https://avatars2.githubusercontent.com/u/22502546?v=4"},{"login":"mdr1384","avatarUrl":"https://avatars0.githubusercontent.com/u/32360633?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":86,"forks":43,"topics":[]}},"__N_SSG":true}