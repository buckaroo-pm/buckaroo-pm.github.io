{"pageProps":{"data":{"packageName":"buckaroo-pm/attractivechaos-klib","name":"attractivechaos/klib","licence":"","description":"A standalone and lightweight C library","readme":"# Klib: a Generic Library in C\n\n## <a name=\"overview\"></a>Overview\n\nKlib is a standalone and lightweight C library distributed under [MIT/X11\nlicense][1]. Most components are independent of external libraries, except the\nstandard C library, and independent of each other. To use a component of this\nlibrary, you only need to copy a couple of files to your source code tree\nwithout worrying about library dependencies.\n\nKlib strives for efficiency and a small memory footprint. Some components, such\nas khash.h, kbtree.h, ksort.h and kvec.h, are among the most efficient\nimplementations of similar algorithms or data structures in all programming\nlanguages, in terms of both speed and memory use.\n\nA new documentation is available [here](http://attractivechaos.github.io/klib/)\nwhich includes most information in this README file.\n\n#### Common components\n\n* [khash.h][khash]: generic [hash table][2] with open addressing.\n* [kbtree.h][kbtree]: generic search tree based on [B-tree][3].\n* [kavl.h][kavl]: generic intrusive [AVL tree][wiki-avl].\n* [ksort.h][ksort]: generic sort, including [introsort][4], [merge sort][5], [heap sort][6], [comb sort][7], [Knuth shuffle][8] and the [k-small][9] algorithm.\n* [kseq.h][kseq]: generic stream buffer and a [FASTA][10]/[FASTQ][11] format parser.\n* kvec.h: generic dynamic array.\n* klist.h: generic single-linked list and [memory pool][12].\n* kstring.{h,c}: basic string library.\n* kmath.{h,c}: numerical routines including [MT19937-64][13] [pseudorandom generator][14], basic [nonlinear programming][15] and a few special math functions.\n* [ketopt.h][ketopt]: portable command-line argument parser with getopt\\_long-like API.\n\n#### Components for more specific use cases\n\n* ksa.c: constructing [suffix arrays][16] for strings with multiple sentinels, based on a revised [SAIS algorithm][17].\n* knetfile.{h,c}: random access to remote files on HTTP or FTP.\n* kopen.c: smart stream opening.\n* khmm.{h,c}: basic [HMM][18] library.\n* ksw.(h,c}: Striped [Smith-Waterman algorithm][19].\n* knhx.{h,c}: [Newick tree format][20] parser.\n\n\n## <a name=\"methodology\"></a>Methodology\n\nFor the implementation of generic [containers][21], klib extensively uses C\nmacros. To use these data structures, we usually need to instantiate methods by\nexpanding a long macro. This makes the source code look unusual or even ugly\nand adds difficulty to debugging. Unfortunately, for efficient generic\nprogramming in C that lacks [template][22], using macros is the only\nsolution. Only with macros, we can write a generic container which, once\ninstantiated, compete with a type-specific container in efficiency. Some\ngeneric libraries in C, such as [Glib][23], use the `void*` type to implement\ncontainers. These implementations are usually slower and use more memory than\nklib (see [this benchmark][31]).\n\nTo effectively use klib, it is important to understand how it achieves generic\nprogramming. We will use the hash table library as an example:\n\n    #include \"khash.h\"\n    KHASH_MAP_INIT_INT(m32, char)        // instantiate structs and methods\n    int main() {\n        int ret, is_missing;\n        khint_t k;\n        khash_t(m32) *h = kh_init(m32);  // allocate a hash table\n        k = kh_put(m32, h, 5, &ret);     // insert a key to the hash table\n        if (!ret) kh_del(m32, h, k);\n        kh_value(h, k) = 10;             // set the value\n        k = kh_get(m32, h, 10);          // query the hash table\n        is_missing = (k == kh_end(h));   // test if the key is present\n        k = kh_get(m32, h, 5);\n        kh_del(m32, h, k);               // remove a key-value pair\n        for (k = kh_begin(h); k != kh_end(h); ++k)  // traverse\n            if (kh_exist(h, k))          // test if a bucket contains data\n    \t\t\tkh_value(h, k) = 1;\n        kh_destroy(m32, h);              // deallocate the hash table\n        return 0;\n    }\n\nIn this example, the second line instantiates a hash table with `unsigned` as\nthe key type and `char` as the value type. `m32` names such a type of hash table.\nAll types and functions associated with this name are macros, which will be\nexplained later. Macro `kh_init()` initiates a hash table and `kh_destroy()`\nfrees it. `kh_put()` inserts a key and returns the iterator (or the position)\nin the hash table. `kh_get()` and `kh_del()` get a key and delete an element,\nrespectively. Macro `kh_exist()` tests if an iterator (or a position) is filled\nwith data.\n\nAn immediate question is this piece of code does not look like a valid C\nprogram (e.g. lacking semicolon, assignment to an _apparent_ function call and\n_apparent_ undefined `m32` 'variable'). To understand why the code is correct,\nlet's go a bit further into the source code of `khash.h`, whose skeleton looks\nlike:\n\n    #define KHASH_INIT(name, SCOPE, key_t, val_t, is_map, _hashf, _hasheq) \\\n      typedef struct { \\\n        int n_buckets, size, n_occupied, upper_bound; \\\n        unsigned *flags; \\\n        key_t *keys; \\\n        val_t *vals; \\\n      } kh_##name##_t; \\\n      SCOPE inline kh_##name##_t *init_##name() { \\\n        return (kh_##name##_t*)calloc(1, sizeof(kh_##name##_t)); \\\n      } \\\n      SCOPE inline int get_##name(kh_##name##_t *h, key_t k) \\\n      ... \\\n      SCOPE inline void destroy_##name(kh_##name##_t *h) { \\\n        if (h) { \\\n          free(h->keys); free(h->flags); free(h->vals); free(h); \\\n        } \\\n      }\n    \n    #define _int_hf(key) (unsigned)(key)\n    #define _int_heq(a, b) (a == b)\n    #define khash_t(name) kh_##name##_t\n    #define kh_value(h, k) ((h)->vals[k])\n    #define kh_begin(h, k) 0\n    #define kh_end(h) ((h)->n_buckets)\n    #define kh_init(name) init_##name()\n    #define kh_get(name, h, k) get_##name(h, k)\n    #define kh_destroy(name, h) destroy_##name(h)\n    ...\n    #define KHASH_MAP_INIT_INT(name, val_t) \\\n    \tKHASH_INIT(name, static, unsigned, val_t, is_map, _int_hf, _int_heq)\n\n`KHASH_INIT()` is a huge macro defining all the structs and methods. When this\nmacro is called, all the code inside it will be inserted by the [C\npreprocess][37] to the place where it is called. If the macro is called\nmultiple times, multiple copies of the code will be inserted. To avoid naming\nconflict of hash tables with different key-value types, the library uses [token\nconcatenation][36], which is a preprocessor feature whereby we can substitute\npart of a symbol based on the parameter of the macro. In the end, the C\npreprocessor will generate the following code and feed it to the compiler\n(macro `kh_exist(h,k)` is a little complex and not expanded for simplicity):\n\n    typedef struct {\n      int n_buckets, size, n_occupied, upper_bound;\n      unsigned *flags;\n      unsigned *keys;\n      char *vals;\n    } kh_m32_t;\n    static inline kh_m32_t *init_m32() {\n      return (kh_m32_t*)calloc(1, sizeof(kh_m32_t));\n    }\n    static inline int get_m32(kh_m32_t *h, unsigned k)\n    ...\n    static inline void destroy_m32(kh_m32_t *h) {\n      if (h) {\n        free(h->keys); free(h->flags); free(h->vals); free(h);\n      }\n    }\n\n\tint main() {\n\t\tint ret, is_missing;\n\t\tkhint_t k;\n\t\tkh_m32_t *h = init_m32();\n\t\tk = put_m32(h, 5, &ret);\n\t\tif (!ret) del_m32(h, k);\n\t\th->vals[k] = 10;\n\t\tk = get_m32(h, 10);\n\t\tis_missing = (k == h->n_buckets);\n\t\tk = get_m32(h, 5);\n\t\tdel_m32(h, k);\n\t\tfor (k = 0; k != h->n_buckets; ++k)\n\t\t\tif (kh_exist(h, k)) h->vals[k] = 1;\n\t\tdestroy_m32(h);\n\t\treturn 0;\n\t}\n\nThis is the C program we know.\n\nFrom this example, we can see that macros and the C preprocessor plays a key\nrole in klib. Klib is fast partly because the compiler knows the key-value\ntype at the compile time and is able to optimize the code to the same level\nas type-specific code. A generic library written with `void*` will not get such\nperformance boost.\n\nMassively inserting code upon instantiation may remind us of C++'s slow\ncompiling speed and huge binary size when STL/boost is in use. Klib is much\nbetter in this respect due to its small code size and component independency.\nInserting several hundreds lines of code won't make compiling obviously slower.\n\n## <a name=\"resources\"></a>Resources\n\n* Library documentation, if present, is available in the header files. Examples\ncan be found in the [test/][24] directory.\n* **Obsolete** documentation of the hash table library can be found at\n[SourceForge][25]. This README is partly adapted from the old documentation.\n* [Blog post][26] describing the hash table library.\n* [Blog post][27] on why using `void*` for generic programming may be inefficient.\n* [Blog post][28] on the generic stream buffer.\n* [Blog post][29] evaluating the performance of `kvec.h`.\n* [Blog post][30] arguing B-tree may be a better data structure than a binary search tree.\n* [Blog post][31] evaluating the performance of `khash.h` and `kbtree.h` among many other implementations.\n[An older version][33] of the benchmark is also available.\n* [Blog post][34] benchmarking internal sorting algorithms and implementations.\n* [Blog post][32] on the k-small algorithm.\n* [Blog post][35] on the Hooke-Jeeve's algorithm for nonlinear programming.\n\n[1]: http://en.wikipedia.org/wiki/MIT_License\n[2]: https://en.wikipedia.org/wiki/Hash_table\n[3]: http://en.wikipedia.org/wiki/B-tree\n[4]: http://en.wikipedia.org/wiki/Introsort\n[5]: http://en.wikipedia.org/wiki/Merge_sort\n[6]: http://en.wikipedia.org/wiki/Heapsort\n[7]: http://en.wikipedia.org/wiki/Comb_sort\n[8]: http://en.wikipedia.org/wiki/Fisher-Yates_shuffle\n[9]: http://en.wikipedia.org/wiki/Selection_algorithm\n[10]: http://en.wikipedia.org/wiki/FASTA_format\n[11]: http://en.wikipedia.org/wiki/FASTQ_format\n[12]: http://en.wikipedia.org/wiki/Memory_pool\n[13]: http://en.wikipedia.org/wiki/Mersenne_twister\n[14]: http://en.wikipedia.org/wiki/Pseudorandom_generator\n[15]: http://en.wikipedia.org/wiki/Nonlinear_programming\n[16]: http://en.wikipedia.org/wiki/Suffix_array\n[17]: https://sites.google.com/site/yuta256/sais\n[18]: http://en.wikipedia.org/wiki/Hidden_Markov_model\n[19]: http://en.wikipedia.org/wiki/Smith-Waterman_algorithm\n[20]: http://en.wikipedia.org/wiki/Newick_format\n[21]: http://en.wikipedia.org/wiki/Container_(abstract_data_type)\n[22]: http://en.wikipedia.org/wiki/Template_(C%2B%2B)\n[23]: http://en.wikipedia.org/wiki/GLib\n[24]: https://github.com/attractivechaos/klib/tree/master/test\n[25]: http://klib.sourceforge.net/\n[26]: http://attractivechaos.wordpress.com/2008/09/02/implementing-generic-hash-library-in-c/\n[27]: http://attractivechaos.wordpress.com/2008/10/02/using-void-in-generic-c-programming-may-be-inefficient/\n[28]: http://attractivechaos.wordpress.com/2008/10/11/a-generic-buffered-stream-wrapper/\n[29]: http://attractivechaos.wordpress.com/2008/09/19/c-array-vs-c-vector/\n[30]: http://attractivechaos.wordpress.com/2008/09/24/b-tree-vs-binary-search-tree/\n[31]: http://attractivechaos.wordpress.com/2008/10/07/another-look-at-my-old-benchmark/\n[32]: http://attractivechaos.wordpress.com/2008/09/13/calculating-median/\n[33]: http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/\n[34]: http://attractivechaos.wordpress.com/2008/08/28/comparison-of-internal-sorting-algorithms/\n[35]: http://attractivechaos.wordpress.com/2008/08/24/derivative-free-optimization-dfo/\n[36]: http://en.wikipedia.org/wiki/C_preprocessor#Token_concatenation\n[37]: http://en.wikipedia.org/wiki/C_preprocessor\n\n[wiki-avl]: https://en.wikipedia.org/wiki/AVL_tree\n\n[kbtree]: http://attractivechaos.github.io/klib/#KBtree%3A%20generic%20ordered%20map:%5B%5BKBtree%3A%20generic%20ordered%20map%5D%5D\n[khash]: http://attractivechaos.github.io/klib/#Khash%3A%20generic%20hash%20table:%5B%5BKhash%3A%20generic%20hash%20table%5D%5D\n[kseq]: http://attractivechaos.github.io/klib/#Kseq%3A%20stream%20buffer%20and%20FASTA%2FQ%20parser:%5B%5BKseq%3A%20stream%20buffer%20and%20FASTA%2FQ%20parser%5D%5D\n[ksort]: http://attractivechaos.github.io/klib/#Ksort%3A%20sorting%2C%20shuffling%2C%20heap%20and%20k-small:%5B%5BKsort%3A%20sorting%2C%20shuffling%2C%20heap%20and%20k-small%5D%5D\n[kavl]: http://attractivechaos.github.io/klib/#KAVL%3A%20generic%20intrusive%20AVL%20tree\n[ketopt]: http://attractivechaos.github.io/klib/#Ketopt%3A%20parsing%20command-line%20arguments\n","versions":[{"ref":"master","manifest":"targets = [ \"//:klib\" ]\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/host-pthread\"\nversion = \"branch=master\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/madler-zlib\"\nversion = \"branch=master\"\n","lockFile":"manifest = \"acb7ecceb75915f8d749888ab92443f7c1f9756bc4716f6fe2a4c196fc453db6\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/host-pthread\"\ntarget = \"//:pthread\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/madler-zlib\"\ntarget = \"//:zlib\"\n\n[lock.\"github.com/buckaroo-pm/host-pthread\"]\nversions = [ \"branch=master\" ]\nrevision = \"a62519aa69c8e3243d6065fbf4c1d2de072f86f6\"\n\n[lock.\"github.com/buckaroo-pm/madler-zlib\"]\nversions = [ \"branch=master\" ]\nrevision = \"906f727175ca6a7f8943e375467d6e461a55b68d\"\n","buck":"load('//:tests.bzl', 'createTests')\nload('//:subdir_glob.bzl', 'subdir_glob')\nload('//:buckaroo_macros.bzl', 'buckaroo_deps_from_package')\n\ncxx_library(\n  name = 'klib',\n  header_namespace = '',\n  srcs = glob(['*.c']),\n  exported_headers = subdir_glob([\n    ('','*.h')\n  ]),\n  visibility = [\n    'PUBLIC',\n  ],\n  deps = buckaroo_deps_from_package('github.com/buckaroo-pm/host-pthread')\n)\n\ntest_suite(\n  name = 'test',\n  tests = createTests(glob(['test/*_test.c']))\n)\n","bazel":"","deps":[{"uri":"github.com/buckaroo-pm/host-pthread","name":"buckaroo-pm/host-pthread","version":"branch=master"},{"uri":"github.com/buckaroo-pm/madler-zlib","name":"buckaroo-pm/madler-zlib","version":"branch=master"}],"lock":[{"uri":"github.com/buckaroo-pm/host-pthread","name":"buckaroo-pm/host-pthread","spec":{"versions":["branch=master"],"revision":"a62519aa69c8e3243d6065fbf4c1d2de072f86f6"}},{"uri":"github.com/buckaroo-pm/madler-zlib","name":"buckaroo-pm/madler-zlib","spec":{"versions":["branch=master"],"revision":"906f727175ca6a7f8943e375467d6e461a55b68d"}}]}],"updated":"2019-01-23T14:36:59Z","updatedUpstream":"2021-01-13T22:22:34Z","contributors":[{"login":"johnm","avatarUrl":"https://avatars3.githubusercontent.com/u/8661?v=4"},{"login":"ihh","avatarUrl":"https://avatars2.githubusercontent.com/u/54113?v=4"},{"login":"jmarshall","avatarUrl":"https://avatars3.githubusercontent.com/u/70921?v=4"},{"login":"arrbee","avatarUrl":"https://avatars0.githubusercontent.com/u/103350?u=809e4e0a2c1279baa09850a56c64aefa49c4a3c6&v=4"},{"login":"zhanxw","avatarUrl":"https://avatars3.githubusercontent.com/u/157832?u=466c8c153019afae98d45da41c05049a8c36002b&v=4"},{"login":"lh3","avatarUrl":"https://avatars2.githubusercontent.com/u/480346?v=4"},{"login":"attractivechaos","avatarUrl":"https://avatars2.githubusercontent.com/u/563093?v=4"},{"login":"immerrr","avatarUrl":"https://avatars2.githubusercontent.com/u/579798?v=4"},{"login":"droe","avatarUrl":"https://avatars2.githubusercontent.com/u/749226?u=eb1e62f532b5403f0874f716d1cd2b4d550c64d2&v=4"},{"login":"leecbaker","avatarUrl":"https://avatars0.githubusercontent.com/u/1047159?v=4"},{"login":"zjf","avatarUrl":"https://avatars3.githubusercontent.com/u/1586818?v=4"},{"login":"pmelsted","avatarUrl":"https://avatars2.githubusercontent.com/u/1830628?v=4"},{"login":"jkbonfield","avatarUrl":"https://avatars1.githubusercontent.com/u/2210525?u=3aa71d7dfa4b08d0aae4e1cae19605a3cb3c4967&v=4"},{"login":"jiangzhuti","avatarUrl":"https://avatars2.githubusercontent.com/u/3127813?u=5177634c49fa32fdcb479bd76ea824be3e04ad6a&v=4"},{"login":"daviesrob","avatarUrl":"https://avatars2.githubusercontent.com/u/3234562?v=4"},{"login":"piki","avatarUrl":"https://avatars3.githubusercontent.com/u/3660033?u=aecc5ad678bd8a5ce36cfc11b785c389ffa1e653&v=4"},{"login":"sciascid","avatarUrl":"https://avatars1.githubusercontent.com/u/3881727?u=f5182ebc0b667613754311ac2c564a4e1b784b45&v=4"},{"login":"dnbaker","avatarUrl":"https://avatars2.githubusercontent.com/u/6412885?u=fcde1fe3079c4237b822fc7673c944736dacee8e&v=4"},{"login":"valeriuo","avatarUrl":"https://avatars1.githubusercontent.com/u/6553979?u=96404657a1e5dbcf5090852f86bce62991a7b8b7&v=4"}],"fundingLinks":[],"contactLinks":[],"stars":3170,"forks":442,"topics":["c","generic","library","hashtable","b-tree","avl-tree","sort","algorithm"]}},"__N_SSG":true}