{"pageProps":{"data":{"packageName":"buckaroo-pm/mapbox-shelf-pack-cpp","name":"mapbox/shelf-pack-cpp","licence":"ISC","description":"C++ port of https://github.com/mapbox/shelf-pack","readme":"[![Build Status](https://circleci.com/gh/mapbox/shelf-pack-cpp.svg?style=shield)](https://circleci.com/gh/mapbox/shelf-pack-cpp)\n\n## shelf-pack-cpp\n\nC++ port of [shelf-pack](https://github.com/mapbox/shelf-pack)\n\nA 2D rectangular [bin packing](https://en.wikipedia.org/wiki/Bin_packing_problem)\ndata structure that uses the Shelf Best Height Fit heuristic.\n\n\n### What is it?\n\n`shelf-pack` is a library for packing little rectangles into a big rectangle.  This sounds simple enough,\nbut finding an optimal packing is a problem with [NP-Complete](https://en.wikipedia.org/wiki/NP-completeness)\ncomplexity.  One useful application of bin packing is to assemble icons or glyphs into a sprite texture.\n\nThere are many ways to approach the bin packing problem, but `shelf-pack` uses the Shelf Best\nHeight Fit heuristic.  It works by dividing the total space into \"shelves\", each with a certain height.\nThe allocator packs rectangles onto whichever shelf minimizes the amount of wasted vertical space.\n\n`shelf-pack` is simple, fast, and works best when the rectangles have similar heights (icons and glyphs\nare like this).  It is not a generalized bin packer, and can potentially waste a lot of space if the\nrectangles vary significantly in height.\n\n\n### Usage\n\n#### Basic Usage\n\n```cpp\n#include <shelf-pack.hpp>\n#include <iostream>\n\nusing namespace mapbox;\n\nvoid main(void) {\n\n    // Initialize the sprite with a width and height..\n    ShelfPack sprite(64, 64);\n\n    // Pack bins one at a time..\n    for (int i = 0; i < 5; i++) {\n        Bin* bin = sprite.packOne(-1, 10, 10);\n        // `packOne()` accepts parameters: `id`, `width`, `height`\n        // and returns a pointer to a single allocated Bin object..\n        // `id` is optional - pass `-1` and shelf-pack will make up a number for you..\n\n        if (bin) {\n            std::cout << *bin << std::endl;\n        } else {\n            std::cout << \"out of space\" << std::endl;\n        }\n\n        /* output:\n        Bin { id: 1, x: 0, y: 0, w: 10, h: 10, maxw: 10, maxh: 10, refcount: 1 }\n        Bin { id: 2, x: 32, y: 0, w: 10, h: 10, maxw: 10, maxh: 10, refcount: 1 }\n        Bin { id: 3, x: 0, y: 32, w: 10, h: 10, maxw: 10, maxh: 10, refcount: 1 }\n        Bin { id: 4, x: 32, y: 32, w: 10, h: 10, maxw: 10, maxh: 10, refcount: 1 }\n        out of space\n        */\n    }\n\n    // Clear sprite and start over..\n    sprite.clear();\n\n    // Or, resize sprite by passing larger dimensions..\n    sprite.resize(128, 128);   // width, height\n}\n```\n\n\n#### Batch packing\n\n```cpp\n#include <shelf-pack.hpp>\n#include <iostream>\n\nvoid main(void) {\n\n    // If you don't want to think about the size of the sprite,\n    // the `autoResize` option will allow it to grow as needed..\n    ShelfPack::ShelfPackOptions options;\n    options.autoResize = true;\n    ShelfPack sprite(10, 10, options);\n\n    // Bins can be allocated in batches..\n    // Each bin should be initialized with `id`, `w` (width), `h` (height)..\n    std::vector<Bin> bins;\n    bins.emplace_back(-1, 10, 10);\n    bins.emplace_back(-1, 10, 12);\n    bins.emplace_back(-1, 10, 12);\n    bins.emplace_back(-1, 10, 10);\n\n    // `pack()` returns a vector of Bin* pointers, with `x`, `y`, `w`, `h` values..\n    std::vector<Bin*> results = sprite.pack(bins);\n\n    for (const auto& bin : results) {\n        std::cout << *bin << std::endl;\n    }\n    /* output:\n    Bin { id: 1, x: 0, y: 0, w: 10, h: 10, maxw: 10, maxh: 10, refcount: 1 }\n    Bin { id: 2, x: 0, y: 10, w: 10, h: 12, maxw: 10, maxh: 12, refcount: 1 }\n    Bin { id: 3, x: 10, y: 10, w: 10, h: 12, maxw: 10, maxh: 12, refcount: 1 }\n    Bin { id: 4, x: 10, y: 0, w: 10, h: 10, maxw: 10, maxh: 10, refcount: 1 }\n    */\n\n    // If you don't mind letting ShelfPack modify your objects,\n    // the `inPlace` option will assign `id`, `x`, `y` values to the incoming Bins.\n    // Fancy!\n    std::vector<Bin> myBins;\n    myBins.emplace_back(-1, 12, 24);\n    myBins.emplace_back(-1, 12, 12);\n    myBins.emplace_back(-1, 10, 10);\n\n    ShelfPack::PackOptions options;\n    options.inPlace = true;\n\n    sprite.pack(myBins, options);\n\n    for (const auto& mybin : myBins) {\n        std::cout << mybin << std::endl;\n    }\n\n    /* output:\n    { id: 5, x: 0, y: 22, w: 12, h: 24, maxw: 12, maxh: 24, refcount: 1 }\n    { id: 6, x: 20, y: 10, w: 12, h: 12, maxw: 12, maxh: 12, refcount: 1 }\n    { id: 7, x: 20, y: 0, w: 10, h: 10, maxw: 10, maxh: 10, refcount: 1 }\n    */\n}\n\n```\n\n#### Reference Counting\n\n```cpp\n#include <shelf-pack.hpp>\n#include <iostream>\n#include <array>\n\nvoid main(void) {\n\n    // Initialize the sprite with a width and height..\n    ShelfPack sprite(64, 64);\n    Bin* bin;\n\n    // Allocated bins are automatically reference counted.\n    // They start out having a refcount of 1.\n    std::array<int32_t, 3> ids = { 100, 101, 102 };\n    for(const auto& id : ids) {\n        bin = sprite.packOne(id, 16, 16);\n        std::cout << *bin << std::endl;\n    }\n\n    /* output:\n    Bin { id: 100, x: 0, y: 0, w: 16, h: 16, maxw: 16, maxh: 16, refcount: 1 }\n    Bin { id: 101, x: 16, y: 0, w: 16, h: 16, maxw: 16, maxh: 16, refcount: 1 }\n    Bin { id: 102, x: 32, y: 0, w: 16, h: 16, maxw: 16, maxh: 16, refcount: 1 }\n    */\n\n    // If you try to pack the same id again, shelf-pack will not re-pack it.\n    // Instead, it will increment the reference count automatically..\n    Bin* bin102 = sprite.packOne(102, 16, 16);\n    std::cout << *bin102 << std::endl;\n\n    /* output:\n    Bin { id: 102, x: 32, y: 0, w: 16, h: 16, maxw: 16, maxh: 16, refcount: 2 }\n    */\n\n    // You can also manually increment the reference count..\n    Bin* bin101 = sprite.getBin(101);\n    sprite.ref(*bin101);\n    std::cout << *bin101 << std::endl;\n\n    /* output:\n    Bin { id: 101, x: 16, y: 0, w: 16, h: 16, maxw: 16, maxh: 16, refcount: 2 }\n    */\n\n    // ...and decrement it!\n    Bin* bin100 = sprite.getBin(100);\n    sprite.unref(*bin100);\n    std::cout << *bin100 << std::endl;\n\n    /* output:\n    Bin { id: 100, x: 0, y: 0, w: 16, h: 16, maxw: 16, maxh: 16, refcount: 0 }\n    */\n\n    // Bins with a refcount of 0 are considered free space.\n    // Next time a bin is packed, shelf-back tries to reuse free space first.\n    // See how Bin 103 gets allocated at [0,0] - Bin 100's old spot!\n    Bin* bin103 = sprite.packOne(103, 16, 15);\n    std::cout << *bin103 << std::endl;\n\n    /* output:\n    Bin { id: 103, x: 0, y: 0, w: 16, h: 15, maxw: 16, maxh: 16, refcount: 1 }\n    */\n\n    // Bin 103 may be smaller (16x15) but it knows 16x16 was its original size.\n    // If that space becomes free again, a 16x16 bin will still fit there.\n    sprite.unref(*bin103);\n    Bin* bin104 = sprite.packOne(104, 16, 16);\n    std::cout << *bin104 << std::endl;\n\n    /* output:\n    Bin { id: 104, x: 0, y: 0, w: 16, h: 16, maxw: 16, maxh: 16, refcount: 1 }\n    */\n\n```\n\n\n### Documentation\n\nComplete API documentation can be found on the JavaScript version of the project:\nhttp://mapbox.github.io/shelf-pack/docs/\n\n\n### See also\n\nJ. JylÃ¤nky, \"A Thousand Ways to Pack the Bin - A Practical\nApproach to Two-Dimensional Rectangle Bin Packing,\"\nhttp://clb.demon.fi/files/RectangleBinPack.pdf, 2010\n","versions":[{"ref":"master","manifest":"targets = [ \"//:shelf-pack-cpp\" ]\n","lockFile":"","buck":"prebuilt_cxx_library(\n  name = 'shelf-pack-cpp', \n  header_namespace = 'mapbox', \n  header_only = True, \n  exported_headers = subdir_glob([\n    ('include', '**/*.hpp'), \n  ]), \n  visibility = [\n    'PUBLIC', \n  ], \n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2018-11-20T21:05:06Z","updatedUpstream":"2020-02-24T12:43:27Z","contributors":[{"login":"zugaldia","avatarUrl":"https://avatars1.githubusercontent.com/u/6964?u=e17bd7e9c8e0d4ca1df6956596cffc4ef10176de&v=4"},{"login":"bookest","avatarUrl":"https://avatars1.githubusercontent.com/u/14640?u=75e815f366d32a63b0d223fe47182a1570a96bb3&v=4"},{"login":"springmeyer","avatarUrl":"https://avatars1.githubusercontent.com/u/20300?v=4"},{"login":"mikelmaron","avatarUrl":"https://avatars1.githubusercontent.com/u/22896?u=f22126445e688b260ca316709407189f669c2083&v=4"},{"login":"mourner","avatarUrl":"https://avatars2.githubusercontent.com/u/25395?u=6f04fa0e30ee06ee7ef8d13dd6c166d0ca70aeea&v=4"},{"login":"sbma44","avatarUrl":"https://avatars2.githubusercontent.com/u/31717?v=4"},{"login":"sgillies","avatarUrl":"https://avatars3.githubusercontent.com/u/33697?u=518c359114c548926c56fef4b51a123e9a4a5d47&v=4"},{"login":"bhousel","avatarUrl":"https://avatars1.githubusercontent.com/u/38784?u=79ec19b1b876a4ba09982a03406c2838b77ba772&v=4"},{"login":"kkaefer","avatarUrl":"https://avatars1.githubusercontent.com/u/52399?u=7b3a53dfef51246b5c1342108a664842b4ea3571&v=4"},{"login":"alfwatt","avatarUrl":"https://avatars1.githubusercontent.com/u/53469?u=ff9e35352887e919bfd74b6ad0bee578af80e165&v=4"},{"login":"anderco","avatarUrl":"https://avatars1.githubusercontent.com/u/55106?v=4"},{"login":"yuletide","avatarUrl":"https://avatars3.githubusercontent.com/u/58695?u=6322adc3fcbff377e32f0e6299d7aaddd841dc6e&v=4"},{"login":"artemp","avatarUrl":"https://avatars1.githubusercontent.com/u/59056?u=84b41abea2ca9e9c6e5a6af9277ee06e8376c68f&v=4"},{"login":"tristen","avatarUrl":"https://avatars1.githubusercontent.com/u/61150?u=40b52d083ac2c6f414ef35c79271c776787e7bd0&v=4"},{"login":"ivovandongen","avatarUrl":"https://avatars1.githubusercontent.com/u/64527?u=e284cc763f7ca8765196fc0f6279e7538742cdfd&v=4"},{"login":"brunoabinader","avatarUrl":"https://avatars2.githubusercontent.com/u/76133?v=4"},{"login":"apendleton","avatarUrl":"https://avatars3.githubusercontent.com/u/78930?u=911348d600e91c721685538a958ee4252a854589&v=4"},{"login":"yhahn","avatarUrl":"https://avatars1.githubusercontent.com/u/83384?u=b2c1ca34e763ba420f510b5a1d62201c1d9624eb&v=4"},{"login":"PureW","avatarUrl":"https://avatars0.githubusercontent.com/u/85910?v=4"},{"login":"AlekseiCherkes","avatarUrl":"https://avatars3.githubusercontent.com/u/87640?u=f75d2bf7fd442db59db853feab57a208761fddef&v=4"},{"login":"ianshward","avatarUrl":"https://avatars2.githubusercontent.com/u/91258?u=5e631aa4328b540f955d9c2e9e2588fcc1bd0d0d&v=4"},{"login":"gundersen","avatarUrl":"https://avatars0.githubusercontent.com/u/93353?v=4"},{"login":"willwhite","avatarUrl":"https://avatars1.githubusercontent.com/u/93564?u=3e17a4a45e3ce686ca811d9ed79257db04ff345f&v=4"},{"login":"lxbarth","avatarUrl":"https://avatars2.githubusercontent.com/u/98233?u=3ca609d2f417501e961958c5bef2f99327b3f84e&v=4"},{"login":"jfirebaugh","avatarUrl":"https://avatars0.githubusercontent.com/u/98601?u=5b527e69ac7e93e41d9a9518e805e99bd4a08389&v=4"}],"fundingLinks":[],"contactLinks":[],"stars":7,"forks":9,"topics":[]}},"__N_SSG":true}