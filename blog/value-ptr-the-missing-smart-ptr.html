<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><link rel="stylesheet" type="text/css" href="/prism.css"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/value-ptr-the-missing-smart-ptr-1d04146963804e1a321b.js" as="script"/></head><body><div id="__next"><div class="site"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div style="width:100%;max-height:80vh;overflow:hidden"><img src="https://images.unsplash.com/photo-1583320975624-d099f8c042f6?ixid=MXwxMjA3fDB8MHxzZWFyY2h8Mnx8dmFsdWV8ZW58MHwwfDB8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60" style="width:100%"/></div><div class="banner white"><div class="view"><div><h1>value_ptr — The Missing C++ Smart-pointer</h1><div class="post"><h2>TL;DR</h2><p>Use the <code>value_ptr</code> smart-pointer to get value semantics on a heap resource. At the cost of some extra copying, your code will be simpler and easier to reason about.</p><p>Choose which smart-pointer to use with this cheat-sheet.</p><table><thead><tr><th>Name</th><th><code>unique_ptr</code></th><th><code>shared_ptr</code></th><th><code>weak_ptr</code></th><th><code>value_ptr</code></th></tr></thead><tbody><tr><td>Ownership</td><td>Unique</td><td>Shared</td><td>❌</td><td>Unique</td></tr><tr><td>Copyable</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Movable</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Sharing</td><td>❌</td><td>Reference</td><td>❌</td><td>Value</td></tr><tr><td>Lifetime</td><td>Lexical</td><td>Reference-counted</td><td>Non-extending</td><td>Lexical</td></tr><tr><td>Semantics</td><td>Reference</td><td>Reference</td><td>Optional-reference</td><td>Value</td></tr></tbody></table><p>An implementation of <code>value_ptr</code> can be <a href="https://github.com/LoopPerfect/valuable">found on GitHub</a>.</p><h2>Introduction</h2><p>Language features like templates, lambdas and lexically-scoped destructors empower C++ programmers to write higher-order containers to handle an object’s lifetime and side-effects, documenting them in an understandable way in the type-system.</p><p>With smart-pointers, encoding ownership semantics and managing resources has never been easier. We can find smart-pointers in the standard library for the most common use-cases, however none of these smart-pointers provides value semantics. This article will introduce the <code>value_ptr</code>, alongside some motivating examples.</p><p>But first, let’s take a look at the functionality that the C++ 11 standard library already offers:</p><h3>(Dumb) Raw Pointers</h3><p>Yes, raw pointers can be still used, but you should avoid them if a smart-pointer is applicable. This is because raw pointers do not convey any information about a resource’s ownership model.</p><p>Furthermore, allocation and deallocation must be managed by the programmer, which may lead to bugs like double-delete or memory-leaks.</p><p>Take a look at this code:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> x <span class="token operator">=</span> <span class="token function">createInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>From just three lines, there are so many unanswered questions:</p><ul><li>Can <code>x</code> be <code>nullptr</code> and do I have to check?</li><li>Is <code>x</code> managed? Can I delete <code>x</code>? <em>Must</em> I delete <code>x</code>?</li><li>If I delete <code>y</code> before <code>foo</code>, is <code>foo</code> still valid?</li><li>If <code>foo</code> gets destroyed, will <code>y</code> be deleted?</li></ul><p>Used correctly, a smart-pointer makes these clear.</p><h3>unique_ptr</h3><p><code>unique_ptr</code> manages the lifetime of an resource by taking sole ownership of it and binding that to its lexical scope. While copying is not possible, the ownership can be transferred via <code>std::move</code>.</p><p>Use <code>unique_ptr</code> when:</p><ul><li>You want to tie the lifetime of a heap resource to a lexical scope</li><li>You want to enforce that the resource only has one owner at a time</li></ul><h4>Example</h4><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Widget created&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Widget destroyed&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span> <span class="token function">createWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> w <span class="token operator">=</span> <span class="token function">createWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">ASSERT</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// auto w2 = widget;</span>
  <span class="token comment">// The above would error,</span>
  <span class="token comment">//   unique_ptr has no copy-constructor</span>

  <span class="token keyword">auto</span> w3 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>widget<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// w3 now owns the widget, w is empty</span>

  <span class="token function">ASSERT</span><span class="token punctuation">(</span>w3 <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// w3 calls destructor of widget;</span>
  <span class="token comment">//   only one object at a time owns the Widget</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3>shared_ptr</h3><p><code>shared_ptr</code> allows for multiple resource owners by counting the number of references under management. The container’s copy-constructor increments the counter and decrements it on destruction. If the counter hits zero, then the resource will be disposed.</p><p>Use <code>shared_ptr</code> when:</p><ul><li>You want to share ownership between multiple references</li><li>You want to dispose of a resource automatically when it is no longer used</li><li>You don’t have cyclic dependencies</li><li>The overhead of reference counting is acceptable</li></ul><h4>Example</h4><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Texture</span> <span class="token punctuation">{</span>
  <span class="token function">Texture</span><span class="token punctuation">(</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Texture loaded from &quot;</span> <span class="token operator">&lt;&lt;</span> path <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token operator">~</span><span class="token function">Texture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Texture destroyed&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> shared_ptr<span class="token operator">&lt;</span>Texture<span class="token operator">&gt;</span> <span class="token function">load</span><span class="token punctuation">(</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> make_shared<span class="token operator">&lt;</span>Texture<span class="token operator">&gt;</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// These functions will take a copy</span>
<span class="token comment">//   and increment the counter.</span>
<span class="token comment">// Using const&amp; would not increment the ref-counter.</span>
<span class="token keyword">int</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Texture<span class="token operator">&gt;</span> <span class="token keyword">const</span> tex<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">doSomethingElse</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Texture<span class="token operator">&gt;</span> <span class="token keyword">const</span> tex<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  shared_ptr<span class="token operator">&lt;</span>Texture<span class="token operator">&gt;</span> tex <span class="token operator">=</span>
    <span class="token class-name">Texture</span><span class="token operator">::</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token string">&quot;textures/my_texture.png&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">thread</span><span class="token punctuation">(</span>doSthWithTexture<span class="token punctuation">,</span> tex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">thread</span><span class="token punctuation">(</span>doSthMoreWithTexture<span class="token punctuation">,</span> tex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3>weak_ptr</h3><p>We saw that we can use <code>shared_ptr</code> with multiple owners, but what happens if we have cycles in the ownership graph? In this case, we would leak memory as the reference counter would never hit zero! The owners in the cycle would keep each-other alive.</p><p>This is where <code>weak_ptr</code> comes into play. <code>weak_ptr</code> is like <code>shared_ptr</code> but it does not increment the reference counter. If you replace the cycle-branch in your ownership graph with a <code>weak_ptr</code>, then reference counting will work correctly.</p><h4>Example</h4><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
  string name<span class="token punctuation">;</span>
  weak_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> parent<span class="token punctuation">;</span>
  vector<span class="token operator">&lt;</span>shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;&gt;</span> children<span class="token punctuation">;</span>

  <span class="token keyword">bool</span> <span class="token function">hasParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> parent<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> <span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> parent<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// If hasParent()</span>
    <span class="token comment">//  then return shared_ptr from parent</span>
    <span class="token comment">//  else nullptr</span>
  <span class="token punctuation">}</span>

  Node<span class="token operator">&amp;</span> <span class="token function">addChild</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">hasParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token string">&quot;node already belongs to a parent&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    children<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  Node<span class="token operator">&amp;</span> <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Remove parent;</span>
    children<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> <span class="token function">create</span><span class="token punctuation">(</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> make_shared<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> <span class="token function">createTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> root <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> foo <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> bar <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> baz <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">&quot;baz&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  root
    <span class="token operator">-&gt;</span><span class="token function">addChild</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
    <span class="token operator">-&gt;</span><span class="token function">addChild</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>

  bar<span class="token operator">-&gt;</span><span class="token function">addChild</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> tree <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> baz <span class="token operator">=</span> tree<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  tree<span class="token operator">-&gt;</span><span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Remove bar</span>

  <span class="token function">ASSERT</span><span class="token punctuation">(</span>baz<span class="token punctuation">.</span><span class="token function">hasParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// If parent would be a shared_ptr,</span>
  <span class="token comment">//   then bar and baz would keep</span>
  <span class="token comment">//   each-other alive forever.</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Use <code>weak_ptr</code> when:</p><ul><li>You absolutely must have a cyclic ownership graph</li></ul><h2>Introducing value_ptr</h2><p>Value semantics make your code easier to reason about because unlike pointers, ownership must be strictly hierarchical and exclusive.</p><p><code>value_ptr</code> allows us to enforce those semantics on a copyable resource on the heap.</p><h3>How it Works</h3><ul><li><code>value_ptr</code> has exclusive ownership of a resource on the heap.</li><li>When you assign one value_ptr to another, a new <code>value_ptr</code> object is constructed that points to its own copy of the previous <code>value_ptr</code>’s resource.</li><li>The resource is destroyed when the <code>value_ptr</code> leaves its lexical scope.</li><li>No memory is shared, so <code>value_ptr</code> is inherently thread-safe.</li><li>A modern compiler is smart enough to remove most redundant copies.</li></ul><h4>Example 1 — Recursive Data Types</h4><p>Recursive types like trees must be implemented via a pointer in C++ so the layout in memory can be computed at compile-time. However, despite using a pointer, we might still want the simplicity of value-semantics:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Tree</span> <span class="token punctuation">{</span>
  string <span class="token keyword">const</span> name<span class="token punctuation">;</span>
  value_ptr<span class="token operator">&lt;</span>Tree<span class="token operator">&gt;</span> left<span class="token punctuation">;</span>
  value_ptr<span class="token operator">&lt;</span>Tree<span class="token operator">&gt;</span> right<span class="token punctuation">;</span>

  <span class="token function">Tree</span><span class="token punctuation">(</span>
    string <span class="token keyword">const</span><span class="token operator">&amp;</span> name<span class="token punctuation">,</span>
    value_ptr<span class="token operator">&lt;</span>Tree<span class="token operator">&gt;</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> left <span class="token operator">=</span> value_ptr<span class="token operator">&lt;</span>Tree<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    value_ptr<span class="token operator">&lt;</span>Tree<span class="token operator">&gt;</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> right <span class="token operator">=</span> value_ptr<span class="token operator">&lt;</span>Tree<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> name<span class="token punctuation">{</span>name<span class="token punctuation">}</span>
    <span class="token punctuation">,</span> left<span class="token punctuation">{</span>left<span class="token punctuation">}</span>
    <span class="token punctuation">,</span> right<span class="token punctuation">{</span>right<span class="token punctuation">}</span>
  <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Tree root <span class="token operator">=</span> Tree<span class="token punctuation">{</span>
    <span class="token string">&quot;root&quot;</span><span class="token punctuation">,</span>
      Tree<span class="token punctuation">{</span><span class="token string">&quot;l0&quot;</span><span class="token punctuation">}</span>
      Tree<span class="token punctuation">{</span><span class="token string">&quot;r0&quot;</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// Copy of root assigned to left</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// and we don&#x27;t have cyclic references</span>
<span class="token punctuation">}</span>
</code></pre><h4>Example 2 — The PImpl Pattern</h4><p>Sometimes we want to separate the interface of a class from its implementation. This might be to hide code behind a compiled library, or to enforce a constant stack-size.</p><p>Since the lifetime is bound to the owner, a smart-pointer is appropriate here, but what semantics do we want to have? Unlike <code>shared_ptr</code> and <code>unique_ptr</code>, <code>value_ptr</code> gives us value semantics.</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ptr<span class="token operator">-&gt;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Thanks to value_ptr we get value semantics for free</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span>Foo <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

  Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Foo <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

  <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

  <span class="token keyword">struct</span> <span class="token class-name">Pimpl</span><span class="token punctuation">;</span>

  value_ptr<span class="token operator">&lt;</span>Pimpl<span class="token operator">&gt;</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p><em>Header</em></p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Foo</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">Pimpl</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Foo</span><span class="token operator">::</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
  <span class="token operator">:</span> ptr<span class="token punctuation">{</span>Foo<span class="token operator">::</span>Pimpl<span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><p><em>Translation-unit</em></p><h5>More Resources About the PImpl Pattern</h5><ul><li><a href="http://oliora.github.io/2015/12/29/pimpl-and-rule-of-zero.html">PImpl, Rule of Zero and Scott Meyers</a></li><li><a href="http://www.gotw.ca/gotw/028.htm">The Fast PImpl Idiom</a></li><li><a href="https://anteru.net/blog/2009/03/14/385/">PImpl You C++ Code</a></li></ul><h2>Implementing value_ptr</h2><p>You might have noticed that <code>value_ptr</code> is similar to <code>unique_ptr</code>, but with a different copy-constructor. Whilst copying a <code>unique_ptr</code> is forbidden, copying a <code>value_ptr</code> will create a copy of the resource. Thus, we can implement <code>value_ptr</code> by leveraging <code>unique_ptr</code> and a copy function.</p><p>This is what we have done; <a href="https://github.com/loopperfect/valuable">take a look on GitHub</a>, or test-drive our implementation with <a href="https://buckaroo.pm">Buckaroo</a>:</p><pre class="language-bash"><code class="language-bash">buckaroo <span class="token function">add</span> github.com/LoopPerfect/valuable
</code></pre><h2>Summary</h2><p>Value semantics are easy to reason about, and are often useful even for heap objects. The C++ standard library does not provide a smart-pointer with value semantics, but C++ has the features to allow us to roll-our-own.</p><p>Can’t decide which smart-pointer to use? Here’s a quick chart:</p><table><thead><tr><th>Name</th><th><code>unique_ptr</code></th><th><code>shared_ptr</code></th><th><code>weak_ptr</code></th><th><code>value_ptr</code></th></tr></thead><tbody><tr><td>Ownership</td><td>Unique</td><td>Shared</td><td>❌</td><td>Unique</td></tr><tr><td>Copyable</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Movable</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Sharing</td><td>❌</td><td>Reference</td><td>❌</td><td>Value</td></tr><tr><td>Lifetime</td><td>Lexical</td><td>Reference-counted</td><td>Non-extending</td><td>Lexical</td></tr><tr><td>Semantics</td><td>Reference</td><td>Reference</td><td>Optional-reference</td><td>Value</td></tr></tbody></table></div></div></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/value-ptr-the-missing-smart-ptr","query":{},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" async=""></script><script src="/_next/static/chunks/pages/blog/value-ptr-the-missing-smart-ptr-1d04146963804e1a321b.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>