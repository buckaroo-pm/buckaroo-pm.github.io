<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><link rel="stylesheet" type="text/css" href="/prism.css"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/quick-tips-for-java-programmers-0dc92ce99649ccdbb659.js" as="script"/></head><body><div id="__next"><div class="site"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div style="width:100%;max-height:80vh;overflow:hidden"><img src="/posts/7-tips-for-java.jpeg" style="width:100%"/></div><div class="banner white"><div class="view"><div><h1>7 Quick Tips for Java Programmers Starting C++</h1><div class="post"><h2>1. Avoid The new Keyword</h2><p>In Java, objects are instantiated using the new keyword, so it might be natural to assume that we should use new in C++ in the same manner:</p><pre class="language-java"><code class="language-java"><span class="token comment">//java</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Foo</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre class="language-cpp"><code class="language-cpp"><span class="token comment">//c++</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> foo<span class="token operator">-&gt;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Leak! </span>
<span class="token punctuation">}</span>
</code></pre><p>However, unlike in Java, a C++ variable instantiated with new is <em>unmanaged</em>, meaning that you must remember to free the memory after use.</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> foo<span class="token operator">-&gt;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> foo<span class="token punctuation">;</span> <span class="token comment">// How inconvenient! </span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>This can be done with the delete keyword. Coming from the Java world, this seems at best inconvenient, and at worst highly error-prone! Why is an extra statement required for the C++ version, when the Java equivalent is so concise?</p><p>In C++, there are multiple ways to instantiate an object and the preferred way to do so is directly onto the stack.</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo foo<span class="token punctuation">;</span>
  <span class="token keyword">return</span> foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo automatically destroyed</span>
<span class="token punctuation">}</span>
</code></pre><p>When variables are allocated on the stack, they are automatically deleted once they go out of scope. This is very concise, and has great performance characteristics.</p><h2>2. C++’s const is More Powerful Than Java’s final</h2><p>A common pattern when designing large applications is to make values immutable. This reduces complexity by lowering the number of moving parts an application has.</p><p>In Java, we can use the final keyword to mark a <em>reference</em> as immutable. However, the data that is being pointed to may change. For example:</p><pre class="language-java"><code class="language-java">
<span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> xs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// We can modify xs internally</span>
xs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ... but we cannot change where it points to!</span>
xs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Will not compile</span>
</code></pre><p>So to create truly immutable types, Java developers must mark all fields inside of a class as final:</p><pre class="language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  
  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> firstName<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> lastName<span class="token punctuation">;</span>
 
  <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> firstName<span class="token punctuation">,</span> <span class="token class-name">String</span> lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><pre class="language-cpp"><code class="language-cpp">final Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Smith&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">;</span> <span class="token comment">// Will not compile!</span>
</code></pre><p>In C++ we have the const keyword, which is far more powerful. If an instance is marked as const, then none of its members may change, even if they are not marked const in the class definition!</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>string firstName<span class="token punctuation">;</span> <span class="token comment">// No need for const here! </span>
  std<span class="token operator">::</span>string lastName<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><pre class="language-cpp"><code class="language-cpp">Person <span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Smith&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">;</span> <span class="token comment">// Will not compile!</span>
</code></pre><h2>3. Beware of Stack Slicing!</h2><p>In Java, the semantics of all objects is that they are on the heap (the reality is bit more complicated due to optimizations done by the JVM, but this is a good rudimentary understanding).</p><p>C++ is very different, because it allows the user to decide if the object should live on the heap or on the stack. Generally speaking, we should prefer the stack. It gives predictable (and fast!) performance, but it has a big limitation in that the size of each variable must be known at compile-time. This is a big problem when using inheritance.</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>string <span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>In this example we have two classes A and B, where B is a subclass of A. Each has a function what that returns the class name.</p><p>Given these definitions, what do you think the following will do?</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
  A x<span class="token punctuation">;</span>
  B y<span class="token punctuation">;</span>
  A z <span class="token operator">=</span> y<span class="token punctuation">;</span>
 
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;x.what() = &quot;</span> <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;y.what() = &quot;</span> <span class="token operator">&lt;&lt;</span> y<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;z.what() = &quot;</span> <span class="token operator">&lt;&lt;</span> z<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>If you are coming from the Java world, the answer might surprise you! It turns out that when y is cast to type A and assigned to z, it takes the what method of class A.</p><pre class="language-cpp"><code class="language-cpp">x<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> A
y<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> B
z<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> A
</code></pre><p>When a stack-variable is assigned to a super-class in C++, it takes the members and method implementations of that super-class. This is because the size of a variable’s value must not exceed the size of its type. For stack-variables, the compiler just “slices” off the extra information of the sub-class.</p><p>To prevent this, variables can be <em>pointed to</em> instead. A pointer (or <a href="https://en.wikipedia.org/wiki/Reference_(C%2B%2B)">reference</a><a href="https://en.wikipedia.org/wiki/Reference_(C%2B%2B)">)</a>)) always has the same size, regardless of the size of the value being pointed to.</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
  A<span class="token operator">*</span> x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  B<span class="token operator">*</span> y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  A<span class="token operator">*</span> z <span class="token operator">=</span> y<span class="token punctuation">;</span>
 
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;x-&gt;what() = &quot;</span> <span class="token operator">&lt;&lt;</span> x<span class="token operator">-&gt;</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;y-&gt;what() = &quot;</span> <span class="token operator">&lt;&lt;</span> y<span class="token operator">-&gt;</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;z-&gt;what() = &quot;</span> <span class="token operator">&lt;&lt;</span> z<span class="token operator">-&gt;</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
 
  <span class="token keyword">delete</span> x<span class="token punctuation">;</span>
  <span class="token keyword">delete</span> y<span class="token punctuation">;</span>
  <span class="token comment">// Do not delete z because z = y</span>
 
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre class="language-cpp"><code class="language-cpp">x<span class="token operator">-&gt;</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> A
y<span class="token operator">-&gt;</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> B
z<span class="token operator">-&gt;</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> B
</code></pre><h3>Quick Aside: value_ptr</h3><p>We released a new smart-pointer called value_ptr to make it easier to preserve value-semantics on the heap. See:
<a href="https://hackernoon.com/value-ptr-the-missing-c-smart-pointer-1f515664153e"><strong>value_ptr — The Missing C++ Smart-pointer</strong><em>TL;DR</em>hackernoon.com</a></p><h2>4. Overload Your Operators!</h2><p>Java does not allow you to define custom value-types and operators similar to int and boolean. As a result, vector and matrix implementations can be quite cumbersome!</p><pre class="language-java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Vector2</span> <span class="token punctuation">{</span>
 
  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">float</span> x<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">float</span> y<span class="token punctuation">;</span>
 
  <span class="token keyword">public</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token keyword">public</span> <span class="token class-name">Vector2</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Vector2</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token comment">// toString, hashCode, equals…</span>
<span class="token punctuation">}</span>
</code></pre><pre class="language-java"><code class="language-java">
<span class="token class-name">Vector2</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Vector2</span> u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Vector2</span> w <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>In C++, we can just overload the + operator:</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">struct</span> <span class="token class-name">Vector2</span> <span class="token punctuation">{</span>
  <span class="token keyword">float</span> x<span class="token punctuation">;</span>
  <span class="token keyword">float</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">inline</span> Vector2 <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>Vector2 <span class="token keyword">const</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> Vector2 <span class="token keyword">const</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> lhs<span class="token punctuation">.</span>x <span class="token operator">+</span> rhs<span class="token punctuation">.</span>x<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>y <span class="token operator">+</span> lhs<span class="token punctuation">.</span>y <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>This makes vectors usable with +, just like the built-in primitives.</p><pre class="language-cpp"><code class="language-cpp">Vector2 v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Vector2 u <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Vector2 w <span class="token operator">=</span> v <span class="token operator">+</span> w<span class="token punctuation">;</span> <span class="token comment">// Much better!</span>
</code></pre><h2>5. Take Advantage of Compile-time Programming</h2><p>Java’s generics are incredibly simple, and for the most part are only useful for collection types. C++ templates expand the possibilities of compile-time programming considerably, and are in some ways more akin to Java’s annotations.</p><p>Recall our Vector2 class from before. If we want to implement a 3-dimensional version in Java, then we need to create a new class:</p><pre class="language-java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Vector3</span> <span class="token punctuation">{</span>
 
  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">float</span> x<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">float</span> y<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">float</span> z<span class="token punctuation">;</span>
 
  <span class="token keyword">public</span> <span class="token class-name">Vector3</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token keyword">public</span> <span class="token class-name">Vector3</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Vector3</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">,</span> z <span class="token operator">+</span> v<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token comment">// toString, hashCode, equals...</span>
<span class="token punctuation">}</span>
</code></pre><p>In C++, we can make this a parameter of the type, and write generic code that handles all sizes only once! Code is generated at compile-time, so the generic code is no less efficient than the hand-written equivalent.</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> D<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Vector</span> <span class="token punctuation">{</span>
  
  <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">unsigned</span> N <span class="token operator">=</span> D<span class="token punctuation">;</span>
  <span class="token keyword">int</span> data<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
  
  <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> fill <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> fill<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token string">&quot;out of bound&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
   <span class="token comment">// begin, end, etc... </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>With this generic definition, we can create vectors of any length easily:</p><pre class="language-cpp"><code class="language-cpp">Vector<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
Vector<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
Vector<span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">&gt;</span> u<span class="token punctuation">;</span>
<span class="token comment">// etc... </span>
</code></pre><p>Templates can even speed up compilation times! See our comparison below:
<a href="https://hackernoon.com/comparing-the-compilation-times-of-templates-and-macros-d0a1b7264a17"><strong>Comparing the Compilation Times of C++ Templates and Macros</strong><em>TL;DR</em>hackernoon.com</a></p><h2>6. Use auto!</h2><p>Java famously <a href="http://openjdk.java.net/jeps/286">lacks a variable type-inference keyword</a> such as auto (C++), var (C#), val (Kotlin) or let (OCaml). This can make Java code quite verbose, particularly when classes like <a href="https://docs.spring.io/spring/docs/2.5.x/javadoc-api/org/springframework/aop/config/SimpleBeanFactoryAwareAspectInstanceFactory.html">SimpleBeanFactoryAwareAspectInstanceFactory</a> are in the wild!</p><p>With C++, the compiler can figure out many types for you, saving you some typing and making code more readable.</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">struct</span> <span class="token class-name">SomeClassWithAReallyLongName</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

SomeClassWithAReallyLongName <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  SomeClassWithAReallyLongName x<span class="token punctuation">;</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// auto instead of SomeClassWithAReallyLongName</span>
  x<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2>7. Be Prepared to Use More Libraries</h2><p>The JVM, for better or for worse, gives you many platform abstractions out-of-the-box. By comparison, C++ is extremely lean. It lacks built-in support for file-systems, networking and graphics. Instead, C++ developers have to leverage libraries for this functionality.</p><p>A good library will also abstract over platform differences, giving a common set of portable functions, just like Java. Neither approach is strictly better. Java developers benefit from a more unified ecosystem, since everyone is using the same underlying APIs. C++ developers are unburdened by functionality that they do not need, but they also have to make more decisions about what to use, and spend more time integrating it. See:
<a href="https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7"><strong>Approaches to C++ Dependency Management, or Why We Built Buckaroo</strong><em>C++ is an unusual language in that it does not yet have a dominant package manager (we’re working on it!). As a result…</em>hackernoon.com</a></p><h2>Buckaroo</h2><p>We created <a href="https://github.com/LoopPerfect/buckaroo">Buckaroo</a> to make it easier to integrate C++ libraries. If you would like try it out, the best place to start is <a href="http://buckaroo.readthedocs.io/en/latest/">the documentation</a>. You can browse the existing packages on <a href="https://buckaroo.pm/">Buckaroo.pm</a> or request more over on <a href="https://github.com/LoopPerfect/buckaroo-wishlist">the wishlist</a>.</p></div></div></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/quick-tips-for-java-programmers","query":{},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" async=""></script><script src="/_next/static/chunks/pages/blog/quick-tips-for-java-programmers-0dc92ce99649ccdbb659.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>