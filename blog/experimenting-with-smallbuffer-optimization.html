<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><link rel="stylesheet" type="text/css" href="/prism.css"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/experimenting-with-smallbuffer-optimization-70753f13df3d6ed08dd6.js" as="script"/></head><body><div id="__next"><div class="site"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div style="width:100%;max-height:80vh;overflow:hidden"><img src="/posts/smallfun.jpeg" style="width:100%"/></div><div class="banner white"><div class="view"><div><h1>Experimenting with Small Buffer Optimization for C++ Lambdas</h1><div class="post"><p>We implemented SmallFun, an alternative to std::function, which implements <em>fixed-size capture optimization</em> (a form of small buffer optimization). Whilst SmallFun is a bit less generic than std::function, it is <strong>3–5x faster</strong> in some benchmarks.</p><p>You can <a href="https://github.com/LoopPerfect/smallfunction">view the code on GitHub</a>.</p><p><img src="https://cdn-images-1.medium.com/max/3840/1*Q2X85fCAiULppjBiV9SC5A.jpeg" alt="Photo by [Pascal Richier](https://unsplash.com/photos/ECju13NcBzg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText) on [Unsplash](https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText)"/><em>Photo by <a href="https://unsplash.com/photos/ECju13NcBzg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Pascal Richier</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></em></p><h2>Background</h2><p>std::function is a convenient way to store lambdas with closures (also known as captures), whilst providing a unified interface. If you are coming from the OOP world, then it might be helpful to understand them as a generalization of the <a href="https://en.wikipedia.org/wiki/Strategy_pattern">strategy pattern</a>.</p><p>Before std::function and lambdas, we would create a hand-crafted functor object like this:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Functor</span> <span class="token punctuation">{</span>
  <span class="token comment">// The context, or capture</span>
  <span class="token comment">// For example, an int and an unsigned</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> N<span class="token punctuation">;</span>
  
  <span class="token comment">// The lambda</span>
  <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">// For example, a small math function</span>
    <span class="token keyword">return</span> i <span class="token operator">*</span> j <span class="token operator">+</span> N<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>This repository compares std::function, the hand-crafted Functor and SmallFun. We find that SmallFun performs better then std::function by being slighly less generic.</p><h2>The Missed Opportunity of std::function</h2><p>std::function uses a <a href="http://en.cppreference.com/w/cpp/language/pimpl">PImpl pattern</a> to provide an unified interface aross all functors for a given signature.</p><p>For example, these two instances f and g have the same size, despite having different captures:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token comment">// f captures nothing</span>
std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// g captures x, y and z</span>
std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>This is because std::function stores the capture on the <em>heap</em>. This unifies the size of all instances, but it is also an opportunity for optimization!</p><h2>How?</h2><p>Instead of dynamically allocating memory on the <em>heap</em>, we can place the function object (including its virtual table) into a preallocated location on the <em>stack</em>.</p><p>This is how we implemented SmallFun, which is used much like std::function:</p><pre class="language-cpp"><code class="language-cpp"><span class="token comment">// A SmallFun with a size of 64 bytes</span>
SmallFun<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">const</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> N<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> i <span class="token operator">*</span> j <span class="token operator">+</span> N<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h2>Benchmarks</h2><table><thead><tr><th>Test</th><th>Time</th><th>Note</th></tr></thead><tbody><tr><td>functor</td><td>191 ns</td><td>Baseline that&#x27;s the best we could do: a hand-crafted functor</td></tr><tr><td>sf32</td><td>312 ns</td><td>This is big enough to store 2 ints</td></tr><tr><td>sf64</td><td>369 ns</td><td></td></tr><tr><td>sf128</td><td>346 ns</td><td></td></tr><tr><td>sf256</td><td>376 ns</td><td></td></tr><tr><td>sf512</td><td>503 ns</td><td></td></tr><tr><td>sf1024</td><td>569 ns</td><td></td></tr><tr><td>sf2048</td><td>870 ns</td><td></td></tr><tr><td>std::function</td><td>1141 ns</td><td></td></tr></tbody></table><h2>The Test</h2><p>To test how quickly we can allocate and call functors, we will be saving all the many instances in a vector and executing them in a loop. The results are saved into another vector to ensure that the optimizer does not optimize away what we are testing.</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">void</span> <span class="token function">stdFunction</span><span class="token punctuation">(</span>benchmark<span class="token operator">::</span>State<span class="token operator">&amp;</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
  <span class="token keyword">unsigned</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
 
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">const</span> j<span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> <span class="token function">fs</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">r</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
  <span class="token keyword">while</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span><span class="token function">KeepRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> N<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// assign to the type-erased container</span>
        <span class="token keyword">return</span> i <span class="token operator">*</span> j <span class="token operator">+</span> N<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// eval the function objects</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h2>SmallFun Implementation Details</h2><p>To implement SmallFun, we need to combine three C++ patterns: <a href="https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/">type-erasure</a>, <a href="http://en.cppreference.com/w/cpp/language/pimpl">PImpl</a> and <a href="https://stackoverflow.com/a/222578/1256041">placement-new</a>.</p><h3>Type-erasure</h3><p>Type-erasure unifies many implementations into one interface. In our case, every lambda (or functor) has a custom call operator and destructor. We need to automatically generate an implementation for any type the API consumer will be using.</p><p>This shall be our public interface:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ReturnType</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Xs<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Concept</span> <span class="token punctuation">{</span>
  <span class="token keyword">virtual</span> ReturnType <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> ReturnType <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Concept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>And for any callable type with a given signature:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">ReturnType</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Xs<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Model</span> final <span class="token operator">:</span> Concept<span class="token operator">&lt;</span>ReturnType<span class="token punctuation">,</span> Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  
  F f<span class="token punctuation">;</span>
  
  <span class="token function">Model</span><span class="token punctuation">(</span>F <span class="token keyword">const</span><span class="token operator">&amp;</span> f<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">f</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
  <span class="token keyword">virtual</span> ReturnType <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">virtual</span> ReturnType <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Model</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>Now we can use it the following way:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> lambdaType <span class="token operator">=</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>lambda<span class="token punctuation">)</span><span class="token punctuation">;</span>
SFConcept<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">*</span> functor <span class="token operator">=</span> <span class="token keyword">new</span> Model<span class="token operator">&lt;</span>lambdaType<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>lambda<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>This is quite cumbersome and error prone. The next step will be a container.</p><h3>PImpl</h3><p>PImpl seperates, hides, manages the lifetime of an actual implementation and exposes a limited public API.</p><p>A straightforward implementation could look like this:</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ReturnType</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Xs<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span><span class="token function">ReturnType</span><span class="token punctuation">(</span>Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Concept<span class="token operator">&lt;</span>ReturnType<span class="token punctuation">,</span>Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span> pimpl<span class="token punctuation">;</span>
  
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
  <span class="token function">Function</span><span class="token punctuation">(</span>F <span class="token keyword">const</span><span class="token operator">&amp;</span> f<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">pimpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> SFModel<span class="token operator">&lt;</span>F<span class="token punctuation">,</span> ReturnType<span class="token punctuation">,</span> Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token punctuation">)</span> <span class="token comment">// heap allocation</span>
  <span class="token punctuation">{</span><span class="token punctuation">}</span>
 
  <span class="token operator">~</span><span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>This is more or less how std::function is implemented.</p><p>So how do we remove the heap allocation?</p><h3>Placement-new</h3><p>Placement-new allocates memory at a given address. For example:</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">char</span> memorypool<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>memorypool<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>memorypool <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">assert</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>memorypool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>memorypool<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h3>Putting it All Together</h3><p>Now we only need to do minor changes to remove the heap allocation:</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ReturnType</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Xs<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SmallFun</span><span class="token operator">&lt;</span><span class="token function">ReturnType</span><span class="token punctuation">(</span>Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>

  <span class="token keyword">char</span> memory<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
  
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
  <span class="token function">SmallFun</span><span class="token punctuation">(</span>F <span class="token keyword">const</span><span class="token operator">&amp;</span> f<span class="token punctuation">)</span> 
    <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>memory<span class="token punctuation">)</span> Model<span class="token operator">&lt;</span>F<span class="token punctuation">,</span> ReturnType<span class="token punctuation">,</span> Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Model<span class="token operator">&lt;</span>F<span class="token punctuation">,</span> ReturnType<span class="token punctuation">,</span> Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> SIZE <span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
 
  <span class="token operator">~</span><span class="token function">SmallFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>allocated<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">concept</span><span class="token operator">*</span><span class="token punctuation">)</span>memory<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token keyword">concept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>As you may noticed, if the Model&lt;...&gt;’s size is greater than SIZE, bad things will happen! An assert will only catch this at run-time, when it is to late… Luckily, this can be caught at compile-time using enable_if_t.</p><p>But first, what about the copy constructor?</p><h3>Copy Constructor</h3><p>Unlike the implementation of std::function, we cannot just copy or move a std::shared_ptr. We also cannot just copy bitwise the memory, since the lambda may manage a resource that can only be released once due to a side-effect. Therefore, we need to make the model able to copy-construct itself for a given memory location.</p><p>We just need to add:</p><pre class="language-cpp"><code class="language-cpp">  <span class="token comment">// ...</span>

  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> memory<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token punctuation">(</span>memory<span class="token punctuation">)</span> Model<span class="token operator">&lt;</span>F<span class="token punctuation">,</span> ReturnType<span class="token punctuation">,</span> Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> rhsSize<span class="token punctuation">,</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token punctuation">(</span>rhsSize <span class="token operator">&lt;=</span> size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">&gt;</span>
  <span class="token function">SmallFun</span><span class="token punctuation">(</span>SmallFun<span class="token operator">&lt;</span><span class="token function">ReturnType</span><span class="token punctuation">(</span>Xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rhsSize<span class="token operator">&gt;</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rhs<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token comment">// ...</span>
</code></pre><h2>Further Remarks</h2><ul><li><p>As we saw, we can verify at compile-time if a Lambda will fit in our memory. If it does not, we could provide a fallback to heap allocation.</p></li><li><p>A more generic implementation of SmallFun would take a generic allocator.</p></li><li><p>We noticed that we cannot copy the memory just by copying the memory bitwise. However using type-traits, we could check if
the underlying data-type is POD and then copy bitwise.</p></li></ul><h2>Since You’re Here…</h2><p>We created <a href="https://github.com/LoopPerfect/buckaroo">Buckaroo</a> to make it easier to integrate C++ libraries. If you would like try it out, the best place to start is <a href="http://buckaroo.readthedocs.io/en/latest/">the documentation</a>. You can browse the existing packages on <a href="https://buckaroo.pm/">Buckaroo.pm</a> or request more over on <a href="https://github.com/LoopPerfect/buckaroo-wishlist">the wishlist</a>.
<a href="https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7"><strong>Approaches to C++ Dependency Management, or Why We Built Buckaroo</strong><em>C++ is an unusual language in that it does not yet have a dominant package manager (we’re working on it!). As a result…</em>hackernoon.com</a>
<a href="https://hackernoon.com/error-handling-in-c-or-why-you-should-use-eithers-in-favor-of-exceptions-and-error-codes-f0640912eb45"><strong>Error Handling in C++ or: Why You Should Use Eithers in Favor of Exceptions and Error-codes</strong><em>TL;DR</em>hackernoon.com</a></p></div></div></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/experimenting-with-smallbuffer-optimization","query":{},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" async=""></script><script src="/_next/static/chunks/pages/blog/experimenting-with-smallbuffer-optimization-70753f13df3d6ed08dd6.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>