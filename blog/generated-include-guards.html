<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><link rel="stylesheet" type="text/css" href="/prism.css"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/generated-include-guards-b0cea3f66f6ab20a596b.js" as="script"/></head><body><div id="__next"><div class="site"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div style="width:100%;max-height:80vh;overflow:hidden"><img src="/posts/generated-include-guards.jpeg" style="width:100%"/></div><div class="banner white"><div class="view"><div><h1>Generated Include Guards: An Alternative to pragma once</h1><div class="post"><h2>Introduction</h2><p>In C++, nothing prevents the programmer from including a header-file multiple times. This can cause a duplication of definitions, which is an error. Since it is difficult to ensure that a header-file is only included once, a common strategy is to make only the first include count. This can be done using an “include guard”, a small piece of preprocessor logic that looks like this:</p><pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;foo.hpp&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;foo.hpp&quot;</span></span>
</code></pre><h3>How Does it Work?</h3><p>On the first include, HEADER_HAS_BEEN_INCLUDED is not defined, so we define foo. On subsequent includes, HEADER_HAS_BEEN_INCLUDED has been defined, so we just skip the content.</p><p>For example, if we have this C++ file:</p><pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HEADER_HAS_BEEN_INCLUDED</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HEADER_HAS_BEEN_INCLUDED</span></span>

<span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> member<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HEADER_HAS_BEEN_INCLUDED</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HEADER_HAS_BEEN_INCLUDED</span></span>

<span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> member<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><p>Then it will expand to this:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> member<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>And after the preprocessor has finished, we are left with this:</p><pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>

<span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> member<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>This is the idiomatic approach, but it has some limitations:</p><ol><li><p>Three lines of boiler-plate code are required</p></li><li><p>The variable name on lines 1 and 2 must match <em>exactly</em></p></li><li><p>The same variable name must not be used in multiple files</p></li><li><p>We have to remember the #endif, which is located at the other end of the file to the #ifndef</p></li></ol><h3>What About pragma once?</h3><p>#pragma once was designed to overcome these issues. It is a non-standard, but widely supported, feature of C++ compilers. The concept is simple: any file containing #pragma once will only <em>actually</em> be included once, even if the programmer includes it multiple times.</p><p>Using <code>#pragma once</code>, our examples becomes:</p><pre><code>for each header file:
  hash the file
  generate an include guard from the hash
  wrap the contents 
  output into a new header file
</code></pre><p>Looks good, right? Sadly #pragma once brings a host of problems.</p><p>The root cause is that #pragma once is concerned with <em>where</em> some code lives, rather than its <em>content</em>. If you have two copies of the same file accessible via multiple paths, then it will get included twice. And, if you have two paths that <em>appear</em> different, but are actually the same, then the compiler may not spot this. To top things off, it is not standard, so compiler implementations do not have to respect its semantics.</p><h2>A Possible Workaround</h2><p>The problems with #pragma once stem from the fact that it works off of a file’s location, rather than its content. What if we just used the content instead?<em>(Of course, recording all of the contents of each header would be slow, but we can optimize by recording a hash of the content instead).</em></p><p>The process would be:</p><ol><li>When a header-file is included, hash it</li><li>If the hash has been seen before, then ignore the include</li><li>Otherwise, include the header as normal</li></ol><p>This would be a robust solution because it is not at all concerned about the path a file is found at, only its content.</p><h2>Implementing the Workaround</h2><p>Adding a new command to the C++ standard would take considerable time, but luckily we can implement this logic using scripting and preprocessor.</p><p>The basic idea is this:</p><pre><code>for each header file:
  hash the file
  generate an include guard from the hash
  wrap the contents 
  output into a new header file
</code></pre><p>So, for example this header:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Has a SHA-256 hash of:</p><pre><code>786be73f07f8bf5cc4c26dd0bb4f57e0777671adf256e6d5168a4f0c02f167b6
</code></pre><p>So the generated header might be:</p><pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">INCLUDED_786be73f07f8bf5cc4c26dd0bb4f57e0</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INCLUDED_786be73f07f8bf5cc4c26dd0bb4f57e0</span></span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><p>Whilst the transformation for individual files is simple (<a href="https://github.com/njlr/buck-include-guards/blob/84c3a67dcb5eb6d9924cacc4f2c33723beb6245a/scripts/add-include-guard.py">Python script</a>), we still need to manage the transformation process. We need to ensure that:</p><ul><li><p>The transformation is run for every file</p></li><li><p>New files are automatically transformed</p></li><li><p>The transformations of deleted files are automatically removed</p></li><li><p>The transformation is only re-run when the file has changed</p></li><li><p><em>Bonus: Transformations can be safely put into a shared network cache</em></p></li></ul><p>Using <a href="https://buckbuild.com/">Buck build</a>, we can encode this logic into a project’s build script easily.</p><p>Let’s start with a build-rule for a single file and then generalize:</p><pre class="language-python"><code class="language-python">genrule<span class="token punctuation">(</span>
  name <span class="token operator">=</span> <span class="token string">&#x27;guarded-add&#x27;</span><span class="token punctuation">,</span> 
  out <span class="token operator">=</span> <span class="token string">&#x27;add.hpp&#x27;</span><span class="token punctuation">,</span>
  srcs <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">&#x27;scripts/add-include-guard.py&#x27;</span><span class="token punctuation">,</span>
    <span class="token string">&#x27;add.hpp&#x27;</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  cmd <span class="token operator">=</span> <span class="token string">&#x27;python $SRCS &gt; $OUT&#x27;</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre><p>A genrule in Buck is much like a target in Make. We define the input files, the output file name and the command to execute. This target takes our Python script for generating an include guard and runs it on add.hpp. Unlike Make, Buck will isolate and cache the process on its input hashes.</p><p>Now we have a single file working, we can generalize the process to n files. To do this, we make a Python function that creates a genrule for a given file:</p><pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add_include_guard</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
  name <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>sha256<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span>
  genrule<span class="token punctuation">(</span>
    name <span class="token operator">=</span> name<span class="token punctuation">,</span>
    out <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>basename<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    srcs <span class="token operator">=</span> <span class="token punctuation">[</span>
      <span class="token string">&#x27;scripts/add-include-guard.py&#x27;</span><span class="token punctuation">,</span> 
      x<span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    cmd <span class="token operator">=</span> <span class="token string">&#x27;python $SRCS &gt; $OUT&#x27;</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token string">&#x27;:&#x27;</span> <span class="token operator">+</span> name
</code></pre><p>To get the set of header files, we run a glob expression. For example:</p><pre class="language-python"><code class="language-python">mathutils_headers <span class="token operator">=</span> subdir_glob<span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">(</span><span class="token string">&#x27;mathutils/include&#x27;</span><span class="token punctuation">,</span> <span class="token string">&#x27;**/*.hpp&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><p>And to bring it all together:</p><pre class="language-cpp"><code class="language-cpp"><span class="token function">cxx_library</span><span class="token punctuation">(</span>
  name <span class="token operator">=</span> <span class="token string">&#x27;mathutils&#x27;</span><span class="token punctuation">,</span>
  header_namespace <span class="token operator">=</span> <span class="token string">&#x27;mathutils&#x27;</span><span class="token punctuation">,</span>
  exported_headers <span class="token operator">=</span> <span class="token function">dict</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token function">add_include_guard</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> in mathutils_headers<span class="token punctuation">.</span><span class="token function">items</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  srcs <span class="token operator">=</span> <span class="token function">glob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token string">&#x27;mathutils/src/**/*.cpp&#x27;</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre><p>You can find a complete <a href="https://github.com/njlr/buck-include-guards">working example on GitHub</a>.</p><p>Now, our header files can be written without include guards or #pragma once:</p><pre><code>int add(int x, int y);
</code></pre><p>This setup in Buck is really nice to work with:</p><ul><li><p>Zero boiler-plate in the header files</p></li><li><p>Buck will automatically check for new header files, so that builds are always up-to-date</p></li><li><p>Buck will remove stale generated headers</p></li><li><p>Because it understands the target graph, Buck will generate headers in parallel</p></li><li><p>Buck will cache generated headers so that they are only computed when required</p></li><li><p>We are no longer relying on human accuracy (include guards) or non-standard features (#pragma once)</p></li></ul><h2>Since You’re Here…</h2><p>We created <a href="https://github.com/LoopPerfect/buckaroo">Buckaroo</a> to make it easier to integrate C++ libraries. If you would like try it out, the best place to start is <a href="https://buckaroo.readthedocs.io/en/latest/">the documentation</a>. You can browse the existing packages on <a href="https://www.buckaroo.pm/">Buckaroo.pm</a> or request more over on <a href="https://github.com/LoopPerfect/buckaroo-wishlist">the wishlist</a>.
<a href="https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7"><strong>Approaches to C++ Dependency Management, or Why We Built Buckaroo</strong><em>C++ is an unusual language in that it does not yet have a dominant package manager (we’re working on it!). As a result…</em>hackernoon.com</a></p></div></div></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/generated-include-guards","query":{},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" async=""></script><script src="/_next/static/chunks/pages/blog/generated-include-guards-b0cea3f66f6ab20a596b.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>