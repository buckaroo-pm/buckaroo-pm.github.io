<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><link rel="stylesheet" type="text/css" href="/prism.css"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/introducing-conduit-lazy-sequences-for-c-6587de0d27ac00abebf5.js" as="script"/></head><body><div id="__next"><div class="site"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div style="width:100%;max-height:80vh;overflow:hidden"><img src="/posts/introducing-conduit.png" style="width:100%"/></div><div class="banner white"><div class="view"><div><h1>Introducing Conduit: Lazy Sequences Using the Coroutine TS</h1><div class="post"><p><a href="https://github.com/LoopPerfect/conduit">Conduit</a> is a new library that leverages the <a href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">Coroutine TS</a> to introduce lazy sequences to C++.</p><p>Lazy sequences are an idea that’s very popular in the functional-programming community, but less common in the C++ world.</p><blockquote><h1><strong>Simply put, a lazy sequence is one where the elements are computed as they are requested, rather than in advance.</strong></h1></blockquote><p>This can lead to big efficiency gains since you only perform the computation required. It also allows you to represent infinite sequences, which of course could never fit into a vector!</p><p>Let’s see how Conduit works with some simple examples…</p><h2>Square Numbers</h2><p>Everyone is familiar with square numbers, so this is a great place to start.</p><blockquote><p><em>0, 1, 4, 9, 16, …</em></p></blockquote><p>A Conduit sequence is defined using the seq template. Here we have a sequence of ints:</p><pre class="language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> squares <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> seq<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">co_yield</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
    <span class="token operator">++</span>x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>You might see the while (true) and be alarmed, but don’t worry! This function is a coroutine, meaning it can suspend its execution and return control back to the caller. This prevents an infinite loop.</p><p>The suspension point is co_yield x * x. This statement saves the stack onto the heap for later reuse, returns the next sequence element and jumps execution back to the caller.</p><p>OK… but how do I use this in practice?</p><p>Every seq can be used as an iterator:</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> <span class="token function">squares</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token comment">// squares is infinite, so we need to break</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token operator">++</span>i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Alternatively, you can save the whole sequence into a std::vector. Just be sure not to try this on an infinite sequence!</p><pre class="language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">&gt;&gt;</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
  <span class="token operator">&gt;&gt;</span> <span class="token function">toVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// v = { 0, 1, 2, 3, 4 }</span>
</code></pre><h2>Sequence Transformations</h2><p>This is pretty cool, but things get really interesting once you start combining and transforming sequences. To give you some idea, look at how concisely these functions can be implemented…</p><pre class="language-cpp"><code class="language-cpp"><span class="token comment">// Sum of the first 10 squares </span>
<span class="token keyword">auto</span> total <span class="token operator">=</span> <span class="token function">squares</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Jumps between the first 10 squares</span>
<span class="token keyword">auto</span> jumps <span class="token operator">=</span> <span class="token function">squares</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token operator">&gt;&gt;</span> <span class="token function">scan</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">,</span> <span class="token keyword">auto</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y <span class="token operator">-</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> 
  <span class="token operator">&gt;&gt;</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// The obligatory fibonacci</span>
<span class="token keyword">auto</span> fibonacci <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> seq<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  
  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token boolean">true</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">co_yield</span> a<span class="token punctuation">;</span>
    
    <span class="token function">tie</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> tuple<span class="token punctuation">{</span>a <span class="token operator">+</span> b<span class="token punctuation">,</span> a<span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Cumulative sum of 6 pseduo-random dice rolls</span>
<span class="token keyword">auto</span> randoms <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> seed<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> seq<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// pseudo-random</span>
  std<span class="token operator">::</span>mt19937 <span class="token function">engine</span><span class="token punctuation">(</span>seed<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>uniform_real_distribution<span class="token operator">&lt;</span><span class="token operator">&gt;</span> dist<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">co_yield</span> <span class="token function">dist</span><span class="token punctuation">(</span>engine<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> rolls <span class="token operator">=</span> <span class="token function">randoms</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 
  <span class="token operator">&gt;&gt;</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">ceil</span><span class="token punctuation">(</span>x <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token operator">&gt;&gt;</span> <span class="token function">scan</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">,</span> <span class="token keyword">auto</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token operator">&gt;&gt;</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>As you can see, many sequences are simple transformations of others, and Conduit allows us to represent this with a terse syntax.</p><h2>Compiler Optimization</h2><p><a href="https://en.wikipedia.org/wiki/Alan_Perlis">Alan Perlis</a> once joked that LISP programmers know the value of everything and the cost of nothing. And indeed a common criticism of lazy sequences is that they are far slower than transformations over vectors.</p><blockquote><h1>LISP programmers know the value of everything and the cost of nothing. — Alan Perlis</h1></blockquote><p>However, with Clang and the Coroutine TS, we’ve found that these abstractions usually compile away!</p><p>For example, consider this Fibonacci program:</p><pre class="language-cpp"><code class="language-cpp">
<span class="token keyword">auto</span> fibonacci <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> seq<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">0ll</span><span class="token punctuation">;</span> 
  <span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token number">1ll</span><span class="token punctuation">;</span>
  
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">co_yield</span> a<span class="token punctuation">;</span>
    
    <span class="token function">tie</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> tuple<span class="token punctuation">{</span>a <span class="token operator">+</span> b<span class="token punctuation">,</span> a<span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">long</span> N <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> n <span class="token operator">=</span> N<span class="token punctuation">;</span>
  <span class="token keyword">auto</span> items <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token operator">&gt;&gt;</span> <span class="token function">drop</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token operator">&gt;&gt;</span> <span class="token function">take</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">+=</span> x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Incredibly, Clang optimizes this to just:</p><pre><code>main: # @main
  mov eax, 511172301
  ret
</code></pre><p>Amazing stuff!</p><h2>Try Conduit</h2><p>Conduit is available as a <a href="https://github.com/LoopPerfect/conduit/releases">header-only library</a> on <a href="https://github.com/loopperfect/conduit">GitHub</a>. All you need is a C++ compiler with the Coroutine TS.</p><p>Want to contribute? We have an actively maintained list of issues over on the <a href="https://github.com/loopperfect/conduit/issues">tracker</a>. 💖</p><h2>Since You’re Here…</h2><p>We recently announced <a href="https://buildinfer.loopperfect.com/">BuildInfer</a>, a new tool to optimize your C/C++ build scripts. <a href="https://buildinfer.loopperfect.com/">Take a look</a>!</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*pkwieX1RSK5S0LXbFyaEJg.png"/></p></div></div></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/introducing-conduit-lazy-sequences-for-c","query":{},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/fe8ef1070ee43d1bcce443c3875737aef33fa79f.55d4b28eaf40fcb59af0.js" async=""></script><script src="/_next/static/chunks/pages/blog/introducing-conduit-lazy-sequences-for-c-6587de0d27ac00abebf5.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>