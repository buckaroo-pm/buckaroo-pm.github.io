{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport Layout from '/home/gaetano/projects/buckaroo-pm.github.io/layouts/index';\nexport var frontMatter = {\n  title: 'Generated Include Guards: An Alternative to pragma once',\n  banner: '/posts/generated-include-guards.jpeg',\n  author: 'Team Buckaroo',\n  created: '2017-10-18T11:00:00.000Z',\n  attribution: 'Photo by Toa Heftiba on Unsplash',\n  __resourcePath: 'blog/generated-include-guards.md',\n  __scans: {},\n  layout: 'index'\n};\nvar layoutProps = {\n  frontMatter: frontMatter\n};\nvar MDXLayout = Layout;\nexport default function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _objectSpread(_objectSpread(_objectSpread({}, layoutProps), props), {}, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Introduction\"), mdx(\"p\", null, \"In C++, nothing prevents the programmer from including a header-file multiple times. This can cause a duplication of definitions, which is an error. Since it is difficult to ensure that a header-file is only included once, a common strategy is to make only the first include count. This can be done using an \\u201Cinclude guard\\u201D, a small piece of preprocessor logic that looks like this:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"include\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token string\"\n  }), \"\\\"foo.hpp\\\"\")), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"include\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token string\"\n  }), \"\\\"foo.hpp\\\"\")), \"\\n\")), mdx(\"h3\", null, \"How Does it Work?\"), mdx(\"p\", null, \"On the first include, HEADER_HAS_BEEN_INCLUDED is not defined, so we define foo. On subsequent includes, HEADER_HAS_BEEN_INCLUDED has been defined, so we just skip the content.\"), mdx(\"p\", null, \"For example, if we have this C++ file:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"ifndef\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token expression\"\n  }), \"HEADER_HAS_BEEN_INCLUDED\")), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"define\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token macro-name\"\n  }), \"HEADER_HAS_BEEN_INCLUDED\")), \"\\n\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"struct\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token class-name\"\n  }), \"foo\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"{\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" member\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"}\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"endif\")), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"ifndef\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token expression\"\n  }), \"HEADER_HAS_BEEN_INCLUDED\")), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"define\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token macro-name\"\n  }), \"HEADER_HAS_BEEN_INCLUDED\")), \"\\n\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"struct\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token class-name\"\n  }), \"foo\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"{\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" member\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"}\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"endif\")), \"\\n\")), mdx(\"p\", null, \"Then it will expand to this:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"struct\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token class-name\"\n  }), \"foo\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"{\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" member\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"}\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\")), mdx(\"p\", null, \"And after the preprocessor has finished, we are left with this:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"pragma\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token expression\"\n  }), \"once\")), \"\\n\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"struct\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token class-name\"\n  }), \"foo\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"{\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" member\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"}\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\")), mdx(\"p\", null, \"This is the idiomatic approach, but it has some limitations:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Three lines of boiler-plate code are required\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The variable name on lines 1 and 2 must match \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"exactly\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The same variable name must not be used in multiple files\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"We have to remember the #endif, which is located at the other end of the file to the #ifndef\"))), mdx(\"h3\", null, \"What About pragma once?\"), mdx(\"p\", null, \"#pragma once was designed to overcome these issues. It is a non-standard, but widely supported, feature of C++ compilers. The concept is simple: any file containing #pragma once will only \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"actually\"), \" be included once, even if the programmer includes it multiple times.\"), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#pragma once\"), \", our examples becomes:\"), mdx(\"pre\", null, mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {}), \"for each header file:\\n  hash the file\\n  generate an include guard from the hash\\n  wrap the contents \\n  output into a new header file\\n\")), mdx(\"p\", null, \"Looks good, right? Sadly #pragma once brings a host of problems.\"), mdx(\"p\", null, \"The root cause is that #pragma once is concerned with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"where\"), \" some code lives, rather than its \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"content\"), \". If you have two copies of the same file accessible via multiple paths, then it will get included twice. And, if you have two paths that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"appear\"), \" different, but are actually the same, then the compiler may not spot this. To top things off, it is not standard, so compiler implementations do not have to respect its semantics.\"), mdx(\"h2\", null, \"A Possible Workaround\"), mdx(\"p\", null, \"The problems with #pragma once stem from the fact that it works off of a file\\u2019s location, rather than its content. What if we just used the content instead?\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"(Of course, recording all of the contents of each header would be slow, but we can optimize by recording a hash of the content instead).\")), mdx(\"p\", null, \"The process would be:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When a header-file is included, hash it\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If the hash has been seen before, then ignore the include\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Otherwise, include the header as normal\")), mdx(\"p\", null, \"This would be a robust solution because it is not at all concerned about the path a file is found at, only its content.\"), mdx(\"h2\", null, \"Implementing the Workaround\"), mdx(\"p\", null, \"Adding a new command to the C++ standard would take considerable time, but luckily we can implement this logic using scripting and preprocessor.\"), mdx(\"p\", null, \"The basic idea is this:\"), mdx(\"pre\", null, mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {}), \"for each header file:\\n  hash the file\\n  generate an include guard from the hash\\n  wrap the contents \\n  output into a new header file\\n\")), mdx(\"p\", null, \"So, for example this header:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"add\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" x\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" y\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\")), mdx(\"p\", null, \"Has a SHA-256 hash of:\"), mdx(\"pre\", null, mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {}), \"786be73f07f8bf5cc4c26dd0bb4f57e0777671adf256e6d5168a4f0c02f167b6\\n\")), mdx(\"p\", null, \"So the generated header might be:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"ifndef\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token expression\"\n  }), \"INCLUDED_786be73f07f8bf5cc4c26dd0bb4f57e0\")), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"define\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token macro-name\"\n  }), \"INCLUDED_786be73f07f8bf5cc4c26dd0bb4f57e0\")), \"\\n\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"add\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" x\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"int\"), \" y\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token macro property\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive-hash\"\n  }), \"#\"), mdx(\"span\", _objectSpread({\n    parentName: \"span\"\n  }, {\n    \"className\": \"token directive keyword\"\n  }), \"endif\")), \"\\n\")), mdx(\"p\", null, \"Whilst the transformation for individual files is simple (\", mdx(\"a\", _objectSpread({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/njlr/buck-include-guards/blob/84c3a67dcb5eb6d9924cacc4f2c33723beb6245a/scripts/add-include-guard.py\"\n  }), \"Python script\"), \"), we still need to manage the transformation process. We need to ensure that:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The transformation is run for every file\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"New files are automatically transformed\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The transformations of deleted files are automatically removed\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The transformation is only re-run when the file has changed\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Bonus: Transformations can be safely put into a shared network cache\")))), mdx(\"p\", null, \"Using \", mdx(\"a\", _objectSpread({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://buckbuild.com/\"\n  }), \"Buck build\"), \", we can encode this logic into a project\\u2019s build script easily.\"), mdx(\"p\", null, \"Let\\u2019s start with a build-rule for a single file and then generalize:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-python\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"genrule\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"\\n  name \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'guarded-add'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" \\n  out \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'add.hpp'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n  srcs \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"[\"), \"\\n    \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'scripts/add-include-guard.py'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n    \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'add.hpp'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"]\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n  cmd \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'python $SRCS > $OUT'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \"\\n\")), mdx(\"p\", null, \"A genrule in Buck is much like a target in Make. We define the input files, the output file name and the command to execute. This target takes our Python script for generating an include guard and runs it on add.hpp. Unlike Make, Buck will isolate and cache the process on its input hashes.\"), mdx(\"p\", null, \"Now we have a single file working, we can generalize the process to n files. To do this, we make a Python function that creates a genrule for a given file:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-python\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"def\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"add_include_guard\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"x\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \":\"), \"\\n  name \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" hashlib\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), \"sha256\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"x\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), \"hexdigest\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"[\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token number\"\n  }), \"0\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \":\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token number\"\n  }), \"16\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"]\"), \"\\n  genrule\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"\\n    name \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" name\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n    out \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" os\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), \"path\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), \"basename\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"x\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n    srcs \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"[\"), \"\\n      \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'scripts/add-include-guard.py'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" \\n      x\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n    \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"]\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n    cmd \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'python $SRCS > $OUT'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"return\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"':'\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"+\"), \" name\\n\")), mdx(\"p\", null, \"To get the set of header files, we run a glob expression. For example:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-python\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"mathutils_headers \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" subdir_glob\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"[\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'mathutils/include'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'**/*.hpp'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"]\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \"\\n\")), mdx(\"p\", null, \"And to bring it all together:\"), mdx(\"pre\", _objectSpread({}, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"cxx_library\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"\\n  name \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'mathutils'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n  header_namespace \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'mathutils'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n  exported_headers \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"dict\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"[\"), \"\\n    \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"x\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"add_include_guard\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"y\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"for\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"x\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" y\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \" in mathutils_headers\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"items\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"]\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n  srcs \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"glob\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"[\"), \"\\n    \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"'mathutils/src/**/*.cpp'\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n  \", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"]\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n\", mdx(\"span\", _objectSpread({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \"\\n\")), mdx(\"p\", null, \"You can find a complete \", mdx(\"a\", _objectSpread({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/njlr/buck-include-guards\"\n  }), \"working example on GitHub\"), \".\"), mdx(\"p\", null, \"Now, our header files can be written without include guards or #pragma once:\"), mdx(\"pre\", null, mdx(\"code\", _objectSpread({\n    parentName: \"pre\"\n  }, {}), \"int add(int x, int y);\\n\")), mdx(\"p\", null, \"This setup in Buck is really nice to work with:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Zero boiler-plate in the header files\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Buck will automatically check for new header files, so that builds are always up-to-date\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Buck will remove stale generated headers\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Because it understands the target graph, Buck will generate headers in parallel\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Buck will cache generated headers so that they are only computed when required\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"We are no longer relying on human accuracy (include guards) or non-standard features (#pragma once)\"))), mdx(\"h2\", null, \"Since You\\u2019re Here\\u2026\"), mdx(\"p\", null, \"We created \", mdx(\"a\", _objectSpread({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/LoopPerfect/buckaroo\"\n  }), \"Buckaroo\"), \" to make it easier to integrate C++ libraries. If you would like try it out, the best place to start is \", mdx(\"a\", _objectSpread({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://buckaroo.readthedocs.io/en/latest/\"\n  }), \"the documentation\"), \". You can browse the existing packages on \", mdx(\"a\", _objectSpread({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.buckaroo.pm/\"\n  }), \"Buckaroo.pm\"), \" or request more over on \", mdx(\"a\", _objectSpread({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/LoopPerfect/buckaroo-wishlist\"\n  }), \"the wishlist\"), \".\\n\", mdx(\"a\", _objectSpread({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7\"\n  }), mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Approaches to C++ Dependency Management, or Why We Built Buckaroo\"), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"C++ is an unusual language in that it does not yet have a dominant package manager (we\\u2019re working on it!). As a result\\u2026\"), \"hackernoon.com\")));\n}\n;\nMDXContent.isMDXComponent = true;","map":null,"metadata":{},"sourceType":"module"}