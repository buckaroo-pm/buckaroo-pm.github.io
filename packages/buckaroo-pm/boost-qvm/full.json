{
  "packageName": "buckaroo-pm/boost-qvm",
  "name": "boostorg/qvm",
  "licence": "",
  "description": "Boost Quaternions, Vectors, Matrices library",
  "readme": ":last-update-label!:\n:source-highlighter: coderay\n:icons: font\n:toclevels: 3\n:toc: left\n:toc-title: Boost QVM\n:sectnumlevels: 2\n\n= Boost QVM\nGeneric {CPP} library for working with Quaternions Vectors and Matrices\n:keywords: c++, boost, matrix, vector, quaternion\n\n[abstract]\n== Abstract\nBoost QVM is a generic library for working with Quaternions, Vectors and Matrices of static size with the emphasis on 2, 3 and 4-dimensional operations needed in graphics, video games and simulation applications.\n\nAll operations are implemented in terms of free function templates using https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error[SFINAE], compatible with any user-defined quaternion, vector or matrix type. Binary operations are able to work with disparate value types.\n\nThe library also provides <<view_proxy,view proxies>> that can be used to map one lvalue type to another with zero overhead, and without the creating temporary objects.\n\n== Distribution\n\nQVM is part of https://www.boost.org/[Boost] and is distributed under the http://www.boost.org/LICENSE_1_0.txt[Boost Software License, Version 1.0].\n\nThe source code is available in https://github.com/boostorg/qvm[BOOST QVM GitHub repository].\n\n(C) 2008-2018 Emil Dotchevski and Reverge Studios, Inc.\n\n== Feedback / support\n\nPlease use the link:https://lists.boost.org/mailman/listinfo.cgi/boost[Boost Developers mailing list].\n\n== Portability\n\nSee the link:https://travis-ci.org/boostorg/qvm[Boost QVM Travis CI Builds].\n\n== Tutorial\n\n=== Quaternions, Vectors, Matrices\n\nOut of the box Boost QVM defines generic yet simple <<quat,`quat`>>, <<vec,`vec`>> and <<mat,`mat`>> types. For example, the following snippet creates a quaternion object that rotates around the X axis:\n\n[source,c++]\n----\nquat<float> rx = rotx_quat(3.14159f);\n----\n\nSimilarly, a matrix that translates by a given vector can be created as follows:\n\n[source,c++]\n----\nvec<float,3> v = {0,0,7};\nmat<float,4,4> tr = translation_mat(v);\n----\n\nThe usual quaternion, vector and matrix operations work on these Boost QVM types, however the operations are decoupled from any specific type: they work on any suitable type that has been registered by specializing the <<quat_traits,`quat_traits`>>, <<vec_traits,`vec_traits`>> and <<mat_traits,`mat_traits`>> templates.\n\nFor example, a user-defined 3D vector type `float3` can be introduced to Boost QVM as follows:\n\n[source,c++]\n----\nstruct float3 { float a[3]; };\n\nnamespace boost { namespace qvm {\n\n    template <>\n    struct vec_traits<float3> {\n\n        static int const dim=3;\n        typedef float scalar_type;\n\n        template <int I>\n        static inline scalar_type & write_element( float3 & v ) {\n            return v.a[I];\n        }\n\n        template <int I>\n        static inline scalar_type read_element( float3 const & v ) {\n            return v.a[I];\n        }\n\n        static inline scalar_type & write_element_idx( int i, float3 & v ) {\n            return v.a[i];\n        } //optional\n\n        static inline scalar_type read_element_idx( int i, float3 const & v ) {\n            return v.a[i];\n        } //optional\n\n    };\n\n} }\n----\n\nEquivalently, using the <<vec_traits_defaults,`vec_traits_defaults`>> template the above can be shortened to:\n\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <>\n    struct vec_traits<float3>: vec_traits_defaults<float3,float,3> {\n\n        template <int I>\n        static inline scalar_type & write_element( float3 & v ) {\n            return v.a[I];\n        }\n\n        static inline scalar_type & write_element_idx( int i, float3 & v ) {\n            return v.a[i];\n        } //optional\n\n    };\n\n} }\n----\n\nAfter a similar specialization of the <<mat_traits,`mat_traits`>> template for a user-defined 3x3 matrix type `float33`, the full range of vector and matrix operations defined by Boost QVM headers becomes available automatically:\n\n[source,c++] \n----\nfloat3 v;\nX(v) = 0;\nY(v) = 0;\nZ(v) = 7;\nfloat vmag = mag(v);\nfloat33 m = rotx_mat<3>(3.14159f);\nfloat3 vrot = m * v;\n----\n\nUser-defined quaternion types are similarly introduced to Boost QVM by specializing the <<quat_traits,`quat_traits`>> template.\n\n'''\n\n=== C Arrays\n\nIn <<boost/qvm/quat_traits_array.hpp,`boost/qvm/quat_traits_array.hpp`>>, <<boost/qvm/vec_traits_array.hpp,`boost/qvm/vec_traits_array.hpp`>> and <<boost/qvm/mat_traits_array.hpp,`boost/qvm/mat_traits_array.hpp`>> Boost QVM defines appropriate <<quat_traits,`quat_traits`>>, <<vec_traits,`vec_traits`>> and <<mat_traits,`mat_traits`>> specializations that allow Boost QVM functions to operate directly on plain old C arrays:\n\n[source,c++] \n----\nfloat v[3] = {0,0,7};\nfloat3 vrot = rotx_mat<3>(3.14159f) * v;\n----\n\nNaturally, operator overloads cannot kick in if all elements of an expression are of built-in types. The following is still illegal:\n\n[source,c++] \n----\nfloat v[3] = {0,0,7};\nv *= 42;\n----\n\nThe <<vref,`vref`>> and <<mref,`mref`>> function templates can be used to work around this issue:\n\n[source,c++] \n----\nfloat v[3] = {0,0,7};\nvref(v) *= 42;\n----\n\n'''\n\n[[view_proxy]]\n=== View proxies\n\nBoost QVM defines various function templates that provide static mapping between (possibly user-defined) quaternion, vector and matrix types. The example below multiplies column 1 (Boost QVM indexes are always zero-based) of the matrix `m` by a scalar:\n\n[source,c++] \n----\nvoid multiply_column1( float33 & m, float scalar ) {\n    col<1>(m) *= scalar;\n}\n----\n\nThe expression <<col,`col<1>(m)`>> is an lvalue of an unspecified 3D vector type that refers to column 1 of `m`. Note however that this does not create any temporary objects; instead `operator*=` above works directly with a reference to `m`.\n\nHere is another example, multiplying a transposed view of a matrix by a vector of some user-defined type `float3`:\n\n[source,c++] \n----\nfloat3 v = {0,0,7};\nfloat3 vrot = transposed(rotx_mat<3>(3.14159f)) * v;\n----\n\nIn general, the various view proxy functions return references of unspecified, non-copyable types that refer to the original object. They can be assigned from or converted to any compatible vector or matrix type.\n\n'''\n\n=== Swizzling\n\nBoost QVM allows accessing vector elements by swizzling, exposing vector views of different dimensions, and/or views with reordered elements. The example below rotates `v` around the X axis, and stores the resulting vector back in `v` but with the X and Y elements swapped:\n\n[source,c++] \n----\nfloat3 v = {0,0,7};\nYXZ(v) = rotx_mat<3>(3.14159f) * v;\n----\n\nA special case of swizzling provides next-dimension-view of a vector object, adding either 0 or 1 as its last component. Assuming `float3` is a 3D vector type, and `float4` is a 4D vector type, the following statements are valid:\n\n[source,c++] \n----\nfloat3 v = {0,0,7};\nfloat4 point = XYZ1(v); //{0,0,7,1}\nfloat4 vector = XYZ0(v); //{0,0,7,0}\n----\n\nIt is also valid for swizzling to address vector elements more than once:\n\n[source,c++] \n----\nfloat3 v = {0,0,7};\nfloat4 v1 = ZZZZ(v); //{7,7,7,7}\n----\n\nBoost QVM defines all permutations of `X`, `Y`, `Z`, `W` for 1D, 2D, 3D and 4D swizzling, plus each dimension defines variants with 0 or 1 used at any position (if 0 or 1 appear at the first position, the swizzling function name begins with underscore, e.g. `_1XY`).\n\nThe swizzling syntax can also be used to bind scalars as vectors. For example:\n\n[source,c++]\n----\nfloat3 v = _00X(42.0f); //{0,0,42}\n----\n\n'''\n\n[[enable_if]]\n=== SFINAE/enable_if\n\nSFINAE stands for Substitution Failure Is Not An Error. This refers to a situation in {CPP} where an invalid substitution of template parameters (including when those parameters are deduced implicitly as a result of an unqualified call) is not in itself an error.\n\nIn absence of concepts support, SFINAE can be used to disable function template overloads that would otherwise present a signature that is too generic. More formally, this is supported by the Boost `enable_if` library.\n\nFor example, Boost QVM defines `operator*` overload which works with any user-defined matrix and vector types. The naive approach would be to declare this overload as follows:\n\n[source,c++] \n----\ntemplate <class Matrix,class Vector>\nVector operator*( Matrix const & m, Vector const & v );\n----\n\nEven if the function definition might contain code that would compile only for `Matrix` and `Vector` types, because the function declaration itself is valid, it will participate in overload rezolutions when multiplying objects of any two types whatsoever. This typically renders overload resolutions ambiguous and the compiler (correctly) issues an error.\n\nUsing `enable_if`, Boost QVM declares such overloads in a way that preserves their generic signature but only participate in overload resolutions if the passed parameters make sense depending on the semantics of the operation being defined:\n\n[source,c++] \n----\ntemplate <class A,class B>\ntypename enable_if_c<\n    is_mat<A>::value && is_vec<B>::value && mat_traits<A>::cols==vec_traits<B>::dim, //Condition\n    B>::type //Return type\noperator*( A const & a, B const & b );\n----\n\nFor brevity, function declarations throughout this documentation specify the condition which controls whether they are enabled or not without specifying exactly what `enable_if` construct is used to achieve this effect.\n\n'''\n\n=== Interoperability\n\nAn important design goal of Boost QVM is that it works seamlessly with 3rd-party quaternion, vector and matrix types and libraries. Even when such libraries overload the same {CPP} operators as Boost QVM, it is safe to bring the entire `boost::qvm` namespace in scope by specifying:\n\n[source,c++] \n----\nusing namespace boost::qvm;\n----\n\nThe above using directive does not introduce ambiguities with function and operator overloads defined by a 3rd-party library because:\n\n- Most `boost::qvm` function overloads and all operator overloads use SFINAE/`enable_if`, which makes them \"disappear\" unless an expression uses types that have the appropriate Boost QVM-specific type traits defined;\n\n- Whenever such overloads are compatible with a given expression, their signature is extremely generic, which means that any other (user-defined) compatible overload will be a better match in any overload resolution.\n\nNOTE: Bringing the entire boost::qvm namespace in scope may introduce ambiguities when accessing types (as opposed to functions) defined by 3rd-party libraries. In that case, you can safely bring namespace `boost::qvm::sfinae` in scope instead, which contains only function and operator overloads that use SFINAE/`enable_if`.\n\n==== Specifying return types for binary operations\n\nBringing the `boost::qvm` namespace in scope lets you mix vector and matrix types that come from different APIs into a common, type-safe framework. In this case however, it should be considered what types should be returned by binary operations that return an object by value. For example, if you multiply a 3x3 matrix `m1` of type `user_matrix1` by a 3x3 matrix `m2` of type `user_matrix2`, what type should that operation return?\n\nThe answer is that by default, Boost QVM returns some kind of compatible matrix type, so it is always safe to write:\n\n[source,c++] \n----\nauto & m = m1 * m2;\n----\n\nHowever, the type deduced by default converts implicitly to any compatible matrix type, so the following is also valid, at the cost of a temporary:\n\n[source,c++] \n----\nuser_matrix1 m = m1 * m2;\n----\n\nWhile the temporary object can be optimized away by many compilers, it can be avoided altogether by specializing the <<deduce_mat2,`deduce_mat2`>> template. For example, to specify that multiplying a `user_matrix1` by a `user_matrix2` should always produce a `user_matrix1` object, you could write:\n\n[source,c++] \n----\nnamespace boost { namespace qvm {\n\n    template <>\n    struct deduce_mat2<user_matrix1,user_matrix2,3,3> {\n        typedef user_matrix1 type;\n    };\n\n    template <>\n    struct deduce_mat2<user_matrix2,user_matrix1,3,3> {\n        typedef user_matrix1 type;\n    };\n\n} }\n----\n\n[WARNING]\n====\nBe mindful of potential ODR violation when using <<deduce_quat2,`deduce_quat2`>>, <<deduce_vec2,`deduce_vec2`>> and <<deduce_mat2,`deduce_mat2`>> in independent libraries. For example, this could happen if `lib1` defines `deduce_vec2<lib1::vec,lib2::vec>::type` as `lib1::vec` and in the same program `lib2` defines `deduce_vec2<lib1::vec,lib2::vec>::type` as `lib2::vec`.\n\nIt is best to keep such specializations out of `lib1` and `lib2`. Of course, it is always safe for `lib1` and `lib2` to use <<convert_to,`convert_to`>> to convert between the `lib1::vec` and `lib2::vec` types as needed.\n====\n\n==== Specifying return types for unary operations\n\nPerhaps surprisingly, unary operations that return an object by value have a similar, though simpler issue. That's because the argument they're called with may not be copyable, as in:\n\n[source,c++] \n----\nfloat m[3][3];\nauto & inv = inverse(m);\n----\n\nAbove, the object returned by <<mat_inverse,`inverse`>> and captured by `inv` can not be of type `float[3][3]`, because that type isn't copyable. By default, Boost QVM \"just works\", returning an object of suitable matrix type that is copyable. This deduction process can be controlled, by specializing the <<deduce_mat,`deduce_mat`>> template.\n\n==== Converting between different quaternion, vector and matrix types\n\nAny time you need to create a matrix of a particular {CPP} type from any other compatible matrix type, you can use the <<convert_to,`convert_to`>> function:\n\n[source,c++] \n----\nuser_matrix2 m=convert_to<user_matrix2>(m1 * m2);\n----\n\n'''\n\n=== Header files\n\nBoost QVM is split into multiple headers to allow different compilation units to `#include` only the components they need. Each function in this document specifies the exact header that must be `#included` in order to use it.\n\nThe tables below list commonly used components and the headers they're found in. Header names containing a number define functions that only work with objects of that dimension; e.g. `vec_operations2.hpp` contains only functions for working with 2D vectors.\n\nThe header `boost/qvm/all.hpp` is provided for convenience. It includes all other QVM headers.\n\n.Quaternion header files\n[cols=\"1,2l\"]\n|====\n| Quaternion traits |#include <boost/qvm/quat_traits.hpp>\n#include <boost/qvm/quat_traits_array.hpp>\n#include <boost/qvm/deduce_quat.hpp>\n| Quaternion element access |#include <boost/qvm/quat_access.hpp>\n| Quaternion operations |#include <boost/qvm/quat_operations.hpp>\n| <<quat,`quat`>> class template |#include <boost/qvm/quat.hpp>\n|====\n\n.Vector header files\n[cols=\"1,2l\"]\n|====\n| Vector traits |#include <boost/qvm/vec_traits.hpp>\n#include <boost/qvm/vec_traits_array.hpp>\n#include <boost/qvm/deduce_vec.hpp>\n| Vector element access |#include <boost/qvm/vec_access.hpp>\n| Vector <<swizzling,swizzling>> |#include <boost/qvm/swizzle.hpp>\n#include <boost/qvm/swizzle2.hpp>\n#include <boost/qvm/swizzle3.hpp>\n#include <boost/qvm/swizzle4.hpp> \n| Vector operations |#include <boost/qvm/vec_operations.hpp>\n#include <boost/qvm/vec_operations2.hpp>\n#include <boost/qvm/vec_operations3.hpp>\n#include <boost/qvm/vec_operations4.hpp> \n| Quaternion-vector operations |#include <boost/qvm/quat_vec_operations.hpp>\n| Vector-matrix operations |#include <boost/qvm/vec_mat_operations.hpp>\n| Vector-matrix <<view_proxy,view proxies>> |#include <boost/qvm/map_vec_mat.hpp>\n| <<vec,`vec`>> class template |#include <boost/qvm/vec.hpp>\n|====\n\n.Matrix header files\n[cols=\"1,2l\"]\n|====\n| Matrix traits |#include <boost/qvm/mat_traits.hpp>\n#include <boost/qvm/mat_traits_array.hpp>\n#include <boost/qvm/deduce_mat.hpp>\n| Matrix element access |#include <boost/qvm/mat_access.hpp>\n| Matrix operations |#include <boost/qvm/mat_operations.hpp>\n#include <boost/qvm/mat_operations2.hpp>\n#include <boost/qvm/mat_operations3.hpp>\n#include <boost/qvm/mat_operations4.hpp> \n| Matrix-matrix <<view_proxy,view proxies>> |#include <boost/qvm/map_mat_mat.hpp>\n| Matrix-vector <<view_proxy,view proxies>> |#include <boost/qvm/map_mat_vec.hpp>\n| <<mat,`mat`>> class template |#include <boost/qvm/mat.hpp>\n|====\n\n== Reference\n\n[[type_traits]]\n=== Type traits system\n\nBoost QVM is designed to work with user-defined quaternion, vector and matrix types, as well as user-defined scalar types. This section formally defines the way such types can be integrated.\n\n'''\n\n[[scalar_requirements]]\n==== Scalar requirements\n\nA valid scalar type `S` must have accessible destructor, default constructor, copy constructor and assignment operator, and must support the following operations:\n\n====\n[source,c++]\n----\nS operator*( S, S );\nS operator/( S, S );\nS operator+( S, S );\nS operator-( S, S );\n\nS & operator*=( S &, S );\nS & operator/=( S &, S );\nS & operator+=( S &, S );\nS & operator-=( S &, S );\n\nbool operator==( S, S );\nbool operator!=( S, S );\n----\n====\n\nIn addition, the expression `S(0)` should construct a scalar of value zero, and `S(1)` should construct a scalar of value one, or else the <<scalar_traits,`scalar_traits`>> template must be specialized appropriately.\n\n'''\n\n[[is_scalar]]\n==== `is_scalar`\n\n====\n.#include <boost/qvm/scalar_traits.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class T>\n    struct is_scalar {\n        static bool const value=false;\n    };\n\n    template <> struct is_scalar<char>           { static bool const value=true; };\n    template <> struct is_scalar<signed char>    { static bool const value=true; };\n    template <> struct is_scalar<unsigned char>  { static bool const value=true; };\n    template <> struct is_scalar<signed short>   { static bool const value=true; };\n    template <> struct is_scalar<unsigned short> { static bool const value=true; };\n    template <> struct is_scalar<signed int>     { static bool const value=true; };\n    template <> struct is_scalar<unsigned int>   { static bool const value=true; };\n    template <> struct is_scalar<signed long>    { static bool const value=true; };\n    template <> struct is_scalar<unsigned long>  { static bool const value=true; };\n    template <> struct is_scalar<float>          { static bool const value=true; };\n    template <> struct is_scalar<double>         { static bool const value=true; };\n    template <> struct is_scalar<long double>    { static bool const value=true; };\n\n} }\n----\n====\n\nThis template defines a compile-time boolean constant value which can be used to determine whether a type `T` is a valid scalar type. It must be specialized together with the <<scalar_traits,`scalar_traits`>> template in order to introduce a user-defined scalar type to Boost QVM. Such types must satisfy the <<scalar_requirements,scalar requirements>>.\n\n'''\n\n[[scalar_traits]]\n==== `scalar_traits`\n\n====\n.#include <boost/qvm/scalar_traits.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class Scalar>\n    struct scalar_traits {\n\n        BOOST_QVM_INLINE_CRITICAL\n        static Scalar value( int v ) {\n            return Scalar(v);\n        }\n\n    };\n\n} }\n----\n====\n\nThis template may be specialized for user-defined scalar types to define the appropriate conversion from `int`; this is primarily used whenever Boost QVM needs to deduce a zero or one value.\n\n'''\n\n[[deduce_scalar]]\n==== `deduce_scalar`\n\n====\n.#include <boost/qvm/deduce_scalar.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class A,class B>\n    struct deduce_scalar\n    {\n        typedef typename impl<A,B>::type type;\n    };\n\n} }\n----\n====\n\nRequirements: :: `A` and `B` satisfy the <<scalar_requirements,scalar requirements>>.\n\nReturns: ::\n\nIf `A` and `B` are the same type, `impl<A,B>::type` returns that type. Otherwise, `impl<A,B>::type` is well defined for the following types only: `signed`/`unsigned char`, `signed`/`unsigned short`, `signed`/`unsigned int`, `signed`/`unsigned long`, `float` and `double`. The deduction logic is as follows:\n\n- if either of `A` and `B` is `double`, the result is `double`;\n- else, if one of `A` or `B` is an integer type and the other is `float`, the result is `float`;\n- else, if one of `A` or `B` is a signed integer and the other type is unsigned integer, the signed type is changed to unsigned, and then the lesser of the two integers is promoted to the other.\n\nNOTE: This template is used by generic binary operations that return a scalar, to deduce the return type based on the (possibly different) scalars of their arguments.\n\n'''\n\n[[scalar]]\n==== `scalar`\n\n====\n.#include <boost/qvm/scalar_traits.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        template <class T>\n        struct scalar {\n            typedef /*exact definition unspecified*/ type;\n        };\n\n} }\n----\n====\n\nThe expression <<quat_traits,`quat_traits<T>::scalar_type`>> evaluates to the scalar type of the quaternion type `T` (if <<is_quat,`is_quat<T>::value`>> is `true`).\n\nThe expression <<vec_traits,`vec_traits<T>::scalar_type`>> evaluates to the scalar type of the vector type `T` (if <<is_vec,`is_vec<T>::value`>> is `true`).\n\nThe expression <<mat_traits,`mat_traits<T>::scalar_type`>> evaluates to the scalar type of the matrix type `T` (if <<is_mat,`is_mat<T>::value`>> is `true`).\n\nThe expression `scalar<T>::type` is similar, except that it automatically detects whether `T` is a vector or a matrix or a quaternion type.\n\n'''\n\n[[is_quat]]\n==== `is_quat`\n\n====\n.#include <boost/qvm/quat_traits.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class T>\n    struct is_quat {\n\n        static bool const value = false;\n\n    };\n\n} }\n----\n====\n\nThis type template defines a compile-time boolean constant value which can be used to determine whether a type `T` is a quaternion type. For quaternion types, the <<quat_traits,`quat_traits`>> template can be used to access their elements generically, or to obtain their `scalar type`.\n\n'''\n\n[[quat_traits]]\n==== `quat_traits`\n\n====\n.#include <boost/qvm/quat_traits.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class Q>\n    struct quat_traits {\n\n        /*main template members unspecified*/\n\n    };\n    \n    /*\n    User-defined (possibly partial) specializations:\n    \n    template <>\n    struct quat_traits<Q> {\n\n        typedef <<user-defined>> scalar_type;        \n    \n        template <int I>\n        static inline scalar_type read_element( Quaternion const & q );        \n\n        template <int I>\n        static inline scalar_type & write_element( Quaternion & q );        \n\n    };\n    */\n\n} }\n----\n====\n\nThe `quat_traits` template must be specialized for (user-defined) quaternion types in order to enable quaternion operations defined in Boost QVM headers for objects of those types.\n\nNOTE: QVM quaternion operations do not require that quaternion types are copyable.\n\nThe main `quat_traits` template members are not specified. Valid specializations are required to define the following members:\n\n- `scalar_type`: the expression `quat_traits<Quaternion>::scalar_type` must be a value type which satisfies the <<scalar_requirements,`scalar requirements`>>.\n\nIn addition, valid specializations of the `quat_traits` template must define at least one of the following access functions as static members, where `q` is an object of type `Quaternion`, and `I` is compile-time integer constant:\n\n- `read_element`: the expression `quat_traits<Quaternion>::read_element<I>(q)` returns either a copy of or a `const` reference to the `I`-th element of `q`.\n\n- `write_element`: the expression `quat_traits<Quaternion>::write_element<I>(q)` returns mutable reference to the `I`-th element of `q`.\n\nNOTE: For the quaternion `a + bi + cj + dk`, the elements are assumed to be in the following order: `a`, `b`, `c`, `d`; that is, `I`=`0`/`1`/`2`/`3` would access `a`/`b`/`c`/`d`.\n\nIt is illegal to call any of the above functions unless `is_quat<Quaternion>::value` is true. Even then, quaternion types are allowed to define only a subset of the access functions.\n\nBelow is an example of a user-defined quaternion type, and its corresponding specialization of the quat_traits template:\n\n[source,c++]\n----\n#include <boost/qvm/quat_traits.hpp>\n\nstruct fquat { float a[4]; };\n\nnamespace boost { namespace qvm {\n\n    template <>\n    struct quat_traits<fquat> {\n\n        typedef float scalar_type;\n\n        template <int I>\n        static inline scalar_type & write_element( fquat & q ) {\n            return q.a[I];\n        }\n\n        template <int I>\n        static inline scalar_type read_element( fquat const & q ) {\n            return q.a[I];\n        }\n\n    };\n\n} }\n----\n\nEquivalently, using the <<quat_traits_defaults,`quat_traits_defaults`>> template the above can be shortened to:\n\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <>\n    struct quat_traits<fquat>: quat_traits_defaults<fquat,float> {\n\n        template <int I>\n        static inline scalar_type & write_element( fquat & q ) {\n            return q.a[I];\n        }\n\n    };\n\n} }\n----\n\n'''\n\n[[quat_traits_defaults]]\n==== `quat_traits_defaults`\n\n====\n.#include <boost/qvm/quat_traits_defaults.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class QuatType,class ScalarType>\n    struct quat_traits_defaults {\n\n        typedef QuatType quat_type;\n\n        typedef ScalarType scalar_type;\n    \n        template <int I>\n        static BOOST_QVM_INLINE_CRITICAL\n        scalar_type read_element( quat_type const & x ) {\n            return quat_traits<quat_type>::template\n                write_element<I>(const_cast<quat_type &>(x));\n        }\n\n    };\n\n} }\n----\n====\n\nThe `quat_traits_defaults` template is designed to be used as a public base for user-defined specializations of the <<quat_traits,`quat_traits`>> template, to easily define the required members. If it is used, the only member that must be defined by the user in a `quat_traits` specialization is `write_element`; the `quat_traits_defaults` base will define `read_element`, as well as `scalar_type` automatically.\n\n'''\n\n[[deduce_quat]]\n==== `deduce_quat`\n\n====\n.#include <boost/qvm/deduce_quat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class Q>\n    struct deduce_quat {\n        typedef Q type;\n    };\n\n} }\n----\n====\n\nRequirements: ::\n\n- `<<is_quat,is_quat>><Q>::value` is `true`;\n- `<<is_quat,is_quat>><deduce_quat<Q>::type>::value` must be `true`;\n- `deduce_quat<Q>::type` must be copyable.\n\nThis template is used by Boost QVM whenever it needs to deduce a copyable quaternion type from a single user-supplied function parameter of quaternion type. Note that `Q` itself may be non-copyable.\n\nThe main template definition returns `Q`, which means that it is suitable only for copyable quaternion types. Boost QVM also defines (partial) specializations for the non-copyable quaternion types it produces. Users can define other (partial) specializations for their own types.\n\nA typical use of the `deduce_quat` template is for specifying the preferred quaternion type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.\n\n'''\n\n[[deduce_quat2]]\n==== `deduce_quat2`\n\n====\n.#include <boost/qvm/deduce_quat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class A,class B>\n    struct deduce_quat2 {\n        typedef /*unspecified*/ type;\n    };\n\n} }\n----\n====\n\nRequirements: ::\n\n- Both `<<scalar,scalar>><A>::type` and `scalar<B>::type` are well defined;\n- `<<is_quat,is_quat>><A>::value` || `is_quat<B>::value` is `true`;\n- `is_quat<deduce_quat2<A,B>::type>::value` must be `true`;\n- `deduce_quat2<A,B>::type` must be copyable.\n\nThis template is used by Boost QVM whenever it needs to deduce a quaternion type from the types of two user-supplied function parameters. The returned type must have accessible copy constructor (the `A` and `B` types themselves could be non-copyable, and either one of them may not be a quaternion type.)\n\nThe main template definition returns an unspecified quaternion type with <<quat_traits,`scalar_type`>> obtained by `<<deduce_scalar,deduce_scalar>><A,B>::type`, except if `A` and `B` are the same quaternion type `Q`, in which case `Q` is returned, which is only suitable for copyable types. Boost QVM also defines (partial) specializations for the non-copyable quaternion types it produces. Users can define other (partial) specializations for their own types.\n\nA typical use of the `deduce_quat2` template is for specifying the preferred quaternion type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.\n\n'''\n\n[[is_vec]]\n==== `is_vec`\n\n====\n.#include <boost/qvm/vec_traits.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class T>\n    struct is_vec {\n\n        static bool const value = false;\n\n    };\n\n } }\n----\n====\n\nThis type template defines a compile-time boolean constant value which can be used to determine whether a type `T` is a vector type. For vector types, the <<vec_traits,`vec_traits`>> template can be used to access their elements generically, or to obtain their dimension and `scalar type`.\n\n'''\n\n[[vec_traits]]\n==== `vec_traits`\n\n====\n.#include <boost/qvm/vec_traits.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class V>\n    struct vec_traits {\n\n        /*main template members unspecified*/\n\n    };\n    \n    /*\n    User-defined (possibly partial) specializations:\n    \n    template <>\n    struct vec_traits<V> {\n\n        static int const dim = <<user-defined>>;        \n\n        typedef <<user-defined>> scalar_type;        \n    \n        template <int I>\n        static inline scalar_type read_element( Vector const & v );\n\n        template <int I>\n        static inline scalar_type & write_element( Vector & v );\n    \n        static inline scalar_type read_element_idx( int i, Vector const & v );        \n        static inline scalar_type & write_element_idx( int i, Vector & v );        \n\n    };\n    */\n\n} }\n----\n====\n\nThe `vec_traits` template must be specialized for (user-defined) vector types in order to enable vector and matrix operations defined in Boost QVM headers for objects of those types.\n\nNOTE: QVM vector operations do not require that vector types are copyable.\n\nThe main `vec_traits` template members are not specified. Valid specializations are required to define the following members:\n\n- `dim`: the expression `vec_traits<Vector>::dim` must evaluate to a compile-time integer constant greater than 0 that specifies the vector size.\n\n- `scalar_type`: the expression `vec_traits<Vector>::scalar_type` must be a value type which satisfies the <<scalar_requirements,`scalar requirements`>>.\n\nIn addition, valid specializations of the `vec_traits` template may define the following access functions as static members, where `v` is an object of type `Vector`, `I` is a compile-time integer constant, and `i` is a variable of type `int`:\n\n- `read_element`: the expression `vec_traits<Vector>::read_element<I>(v)` returns either a copy of or a const reference to the `I`-th element of `v`.\n\n- `write_element`: the expression `vec_traits<Vector>::write_element<I>(v)` returns mutable reference to the `I`-th element of `v`.\n\n- `read_element_idx`: the expression `vec_traits<Vector>::read_element_idx(i,v)` returns either a copy of or a `const` reference to the `i`-th element of `v`.\n\n- `write_element_idx`: the expression `vec_traits<Vector>::write_element_idx(i,v)` returns mutable reference to the `i`-th element of `v`.\n\nIt is illegal to call any of the above functions unless `is_vec<Vector>::value` is true. Even then, vector types are allowed to define only a subset of the access functions. The general requirements are:\n\n- At least one of `read_element` or `write_element` must be defined;\n- If `read_element_idx` is defined, `read_element` must also be defined;\n- If `write_element_idx` is defined, `write_element` must also be defined.\n\nBelow is an example of a user-defined 3D vector type, and its corresponding specialization of the `vec_traits` template:\n\n[source,c++]\n----\n#include <boost/qvm/vec_traits.hpp>\n\nstruct float3 { float a[3]; };\n\nnamespace boost { namespace qvm {\n\n    template <>\n    struct vec_traits<float3> {\n\n        static int const dim=3;\n\n        typedef float scalar_type;\n\n        template <int I>\n        static inline scalar_type & write_element( float3 & v ) {\n            return v.a[I];\n        }\n\n        template <int I>\n        static inline scalar_type read_element( float3 const & v ) {\n            return v.a[I];\n        }\n\n        static inline scalar_type & write_element_idx( int i, float3 & v ) {\n            return v.a[i];\n        } //optional\n\n        static inline scalar_type read_element_idx( int i, float3 const & v ) {\n            return v.a[i];\n        } //optional\n\n    };\n\n} }\n----\n\nEquivalently, using the <<vec_traits_defaults,`vec_traits_defaults`>> template the above can be shortened to:\n\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <>\n    struct vec_traits<float3>: vec_traits_defaults<float3,float,3>\n    {\n\n        template <int I>\n        static inline scalar_type & write_element( float3 & v ) {\n            return v.a[I];\n        }\n\n        static inline scalar_type & write_element_idx( int i, float3 & v ) {\n            return v.a[i];\n        } //optional\n\n    };\n\n} }\n----\n\n'''\n\n[[vec_traits_defaults]]\n==== `vec_traits_defaults`\n\n====\n.#include <boost/qvm/vec_traits_defaults.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class VecType,class ScalarType,int Dim>\n    struct vec_traits_defaults {\n\n        typedef VecType vec_type;\n        typedef ScalarType scalar_type;\n        static int const dim=Dim;\n    \n        template <int I>\n        static BOOST_QVM_INLINE_CRITICAL\n        scalar_type write_element( vec_type const & x ) {\n            return vec_traits<vec_type>::template write_element<I>(const_cast<vec_type &>(x));\n        }\n    \n        static BOOST_QVM_INLINE_CRITICAL\n        scalar_type read_element_idx( int i, vec_type const & x ) {\n            return vec_traits<vec_type>::write_element_idx(i,const_cast<vec_type &>(x));\n        }\n    \n        protected:\n    \n        static BOOST_QVM_INLINE_TRIVIAL\n        scalar_type & write_element_idx( int i, vec_type & m ) {\n            /* unspecified */\n        }\n    };\n\n} }\n----\n====\n\nThe `vec_traits_defaults` template is designed to be used as a public base for user-defined specializations of the <<vec_traits,`vec_traits`>> template, to easily define the required members. If it is used, the only member that must be defined by the user in a `vec_traits` specialization is `write_element`; the `vec_traits_defaults` base will define `read_element`, as well as `scalar_type` and `dim` automatically.\n\nOptionally, the user may also define `write_element_idx`, in which case the `vec_traits_defaults` base will provide a suitable `read_element_idx` definition automatically. If not, `vec_traits_defaults` defines a protected implementation of `write_element_idx` which may be made publicly available by the deriving `vec_traits` specialization in case the vector type for which it is being specialized can not be indexed efficiently. This `write_element_idx` function is less efficient (using meta-programming), implemented in terms of the required user-defined `write_element`.\n\n'''\n\n[[deduce_vec]]\n==== `deduce_vec`\n\n====\n.#include <boost/qvm/deduce_vec.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class V, int Dim=vec_traits<Vector>::dim>\n    struct deduce_vec {\n\n        typedef /*unspecified*/ type;\n\n    };\n\n} }\n----\n====\n\nRequirements: ::\n\n- `<<is_vec,is_vec>><V>::value` is `true`;\n- `is_vec<deduce_vec<V>::type>::value` must be `true`;\n- `deduce_vec<V>::type` must be copyable;\n- `vec_traits<deduce_vec<V>::type>::dim==Dim`.\n\nThis template is used by Boost QVM whenever it needs to deduce a copyable vector type of certain dimension from a single user-supplied function parameter of vector type. The returned type must have accessible copy constructor. Note that `V` may be non-copyable.\n\nThe main template definition returns an unspecified copyable vector type of size `Dim`, except if `<<vec_traits,vec_traits>><V>::dim==Dim`, in which case it returns `V`, which is suitable only if `V` is a copyable type. Boost QVM also defines (partial) specializations for the non-copyable vector types it produces. Users can define other (partial) specializations for their own types.\n\nA typical use of the `deduce_vec` template is for specifying the preferred vector type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.\n\n'''\n\n[[deduce_vec2]]\n==== `deduce_vec2`\n\n====\n.#include <boost/qvm/deduce_vec.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class A,class B,int Dim>\n    struct deduce_vec2 {\n        typedef /*unspecified*/ type;\n    };\n\n} }\n----\n====\n\nRequirements: ::\n\n- Both `<<scalar,scalar>><A>::type` and `scalar<B>::type` are well defined;\n- `<<is_vec,is_vec>><A>::value || is_vec<B>::value` is `true`;\n- `is_vec<deduce_vec2<A,B>::type>::value` must be `true`;\n- `deduce_vec2<A,B>::type` must be copyable;\n- `vec_traits<deduce_vec2<A,B>::type>::dim==Dim`.\n\nThis template is used by Boost QVM whenever it needs to deduce a vector type of certain dimension from the types of two user-supplied function parameters. The returned type must have accessible copy constructor (the `A` and `B` types themselves could be non-copyable, and either one of them may not be a vector type.)\n\nThe main template definition returns an unspecified vector type of the requested dimension with <<vec_traits,`scalar_type`>> obtained by `<<deduce_scalar,deduce_scalar>><A,B>::type`, except if `A` and `B` are the same vector type `V` of dimension `Dim`, in which case `V` is returned, which is only suitable for copyable types. Boost QVM also defines (partial) specializations for the non-copyable vector types it produces. Users can define other (partial) specializations for their own types.\n\nA typical use of the `deduce_vec2` template is for specifying the preferred vector type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.\n\n'''\n\n[[is_mat]]\n==== `is_mat`\n\n====\n.#include <boost/qvm/mat_traits.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class T>\n    struct is_mat {\n\n        static bool const value = false;\n\n    };\n\n} }\n----\n====\n\nThis type template defines a compile-time boolean constant value which can be used to determine whether a type `T` is a matrix type. For matrix types, the <<mat_traits,`mat_traits`>> template can be used to access their elements generically, or to obtain their dimensions and scalar type.\n\n'''\n\n[[mat_traits]]\n==== `mat_traits`\n\n====\n.#include <boost/qvm/mat_traits.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class M>\n    struct mat_traits {\n\n        /*main template members unspecified*/\n\n    };\n\n    /*\n    User-defined (possibly partial) specializations:\n    \n    template <>\n    struct mat_traits<M> {\n\n        static int const rows = <<user-defined>>;        \n        static int const cols = <<user-defined>>;        \n        typedef <<user-defined>> scalar_type;        \n    \n        template <int R,int C>\n        static inline scalar_type read_element( Matrix const & m );\n\n        template <int R,int C>\n        static inline scalar_type & write_element( Matrix & m );\n    \n        static inline scalar_typeread_element_idx( int r, int c, Matrix const & m );\n        static inline scalar_type & write_element_idx( int r, int c, Matrix & m );\n\n    };\n    */\n\n} }\n----\n====\n\nThe `mat_traits` template must be specialized for (user-defined) matrix types in order to enable vector and matrix operations defined in Boost QVM headers for objects of those types.\n\nNOTE: The matrix operations defined by Boost QVM do not require matrix types to be copyable.\n\nThe main `mat_traits` template members are not specified. Valid specializations are required to define the following members:\n\n- `rows`: the expression `mat_traits<Matrix>::rows` must evaluate to a compile-time integer constant greater than 0 that specifies the number of rows in a matrix.\n- `cols` must evaluate to a compile-time integer constant greater than 0 that specifies the number of columns in a matrix.\n- `scalar_type`: the expression `mat_traits<Matrix>::scalar_type` must be a value type which satisfies the scalar requirements.\n\nIn addition, valid specializations of the `mat_traits` template may define the following access functions as static members, where `m` is an object of type `Matrix`, `R` and `C` are compile-time integer constants, and `r` and `c` are variables of type `int`:\n\n- `read_element`: the expression `mat_traits<Matrix>::read_element<R,C>(m)` returns either a copy of or a const reference to the element at row `R` and column `C` of `m`.\n- `write_element`: the expression `mat_traits<Matrix>::write_element<R,C>(m)` returns mutable reference to the element at row `R` and column `C` of `m`.\n- `read_element_idx`: the expression `mat_traits<Matrix>::read_element_idx(r,c,m)` returns either a copy of or a const reference to the element at row `r` and column `c` of `m`.\n- `write_element_idx`: the expression `mat_traits<Matrix>::write_element_idx(r,c,m)` returns mutable reference to the element at row `r` and column `c` of `m`.\n\nIt is illegal to call any of the above functions unless `is_mat<Matrix>::value` is true. Even then, matrix types are allowed to define only a subset of the access functions. The general requirements are:\n\n- At least one of `read_element` or `write_element` must be defined;\n- If `read_element_idx` is defined, `read_element` must also be defined;\n- If `write_element_idx` is defined, `write_element` must also be defined.\n\nBelow is an example of a user-defined 3x3 matrix type, and its corresponding specialization of the `mat_traits` template:\n\n[source,c++]\n----\n#include <boost/qvm/mat_traits.hpp>\n\nstruct float33 { float a[3][3]; };\n\nnamespace boost { namespace qvm {\n\n    template <>\n    struct mat_traits<float33> {\n\n        static int const rows=3;\n        static int const cols=3;\n        typedef float scalar_type;\n\n        template <int R,int C>\n        static inline scalar_type & write_element( float33 & m ) {\n            return m.a[R][C];\n        }\n\n        template <int R,int C>\n        static inline scalar_type read_element( float33 const & m ) {\n            return m.a[R][C];\n        }\n\n        static inline scalar_type & write_element_idx( int r, int c, float33 & m ) {\n            return m.a[r][c];\n        }\n\n        static inline scalar_type read_element_idx( int r, int c, float33 const & m ) {\n            return m.a[r][c];\n        }\n \n    };\n\n} }\n----\n\nEquivalently, we could use the <<mat_traits_defaults,`mat_traits_defaults` template to shorten the above to:\n\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <>\n    struct mat_traits<float33>: mat_traits_defaults<float33,float,3,3> {\n\n        template <int R,int C> static inline scalar_type & write_element( float33 & m ) { return m.a[R][C]; }\n\n        static inline scalar_type & write_element_idx( int r, int c, float33 & m ) {\n            return m.a[r][c];\n        }\n\n    };\n\n} }\n----\n\n'''\n\n[[mat_traits_defaults]]\n==== `mat_traits_defaults`\n\n====\n.#include <boost/qvm/mat_traits_defaults.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class MatType,class ScalarType,int Rows,int Cols>\n    struct mat_traits_defaults\n    {\n        typedef MatType mat_type;\n        typedef ScalarType scalar_type;\n        static int const rows=Rows;\n        static int const cols=Cols;\n    \n        template <int Row,int Col>\n        static BOOST_QVM_INLINE_CRITICAL\n        scalar_type write_element( mat_type const & x ) {\n            return mat_traits<mat_type>::template write_element<Row,Col>(const_cast<mat_type &>(x));\n        }\n    \n        static BOOST_QVM_INLINE_CRITICAL\n        scalar_type read_element_idx( int r, int c, mat_type const & x ) {\n            return mat_traits<mat_type>::write_element_idx(r,c,const_cast<mat_type &>(x));\n        }\n    \n        protected:\n    \n        static BOOST_QVM_INLINE_TRIVIAL\n        scalar_type & write_element_idx( int r, int c, mat_type & m ) {\n            /* unspecified */\n        }\n    };\n\n} }\n----\n====\n\nThe `mat_traits_defaults` template is designed to be used as a public base for user-defined specializations of the <<mat_traits,`mat_traits`>> template, to easily define the required members. If it is used, the only member that must be defined by the user in a `mat_traits` specialization is `write_element`; the `mat_traits_defaults` base will define `read_element`, as well as `scalar_type`, `rows` and `cols` automatically.\n\nOptionally, the user may also define `write_element_idx`, in which case the `mat_traits_defaults` base will provide a suitable `read_element_idx` definition automatically. Otherwise, `mat_traits_defaults` defines a protected implementation of `write_element_idx` which may be made publicly available by the deriving `mat_traits` specialization in case the matrix type for which it is being specialized can not be indexed efficiently. This `write_element_idx` function is less efficient (using meta-programming), implemented in terms of the required user-defined `write_element`.\n\n'''\n\n[[deduce_mat]]\n==== `deduce_mat`\n\n====\n.#include <boost/qvm/deduce_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <\n        class M,\n        int Rows=mat_traits<Matrix>::rows,\n        int Cols=mat_traits<Matrix>::cols>\n    struct deduce_mat {\n\n        typedef /*unspecified*/ type;\n\n    };\n\n} }\n----\n====\n\nRequirements: ::\n\n- `<<is_mat,is_mat>><M>::value` is `true`;\n- `is_mat<deduce_mat<M>::type>::value` must be `true`;\n- `deduce_mat<M>::type` must be copyable;\n- `<<mat_traits,mat_traits>><deduce_mat<M>::type>::rows==Rows`;\n- `mat_traits<deduce_mat<M>::type>::cols==Cols`.\n\nThis template is used by Boost QVM whenever it needs to deduce a copyable matrix type of certain dimensions from a single user-supplied function parameter of matrix type. The returned type must have accessible copy constructor. Note that M itself may be non-copyable.\n\nThe main template definition returns an unspecified copyable matrix type of size `Rows` x `Cols`, except if `<<mat_traits,mat_traits>><M>::rows==Rows && mat_traits<M>::cols==Cols`, in which case it returns `M`, which is suitable only if `M` is a copyable type. Boost QVM also defines (partial) specializations for the non-copyable matrix types it produces. Users can define other (partial) specializations for their own types.\n\nA typical use of the deduce_mat template is for specifying the preferred matrix type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.\n\n'''\n\n[[deduce_mat2]]\n==== `deduce_mat2`\n\n====\n.#include <boost/qvm/deduce_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class A,class B,int Rows,int Cols>\n    struct deduce_mat2 {\n\n        typedef /*unspecified*/ type;\n\n    };\n\n} }\n----\n====\n\nRequirements: ::\n\n- Both `<<scalar,scalar>><A>::type` and `scalar<B>::type` are well defined;\n- `<<is_mat,is_mat>><A>::value || is_mat<B>::value` is `true`;\n- `is_mat<deduce_mat2<A,B>::type>::value` must be `true`;\n- `deduce_mat2<A,B>::type` must be copyable;\n- `<<mat_traits,mat_traits>><deduce_mat2<A,B>::type>::rows==Rows`;\n- `mat_traits<deduce_mat2<A,B>::type>::cols==Cols`.\n\nThis template is used by Boost QVM whenever it needs to deduce a matrix type of certain dimensions from the types of two user-supplied function parameters. The returned type must have accessible copy constructor (the `A` and `B` types themselves could be non-copyable, and either one of them may be a non-matrix type.)\n\nThe main template definition returns an unspecified matrix type of the requested dimensions with <<mat_traits,`scalar_type`>> obtained by `<<deduce_scalar,deduce_scalar>><A,B>::type`, except if `A` and `B` are the same matrix type `M` of dimensions `Rows` x `Cols`, in which case `M` is returned, which is only suitable for copyable types. Boost QVM also defines (partial) specializations for the non-copyable matrix types it produces. Users can define other (partial) specializations for their own types.\n\nA typical use of the `deduce_mat2` template is for specifying the preferred matrix type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.\n\n'''\n\n=== Built-in quaternion, vector and matrix types\n\nBoost QVM defines several class templates (together with appropriate specializations of <<quat_traits,`quat_traits`>>, <<vec_traits,`vec_traits`>> and <<mat_traits,`mat_traits`>> templates) which can be used as generic quaternion, vector and matrix types. Using these types directly wouldn't be typical though, the main design goal of Boost QVM is to allow users to plug in their own quaternion, vector and matrix types.\n\n[[quat]]\n==== `quat`\n\n====\n.#include <boost/qvm/quat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        template <class T>\n        struct quat {\n\n            T a[4];\n        \n            template <class R>\n            operator R() const {\n                R r;\n                assign(r,*this);\n                return r;\n            }\n\n        };\n        \n        template <class Quaternion>\n        struct quat_traits;\n        \n        template <class T>\n        struct quat_traits< quat<T> > {\n\n            typedef T scalar_type;\n        \n            template <int I>\n            static scalar_type read_element( quat<T> const & x ) {\n                return x.a[I];\n            }\n\n            template <int I>\n            static scalar_type & write_element( quat<T> & x ) {\n                return x.a[I];\n            }\n\n        };\n\n} }\n----\n====\n\nThis is a simple quaternion type. It converts to any other quaternion type.\n\nThe partial specialization of the <<quat_traits,`quat_traits`>> template makes the `quat` template compatible with the generic operations defined by Boost QVM.\n\n'''\n\n[[vec]]\n==== `vec`\n\n====\n.#include <boost/qvm/vec.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        template <class T,int Dim>\n        struct vec {\n\n            T a[Dim];\n        \n            template <class R>\n            operator R() const {\n                R r;\n                assign(r,*this);\n                return r;\n            }\n\n        };\n        \n        template <class Vector>\n        struct vec_traits;\n        \n        template <class T,int Dim>\n        struct vec_traits< vec<T,Dim> > {\n\n            typedef T scalar_type;\n            static int const dim=Dim;\n        \n            template <int I>\n            static scalar_type read_element( vec<T,Dim> const & x ) {\n                return x.a[I];\n            }\n            template <int I>\n            static scalar_type & write_element( vec<T,Dim> & x ) {\n                return x.a[I];\n            }\n        \n            static scalar_type read_element_idx( int i, vec<T,Dim> const & x ) {\n                return x.a[i];\n            }\n\n            static scalar_type & write_element_idx( int i, vec<T,Dim> & x ) {\n                return x.a[i];\n            }\n        };\n\n} }\n----\n====\n\nThis is a simple vector type. It converts to any other vector type of compatible size.\n\nThe partial specialization of the <<vec_traits,`vec_traits`>> template makes the `vec` template compatible with the generic operations defined by Boost QVM.\n\n'''\n\n[[mat]]\n==== `mat`\n\n====\n.#include <boost/qvm/mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class T,int Rows,int Cols>\n    struct mat {\n\n        T a[Rows][Cols];\n    \n        template <class R>\n        operator R() const {\n            R r;\n            assign(r,*this);\n            return r;\n        }\n\n    };\n    \n    template <class Matrix>\n    struct mat_traits;\n    \n    template <class T,int Rows,int Cols>\n    struct mat_traits< mat<T,Rows,Cols> > {\n\n        typedef T scalar_type;\n        static int const rows=Rows;\n        static int const cols=Cols;\n    \n        template <int Row,int Col>\n        static scalar_type read_element( mat<T,Rows,Cols> const & x ) {\n            return x.a[Row][Col];\n        }\n\n        template <int Row,int Col>\n        static scalar_type & write_element( mat<T,Rows,Cols> & x ) {\n            return x.a[Row][Col];\n        }\n    \n        static scalar_type read_element_idx( int row, int col, mat<T,Rows,Cols> const & x ) {\n            return x.a[row][col];\n        }\n\n        static scalar_type & write_element_idx( int row, int col, mat<T,Rows,Cols> & x ) {\n            return x.a[row][col];\n        }\n\n    };\n\n} }\n----\n====\n\nThis is a simple matrix type. It converts to any other matrix type of compatible size.\n\nThe partial specialization of the <<mat_traits,`mat_traits`>> template makes the `mat` template compatible with the generic operations defined by Boost QVM.\n\n'''\n\n=== Generic element access\n\n[[quat_access]]\n==== Quaternions\n\n====\n.#include <boost/qvm/quat_access.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<Q>::value\n    \n    template <class Q> -unspecified-return-type- S( Q & q );\n    template <class Q> -unspecified-return-type- V( Q & q );\n    template <class Q> -unspecified-return-type- X( Q & q );\n    template <class Q> -unspecified-return-type- Y( Q & q );\n    template <class Q> -unspecified-return-type- Z( Q & q );\n\n} }\n----\n====\n\nAn expression of the form `S(q)` can be used to access the scalar component of the quaternion `q`. For example,\n\n[source,c++]\n----\nS(q) *= 42;\n----\n\nmultiplies the scalar component of `q` by the scalar 42.\n\nAn expression of the form `V(q)` can be used to access the vector component of the quaternion `q`. For example,\n\n[source,c++]\n----\nV(q) *= 42\n----\n\nmultiplies the vector component of `q` by the scalar 42.\n\nThe `X`, `Y` and `Z` elements of the vector component can also be accessed directly using `X(q)`, `Y(q)` and `Z(q)`.\n\nTIP: The return types are lvalues.\n\n[[vec_access]]\n==== Vectors\n\n====\n.#include <boost/qvm/vec_access.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_vec<V>::value\n    \n    template <int I,class V> -unspecified-return-type- A( V & v );\n    template <class V> -unspecified-return-type- A0( V & v );\n    template <class V> -unspecified-return-type- A1( V & v );\n    ...\n    template <class V> -unspecified-return-type- A9( V & v );\n    \n    template <class V> -unspecified-return-type- X( V & v );\n    template <class V> -unspecified-return-type- Y( V & v );\n    template <class V> -unspecified-return-type- Z( V & v );\n    template <class V> -unspecified-return-type- W( V & v );\n\n} }\n----\n====\n\nAn expression of the form of `A<I>(v)` can be used to access the `I`-th element a vector object `v`. For example, the expression:\n\n[source,c++]\n----\nA<1>(v) *= 42;\n----\n\ncan be used to multiply the element at index 1 (indexing in Boost QVM is always zero-based) of a vector `v` by 42.\n\nFor convenience, there are also non-template overloads for `I` from 0 to 9; an alternative way to write the above expression is:\n\n[source,c++]\n----\nA1(v) *= 42;\n----\n\n`X`, `Y`, `Z` and `W` act the same as `A0`/`A1`/`A2`/`A3`; yet another alternative way to write the above expression is:\n\n[source,c++]\n----\nY(v) *= 42;\n----\n\nTIP: The return types are lvalues.\n\n[[swizzling]]\n==== Vector element swizzling\n\n====\n.#include <boost/qvm/swizzle.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //*** Accessing vector elements by swizzling ***\n    \n    //2D view proxies, only enabled if:\n    //  is_vec<V>::value\n    template <class V> -unspecified-2D-vector-type- XX( V & v );\n    template <class V> -unspecified-2D-vector-type- XY( V & v );\n    template <class V> -unspecified-2D-vector-type- XZ( V & v );\n    template <class V> -unspecified-2D-vector-type- XW( V & v );\n    template <class V> -unspecified-2D-vector-type- X0( V & v );\n    template <class V> -unspecified-2D-vector-type- X1( V & v );\n    template <class V> -unspecified-2D-vector-type- YX( V & v );\n    template <class V> -unspecified-2D-vector-type- YY( V & v );\n    template <class V> -unspecified-2D-vector-type- YZ( V & v );\n    template <class V> -unspecified-2D-vector-type- YW( V & v );\n    template <class V> -unspecified-2D-vector-type- Y0( V & v );\n    template <class V> -unspecified-2D-vector-type- Y1( V & v );\n    template <class V> -unspecified-2D-vector-type- ZX( V & v );\n    template <class V> -unspecified-2D-vector-type- ZY( V & v );\n    template <class V> -unspecified-2D-vector-type- ZZ( V & v );\n    template <class V> -unspecified-2D-vector-type- ZW( V & v );\n    template <class V> -unspecified-2D-vector-type- Z0( V & v );\n    template <class V> -unspecified-2D-vector-type- Z1( V & v );\n    template <class V> -unspecified-2D-vector-type- WX( V & v );\n    template <class V> -unspecified-2D-vector-type- WY( V & v );\n    template <class V> -unspecified-2D-vector-type- WZ( V & v );\n    template <class V> -unspecified-2D-vector-type- WW( V & v );\n    template <class V> -unspecified-2D-vector-type- W0( V & v );\n    template <class V> -unspecified-2D-vector-type- W1( V & v );\n    ...\n    //2D view proxies, only enabled if:\n    //  is_scalar<S>::value\n    template <class S> -unspecified-2D-vector-type- X0( S & s );\n    template <class S> -unspecified-2D-vector-type- X1( S & s );\n    template <class S> -unspecified-2D-vector-type- XX( S & s );\n    ...\n    -unspecified-2D-vector-type- _00();\n    -unspecified-2D-vector-type- _01();\n    -unspecified-2D-vector-type- _10();\n    -unspecified-2D-vector-type- _11();\n    \n    //3D view proxies, only enabled if:\n    //  is_vec<V>::value\n    template <class V> -unspecified-3D-vector-type- XXX( V & v );\n    ...\n    template <class V> -unspecified-3D-vector-type- XXW( V & v );\n    template <class V> -unspecified-3D-vector-type- XX0( V & v );\n    template <class V> -unspecified-3D-vector-type- XX1( V & v );\n    template <class V> -unspecified-3D-vector-type- XYX( V & v );\n    ...\n    template <class V> -unspecified-3D-vector-type- XY1( V & v );\n    ...\n    template <class V> -unspecified-3D-vector-type- WW1( V & v );\n    ...\n    //3D view proxies, only enabled if:\n    //  is_scalar<S>::value\n    template <class S> -unspecified-3D-vector-type- X00( S & s );\n    template <class S> -unspecified-3D-vector-type- X01( S & s );\n    ...\n    template <class S> -unspecified-3D-vector-type- XXX( S & s );\n    template <class S> -unspecified-3D-vector-type- XX0( S & s );\n    ...\n    -unspecified-3D-vector-type- _000();\n    -unspecified-3D-vector-type- _001();\n    -unspecified-3D-vector-type- _010();\n    ...\n    -unspecified-3D-vector-type- _111();\n    \n    //4D view proxies, only enabled if:\n    //  is_vec<V>::value\n    template <class V> -unspecified-4D-vector-type- XXXX( V & v );\n    ...\n    template <class V> -unspecified-4D-vector-type- XXXW( V & v );\n    template <class V> -unspecified-4D-vector-type- XXX0( V & v );\n    template <class V> -unspecified-4D-vector-type- XXX1( V & v );\n    template <class V> -unspecified-4D-vector-type- XXYX( V & v );\n    ...\n    template <class V> -unspecified-4D-vector-type- XXY1( V & v );\n    ...\n    template <class V> -unspecified-4D-vector-type- WWW1( V & v );\n    ...\n    //4D view proxies, only enabled if:\n    //  is_scalar<S>::value\n    template <class S> -unspecified-4D-vector-type- X000( S & s );\n    template <class S> -unspecified-4D-vector-type- X001( S & s );\n    ...\n    template <class S> -unspecified-4D-vector-type- XXXX( S & s );\n    template <class S> -unspecified-4D-vector-type- XX00( S & s );\n    ...\n    -unspecified-4D-vector-type- _0000();\n    -unspecified-4D-vector-type- _0001();\n    -unspecified-4D-vector-type- _0010();\n    ...\n    -unspecified-4D-vector-type- _1111();         \n\n} }\n----\n====\n\nSwizzling allows zero-overhead direct access to a (possibly rearranged) subset of the elements of 2D, 3D and 4D vectors. For example, if `v` is a 4D vector, the expression `YX(v) is a 2D view proxy whose `X` element refers to the `Y` element of `v`, and whose `Y` element refers to the `X` element of `v`. Like other view proxies `YX` is an lvalue, that is, if `v2` is a 2D vector, one could write:\n\n[source,c++]\n----\nYX(v) = v2;\n----\n\nThe above will leave the `Z` and `W` elements of `v` unchanged but assign the `Y` element of `v2` to the `X` element of `v` and the `X` element of `v2` to the `Y` element of `v`.\n\nAll permutations of `X`, `Y`, `Z`, `W`, `0`, `1` for 2D, 3D and 4D swizzling are available (if the first character of the swizzle identifier is `0` or `1`, it is preceded by a `_`, for example `_11XY`).\n\nIt is valid to use the same vector element more than once: the expression `ZZZ(v)` is a 3D vector whose `X`, `Y` and `Z` elements all refer to the `Z` element of `v`.\n\nFinally, scalars can be \"swizzled\" to access them as vectors: the expression `_0X01(42.0f)` is a 4D vector with `X`=0, `Y`=42.0, `Z`=0, `W`=1.\n\n[[mat_access]]\n==== Matrices\n\n====\n.#include <boost/qvm/mat_access.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<Q>::value\n    \n    template <int R,int C,class M> -unspecified-return-type- A( M & m );\n    \n    template <class M> -unspecified-return-type- A00( M & m );\n    template <class M> -unspecified-return-type- A01( M & m );\n    ...\n    template <class M> -unspecified-return-type- A09( M & m );\n    template <class M> -unspecified-return-type- A10( M & m );\n    ...\n    template <class M> -unspecified-return-type- A99( M & m );\n\n} }\n----\n\n====\n\nAn expression of the form `A<R,C>(m)` can be used to access the element at row `R` and column `C` of a matrix object `m`. For example, the expression:\n\n[source,c++]\n----\nA<4,2>(m) *= 42;\n----\n\ncan be used to multiply the element at row 4 and column 2 of a matrix `m` by 42.\n\nFor convenience, there are also non-template overloads for `R` from `0` to `9` and `C` from `0` to `9`; an alternative way to write the above expression is:\n\n[source,c++]\n----\nA42(m) *= 42;\n----\n\nTIP: The return types are lvalues.\n\n'''\n\n=== Generic quaternion operations\n\n[[quat_assign]]\n==== `assign`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B>\n    A & assign( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: Copies all elements of the quaternion `b` to the quaternion `a`.\n\nReturns: :: `a`.\n\n''' \n\n[[quat_convert_to]]\n==== `convert_to`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<R>::value && is_quat<A>::value\n    template <class R,class A>\n    R convert_to( A const & a );\n    \n    //Only enabled if:\n    //  is_quat<R>::value && is_mat<A>::value &&\n    //  mat_traits<A>::rows==3 && mat_traits<A>::cols==3\n    template <class R,class A>\n    R convert_to( A const & m );\n\n} }\n----\n====\n\nRequirements: :: `R` must be copyable.\n\nEffects: ::\n\n- The first overload is equivalent to: `R r; assign(r,a); return r;`\n\n- The second overload assumes that `m` is an orthonormal rotation matrix and converts it to a quaternion that performs the same rotation.\n\n''' \n\n[[quat_minus_eq]]\n==== `operator-=`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B>\n    A & operator-=( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: Subtracts the elements of `b` from the corresponding elements of `a`.\n\nReturns: :: `a`.\n\n''' \n\n[[quat_minus_unary]]\n==== `operator-` (unary)\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n   //Only enabled if: is_quat<A>::value\n    template <class A>\n    typename deduce_quat<A>::type\n    operator-( A const & a );\n\n} }\n\n----\n====\n\nReturns: :: A quaternion of the negated elements of `a`.\n\nNOTE: The <<deduce_quat,`deduce_quat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n''' \n\n[[quat_minus]]\n==== `operator-` (binary)\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B>\n    typename deduce_quat2<A,B>::type\n    operator-( A const & a, B const & b );\n\n} }\n\n----\n====\n\nReturns: :: A quaternion with elements equal to the elements of `b` subtracted from the corresponding elements of `a`.\n\nNOTE: The <<deduce_quat2,`deduce_quat2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n''' \n\n[[quat_plus_eq]]\n==== `operator+=`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B>\n    A & operator+=( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: Adds the elements of `b` to the corresponding elements of `a`.\n\nReturns: :: `a`.\n\n''' \n\n[[quat_plus]]\n==== `operator+`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value &&\n    template <class A,class B>\n    typename deduce_quat2<A,B>::type\n    operator+( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: A quaternion with elements equal to the elements of `a` added to the corresponding elements of `b`.\n\nNOTE: The <<deduce_quat2,`deduce_quat2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n''' \n\n[[quat_div_eq_scalar]]\n==== `operator/=` (scalar)\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value && is_scalar<B>::value\n    template <class A,class B>\n    A & operator/=( A & a, B b );\n\n} }\n----\n====\n\nEffects: :: This operation divides a quaternion by a scalar.\n\nReturns: :: `a`.\n\n''' \n\n[[quat_div_scalar]]\n==== `operator/` (scalar)\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value && is_scalar<B>::value\n    template <class A,class B>\n    typename deduce_quat<A>::type\n    operator/( A const & a, B b );\n\n} }\n----\n====\n\nReturns: :: A quaternion that is the result of dividing the quaternion `a` by the scalar `b`.\n\nNOTE: The <<deduce_quat,`deduce_quat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n''' \n\n[[quat_mul_eq_scalar]]\n==== `operator*=` (scalar)\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value && is_scalar<B>::value\n    template <class A,class B>\n    A & operator*=( A & a, B b );\n\n} }\n----\n====\n\nEffects: :: This operation multiplies the quaternion `a` by the scalar `b`.\n\nReturns: :: `a`.\n\n''' \n\n[[quat_mul_eq]]\n==== `operator*=`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B>\n    A & operator*=( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nA tmp(a);\na = tmp * b;\nreturn a;\n----\n\n''' \n\n[[quat_mul_scalar]]\n==== `operator*` (scalar)\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value && is_scalar<B>::value\n    template <class A,class B>\n    typename deduce_quat<A>::type\n    operator*( A const & a, B b );\n\n} }\n----\n====\n\nReturns: :: A quaternion that is the result of multiplying the quaternion `a` by the scalar `b`.\n\nNOTE: The <<deduce_quat,`deduce_quat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n''' \n\n[[quat_mul]]\n==== `operator*`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B>\n    typename deduce_quat2<A,B>::type\n    operator*( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: The result of multiplying the quaternions `a` and `b`.\n\nNOTE: The <<deduce_quat2,`deduce_quat2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n''' \n\n[[quat_eq]]\n==== `operator==`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B>\n    bool operator==( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: `true` if each element of `a` compares equal to its corresponding element of `b`, `false` otherwise.\n\n''' \n\n[[quat_neq]]\n==== `operator!=`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B>\n    bool operator!=( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: `!(a == b)`.\n\n''' \n\n[[quat_cmp]]\n==== `cmp`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B,class Cmp>\n    bool cmp( A const & a, B const & b, Cmp pred );\n\n} }\n----\n====\n\nReturns: :: Similar to <<quat_eq,`operator==`>>, except that it uses the binary predicate `pred` to compare the individual quaternion elements.\n\n''' \n\n[[quat_mag_sqr]]\n==== `mag_sqr`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    typename quat_traits<A>::scalar_type\n    mag_sqr( A const & a );\n\n} }\n----\n====\n\nReturns: :: The squared magnitude of the quaternion `a`.\n\n''' \n\n[[quat_mag]]\n==== `mag`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    typename quat_traits<A>::scalar_type\n    mag( A const & a );\n\n} }\n----\n====\n\nReturns: :: The magnitude of the quaternion `a`.\n\n''' \n\n[[quat_normalized]]\n==== `normalized`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    typename deduce_quat<A>::type\n    normalized( A const & a );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\ntypename deduce_quat<A>::type tmp;\nassign(tmp,a);\nnormalize(tmp);\nreturn tmp;\n----\n\nNOTE: The <<deduce_quat,`deduce_quat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n''' \n\n[[quat_normalize]]\n==== `normalize`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    void normalize( A & a );\n\n} }\n----\n====\n\nEffects: :: Normalizes `a`.\n\nPostcondition: :: `mag(a)==scalar_traits<typename quat_traits<A>::scalar_type>::value(1).`\n\nThrows: :: If the magnitude of `a` is zero, throws <<zero_magnitude_error,`zero_magnitude_error`>>.\n\n''' \n\n[[quat_dot]]\n==== `dot`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value\n    template <class A,class B>\n    typename deduce_scalar<A,B>::type\n    dot( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: The dot product of the quaternions `a` and `b`.\n\nNOTE: The <<deduce_scalar,`deduce_scalar`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n''' \n\n[[conjugate]]\n==== `conjugate`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    typename deduce_quat<A>::type\n    conjugate( A const & a );\n\n} }\n----\n====\n\nReturns: :: Computes the conjugate of `a`.\n\nNOTE: The <<deduce_quat,`deduce_quat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n''' \n\n[[quat_inverse]]\n==== `inverse`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    typename deduce_quat<A>::type\n    inverse( A const & a );\n\n} }\n----\n====\n\nReturns: :: Computes the multiplicative inverse of `a`, or the conjugate-to-norm ratio.\n\nThrows: :: If the magnitude of `a` is zero, throws <<zero_magnitude_error,`zero_magnitude_error`>>.\n\nTIP: If `a` is known to be unit length, `conjugate` is equivalent to <<quat_inverse,`inverse`>>, yet it is faster to compute.\n\nNOTE: The <<deduce_quat,`deduce_quat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n''' \n\n[[slerp]]\n==== `slerp`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value && is_quat<B>::value && is_scalar<C>\n    template <class A,class B,class C>\n    typename deduce_quat2<A,B> >::type\n    slerp( A const & a, B const & b, C c );\n\n} }\n----\n====\n\nPreconditions: :: `t>=0 && t\\<=1`.\n\nReturns: :: A quaternion that is the result of Spherical Linear Interpolation of the quaternions `a` and `b` and the interpolation parameter `c`. When `slerp` is applied to unit quaternions, the quaternion path maps to a path through 3D rotations in a standard way. The effect is a rotation with uniform angular velocity around a fixed rotation axis.\n\nNOTE: The <<deduce_quat2,`deduce_quat2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n''' \n\n[[zero_quat]]\n==== `zero_quat`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class T>\n    -unspecified-return-type- zero_quat();\n\n} }\n----\n====\n\nReturns: :: A read-only quaternion of unspecified type with <<scalar_traits,`scalar_type`>> `T`, with all elements equal to <<scalar_traits,`scalar_traits<T>::value(0)`>>.\n\n''' \n\n[[quat_set_zero]]\n==== `set_zero`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    void set_zero( A & a );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(a,\n    zero_quat<typename quat_traits<A>::scalar_type>());\n----\n\n''' \n\n[[identity_quat]]\n==== `identity_quat`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class S>\n    -unspecified-return-type- identity_quat();\n\n} }\n----\n====\n\nReturns: :: An identity quaternion with scalar type `S`.\n\n''' \n\n[[quat_set_identity]]\n==== `set_identity`\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    void set_identity( A & a );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(\n    a,\n    identity_quat<typename quat_traits<A>::scalar_type>());\n----\n\n''' \n\n[[rot_quat]]\n==== `rot_quat`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_vec<A>::value && vec_traits<A>::dim==3\n    template <class A>\n    -unspecified-return-type- rot_quat( A const & axis, typename vec_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nReturns: :: A quaternion of unspecified type which performs a rotation around the `axis` at `angle` radians.\n\nThrows: :: In case the axis vector has zero magnitude, throws <<zero_magnitude_error,`zero_magnitude_error`>>.\n\nNOTE: The `rot_quat` function is not a <<view_proxy,view proxy>>; it returns a temp object.\n\n''' \n\n[[quat_set_rot]]\n==== `set_rot`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value &&\n    //  is_vec<B>::value && vec_traits<B>::dim==3\n    template <class A>\n    void set_rot( A & a, B const & axis, typename vec_traits<B>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(\n    a,\n    rot_quat(axis,angle));\n----\n\n''' \n\n[[quat_rotate]]\n==== `rotate`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_quat<A>::value &&\n    //  is_vec<B>::value && vec_traits<B>::dim==3\n    template <class A,class B>\n    void rotate( A & a, B const & axis, typename quat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if: `a *= <<rot_quat,rot_quat>>(axis,angle)`.\n\n''' \n\n[[rotx_quat]]\n==== `rotx_quat`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class Angle>\n    -unspecified-return-type- rotx_quat( Angle const & angle );\n\n} }\n----\n====\n\nReturns: :: A <<view_proxy,view proxy>> quaternion of unspecified type and scalar type `Angle`, which performs a rotation around the X axis at `angle` radians.\n\n''' \n\n[[quat_set_rotx]]\n==== `set_rotx`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    void set_rotx( A & a, typename quat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(\n    a,\n    rotx_quat(angle));\n----\n\n''' \n\n[[quat_rotate_x]]\n==== `rotate_x`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    void rotate_x( A & a, typename quat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if: `a *= <<rotx_quat,rotx_quat>>(angle)`.\n\n''' \n\n[[roty_quat]]\n==== `roty_quat`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class Angle>\n    -unspecified-return-type- roty_quat( Angle const & angle );\n\n} }\n----\n====\n\nReturns: :: A <<view_proxy,view proxy>> quaternion of unspecified type and scalar type `Angle`, which performs a rotation around the Y axis at `angle` radians.\n\n''' \n\n[[quat_set_roty]]\n==== `set_roty`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    void set_rotz( A & a, typename quat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(\n    a,\n    roty_quat(angle));\n----\n\n''' \n\n[[quat_rotate_y]]\n==== `rotate_y`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    void rotate_y( A & a, typename quat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if: `a *= <<roty_quat,roty_quat>>(angle)`.\n\n''' \n\n[[rotz_quat]]\n==== `rotz_quat`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        template <class Angle>\n        -unspecified-return-type- rotz_quat( Angle const & angle );\n\n} }\n----\n====\n\nReturns: :: A <<view_proxy,view proxy>> quaternion of unspecified type and scalar type `Angle`, which performs a rotation around the Z axis at `angle` radians.\n\n''' \n\n[[quat_set_rotz]]\n==== `set_rotz`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    void set_rotz( A & a, typename quat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(\n    a,\n    rotz_quat(angle));\n----\n\n''' \n\n[[quat_rotate_z]]\n==== `rotate_z`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    void rotate_z( A & a, typename quat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if: `a *= <<rotz_quat,rotz_quat>>(angle)`.\n\n''' \n\n[[quat_scalar_cast]]\n==== `scalar_cast`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class Scalar,class A>\n    -unspecified-return_type- scalar_cast( A const & a );\n\n} }\n----\n====\n\nReturns: :: A read-only <<view_proxy,view proxy>> of `a` that looks like a quaternion of the same dimensions as `a`, but with <<quat_traits,`scalar_type`>> `Scalar` and elements constructed from the corresponding elements of `a`.\n\n''' \n\n[[qref]]\n==== `qref`\n\n====\n.#include <boost/qvm/quat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_quat<A>::value\n    template <class A>\n    -unspecified-return-type- qref( A & a );\n\n} }\n----\n====\n\nReturns: :: An identity view proxy of `a`; that is, it simply accesses the elements of `a`.\n\nTIP: `qref` allows calling Boost QVM operations when `a` is of built-in type, for example a plain old C array.\n\n'''\n\n=== Generic vector operations\n\n[[vec_assign]]\n==== `assign`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value && is_vec<B>::value &&\n        //  vec_traits<A>::dim==vec_traits<B>::dim\n        template <class A,class B>\n        A & assign( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: Copies all elements of the vector `b` to the vector `a`.\n\nReturns: :: `a`.\n\n'''\n\n[[vec_convert_to]]\n==== `convert_to`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<R>::value && is_vec<A>::value &&\n        //  vec_traits<R>::dim==vec_traits<A>::dim\n        template <class R,class A>\n        R convert_to( A const & a );\n\n} }\n----\n====\n\nRequirements: :: `R` must be copyable.\n\nEffects: :: As if: `R r; assign(r,a); return r;`\n\n'''\n\n[[vec_minus_eq]]\n==== `operator-=`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value && is_vec<B>::value &&\n        //  vec_traits<A>::dim==vec_traits<B>::dim\n        template <class A,class B>\n        A & operator-=( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: Subtracts the elements of `b` from the corresponding elements of `a`.\n\nReturns: :: `a`.\n\n'''\n\n[[vec_minus_unary]]\n==== `operator-` (unary)\n\noperator-(vec)\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if: is_vec<A>::value\n        template <class A>\n        typename deduce_vec<A>::type\n        operator-( A const & a );\n\n} }\n----\n====\n\nReturns: :: A vector of the negated elements of `a`.\n\nNOTE: The <<deduce_vec,`deduce_vec`>> template can be specialized to deduce the desired return type from the type `A`.\n\n'''\n\n[[vec_minus]]\n==== `operator-` (binary)\n\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value && is_vec<B>::value &&\n        //  vec_traits<A>::dim==vec_traits<B>::dim\n        template <class A,class B>\n        typename deduce_vec2<A,B,vec_traits<A>::dim>::type\n        operator-( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: A vector of the same size as `a` and `b`, with elements the elements of `b` subtracted from the corresponding elements of `a`.\n\nNOTE: The <<deduce_vec2,`deduce_vec2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n'''\n\n[[vec_plus_eq]]\n==== `operator+=`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value && is_vec<B>::value &&\n        //  vec_traits<A>::dim==vec_traits<B>::dim\n        template <class A,class B>\n        A & operator+=( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: Adds the elements of `b` to the corresponding elements of `a`.\n\nReturns: :: `a`.\n\n'''\n\n[[vec_plus]]\n==== `operator+`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value && is_vec<B>::value &&\n        //  vec_traits<A>::dim==vec_traits<B>::dim\n        template <class A,class B>\n        typename deduce_vec2<A,B,vec_traits<A>::dim>::type\n        operator+( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: A vector of the same size as `a` and `b`, with elements the elements of `b` added to the corresponding elements of `a`.\n\nNOTE: The <<deduce_vec2,`deduce_vec2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n'''\n\n[[vec_div_eq_scalar]]\n==== `operator/=` (scalar)\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if: is_vec<A>::value && is_scalar<B>::value\n        template <class A,class B>\n        A & operator/=( A & a, B b );\n\n} }\n----\n====\n\nEffects: :: This operation divides a vector by a scalar.\n\nReturns: :: `a`.\n\n'''\n\n[[vec_div_scalar]]\n==== `operator/`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if: is_vec<A>::value && is_scalar<B>::value\n        template <class A,class B>\n        typename deduce_vec<A>::type\n        operator/( A const & a, B b );\n\n} }\n----\n====\n\nReturns: :: A vector that is the result of dividing the vector `a` by the scalar `b`.\n\nNOTE: The <<deduce_vec,`deduce_vec`>> template can be specialized to deduce the desired return type from the type `A`.\n\n'''\n\n[[vec_mul_eq_scalar]]\n==== `operator*=`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if: is_vec<A>::value && is_scalar<B>::value\n        template <class A,class B>\n        A & operator*=( A & a, B b );\n\n} }\n----\n====\n\nEffects: :: This operation multiplies the vector `a` by the scalar `b`.\n\nReturns: :: `a`.\n\n'''\n\n[[vec_mul_scalar]]\n==== `operator*`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if: is_vec<A>::value && is_scalar<B>::value\n        template <class A>\n        typename deduce_vec<A>::type\n        operator*( A const & a, B b );\n\n} }\n----\n====\n\nReturns: :: A vector that is the result of multiplying the vector `a` by the scalar `b`.\n\nNOTE: The <<deduce_vec,`deduce_vec`>> template can be specialized to deduce the desired return type from the type `A`.\n\n'''\n\n[[vec_eq]]\n==== `operator==`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value && is_vec<B>::value &&\n        //  vec_traits<A>::dim==vec_traits<B>::dim\n        template <class A,class B>\n        bool operator==( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: `true` if each element of `a` compares equal to its corresponding element of `b`, `false` otherwise.\n\n'''\n\n[[vec_neq]]\n==== `operator!=`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value && is_vec<B>::value &&\n        //  vec_traits<A>::dim==vec_traits<B>::dim\n        template <class A,class B>\n        bool operator!=( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: `!(a == b)`.\n\n'''\n\n[[vec_cmp]]\n==== `cmp`\n\n====\n----\n.#include <boost/qvm/mat_operations.hpp>\n\nnamespace boost\n{\n    namespace qvm\n    {\n        //Only enabled if:\n        //  is_mat<A>::value && is_mat<B>::value &&\n        //  mat_traits<A>::rows==mat_traits<B>::rows &&\n        //  mat_traits<A>::cols==mat_traits<B>::cols\n        template <class A,class B,class Cmp>\n        bool cmp( A const & a, B const & b, Cmp pred );\n\n} }\n----\n====\n\nReturns: :: Similar to <<vec_eq,`operator==`>>, except that the individual elements of `a` and `b` are passed to the binary predicate `pred` for comparison.\n\n'''\n\n[[vec_mag_sqr]]\n==== `mag_sqr`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value\n        template <class A>\n        typename vec_traits<A>::scalar_type\n        mag_sqr( A const & a );\n\n} }\n----\n====\n\nReturns: :: The squared magnitude of the vector `a`.\n\n'''\n\n[[vec_mag]]\n==== `mag`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value\n        template <class A>\n        typename vec_traits<A>::scalar_type\n        mag( A const & a );\n\n} }\n----\n====\n\nReturns: :: The magnitude of the vector `a`.\n\n'''\n\n[[vec_normalized]]\n==== `normalized`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value\n        template <class A>\n        typename deduce_vec<A>::type\n        normalized( A const & a );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\ntypename deduce_vec<A>::type tmp;\nassign(tmp,a);\nnormalize(tmp);\nreturn tmp;\n----\n\nNOTE: The <<deduce_vec,`deduce_vec`>> template can be specialized to deduce the desired return type from the type `A`.\n\n'''\n\n[[vec_normalize]]\n==== `normalize`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value\n        template <class A>\n        void normalize( A & a );\n\n} }\n----\n====\n\nEffects: :: Normalizes `a`.\n\nPostcondition:\n\n`mag(a)==<<scalar_traits,scalar_traits>><typename <<vec_traits,vec_traits<A>::scalar_type>>>::value(1)`.\n\nThrows: :: If the magnitude of `a` is zero, throws <<zero_magnitude_error,`zero_magnitude_error`>>.\n\n'''\n\n[[vec_dot]]\n==== `dot`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value && is_vec<B>::value &&\n        //  vec_traits<A>::dim==vec_traits<B>::dim\n        template <class A,class B>\n        typename deduce_scalar<A,B>::type\n        dot( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: The dot product of the vectors `a` and `b`.\n\nNOTE: The <<deduce_scalar,`deduce_scalar`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n'''\n\n[[vec_cross]]\n==== `cross`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value && is_vec<B>::value &&\n        //  vec_traits<A>::dim==3 && vec_traits<B>::dim==3\n        template <class A,class B>\n        typename deduce_vec2<A,B,3>::type\n        cross( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: The cross product of the vectors `a` and `b`.\n\nNOTE: The <<deduce_vec2,`deduce_vec2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n'''\n\n[[zero_vec]]\n==== `zero_vec`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        template <class T,int S>\n        -unspecified-return-type- zero_vec();\n\n} }\n----\n====\n\nReturns: :: A read-only vector of unspecified type with <<vec_traits,`scalar_type`>> `T` and size `S`, with all elements equal to <<scalar_traits,`scalar_traits<T>::value(0)`>>.\n\n'''\n\n[[vec_set_zero]]\n==== `set_zero`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if:\n        //  is_vec<A>::value\n        template <class A>\n        void set_zero( A & a );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(a,\n    zero_vec<\n        typename vec_traits<A>::scalar_type,\n        vec_traits<A>::dim>());\n----\n\n'''\n\n[[vec_scalar_cast]]\n==== `scalar_cast`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if: is_vec<A>::value\n        template <class Scalar,class A>\n        -unspecified-return_type- scalar_cast( A const & a );\n\n} }\n----\n====\n\nReturns: :: A read-only <<view_proxy,view proxy>> of `a` that looks like a vector of the same dimensions as `a`, but with <<vec_traits,`scalar_type`>> `Scalar` and elements constructed from the corresponding elements of `a`.\n\n'''\n\n[[vref]]\n==== `vref`\n\n====\n.#include <boost/qvm/vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n        //Only enabled if: is_vec<A>::value\n        template <class A>\n        -unspecified-return-type- vref( A & a );\n\n} }\n----\n====\n\nReturns: :: An identity <<view_proxy,view proxy>> of `a`; that is, it simply accesses the elements of `a`.\n\nTIP: `vref` allows calling Boost QVM operations when `a` is of built-in type, for example a plain old C array.\n\n'''\n\n=== Generic matrix operations\n\n[[mat_assign]]\n==== `assign`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::rows==mat_traits<B>::rows &&\n    //  mat_traits<A>::cols==mat_traits<B>::cols\n    template <class A,class B>\n    A & assign( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: Copies all elements of the matrix `b` to the matrix `a`.\n\nReturns: :: `a`.\n\n'''\n\n[[mat_convert_to]]\n==== `convert_to`        \n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<R>::value && is_mat<A>::value &&\n    //  mat_traits<R>::rows==mat_traits<A>::rows &&\n    //  mat_traits<R>::cols==mat_traits<A>::cols\n    template <class R,class A>\n    R convert_to( A const & a );\n\n} }\n----\n====\n\nRequirements: :: `R` must be copyable.\n\nEffects:\n\nAs if: `R r; <<mat_assign,assign>>(r,a); return r;`\n\n'''\n\n[[mat_minus_eq_scalar]]\n==== `operator-=`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::rows==mat_traits<B>::rows &&\n    //  mat_traits<A>::cols==mat_traits<B>::cols\n    template <class A,class B>\n    A & operator-=( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: Subtracts the elements of `b` from the corresponding elements of `a`.\n\nReturns: :: `a`.\n\n'''\n\n[[mat_minus_unary]]\n==== `operator-` (unary)\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value\n    template <class A>\n    typename deduce_mat<A>::type\n    operator-( A const & a );\n\n} }\n----\n====\n\nReturns: :: A matrix of the negated elements of `a`.\n\nNOTE: The <<deduce_mat,`deduce_mat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n'''\n\n[[mat_minus]]\n==== `operator-`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::rows==mat_traits<B>::rows &&\n    //  mat_traits<A>::cols==mat_traits<B>::cols\n    template <class A,class B>\n    typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type\n    operator-( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: A matrix of the same size as `a` and `b`, with elements the elements of `b` subtracted from the corresponding elements of `a`.\n\nNOTE: The <<deduce_mat2,`deduce_mat2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n'''\n\n[[mat_plus_eq_scalar]]\n==== `operator+=`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::rows==mat_traits<B>::rows &&\n    //  mat_traits<A>::cols==mat_traits<B>::cols\n    template <class A,class B>\n    A & operator+=( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: Adds the elements of `b` to the corresponding elements of `a`.\n\nReturns: :: `a`.\n\n'''\n\n[[mat_plus]]\n==== `operator+`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::rows==mat_traits<B>::rows &&\n    //  mat_traits<A>::cols==mat_traits<B>::cols\n    template <class A,class B>\n    typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type\n    operator+( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: A matrix of the same size as `a` and `b`, with elements the elements of `b` added to the corresponding elements of `a`.\n\nNOTE: The <<deduce_mat2,`deduce_mat2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n'''\n\n[[mat_div_eq_scalar]]\n==== `operator/=` (scalar)\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value && is_scalar<B>::value\n    template <class A,class B>\n    A & operator/=( A & a, B b );\n\n} }\n----\n====\n\nEffects: :: This operation divides a matrix by a scalar.\n\nReturns: :: `a`.\n\n'''\n\n[[mat_div_scalar]]\n==== `operator/` (scalar)\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value && is_scalar<B>::value\n    template <class A,class B>\n    typename deduce_mat<A>::type\n    operator/( A const & a, B b );\n\n} }\n----\n====\n\nReturns: :: A matrix that is the result of dividing the matrix `a` by the scalar `b`.\n\nNOTE: The <<deduce_mat,`deduce_mat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n'''\n\n[[mat_mul_eq]]\n==== `operator*=`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols &&\n    //  mat_traits<A>::rows==mat_traits<B>::rows &&\n    //  mat_traits<A>::cols==mat_traits<B>::cols\n    template <class A,class B>\n    A & operator*=( A & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nA tmp(a);\na = tmp * b;\nreturn a;\n----\n\n'''\n\n[[mat_mul_eq_scalar]]\n==== `operator*=` (scalar)\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value && is_scalar<B>::value\n    template <class A,class B>\n    A & operator*=( A & a, B b );\n\n} }\n----\n====\n\nEffects: :: This operation multiplies the matrix `a` matrix by the scalar `b`.\n\nReturns: :: `a`.\n\n'''\n\n[[mat_mul]]\n==== `operator*`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::cols==mat_traits<B>::rows\n    template <class A,class B>\n    typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<B>::cols>::type\n    operator*( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: The result of https://en.wikipedia.org/wiki/Matrix_multiplication[multiplying] the matrices `a` and `b`.\n\nNOTE: The <<deduce_mat2,`deduce_mat2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n'''\n\n[[mat_mul_scalar]]\n==== `operator*` (scalar)\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value && is_scalar<B>::value\n    template <class A,class B>\n    typename deduce_mat<A>::type\n    operator*( A const & a, B b );\n\n    //Only enabled if: is_scalar<B>::value && is_mat<A>::value\n    template <class B,class A>\n    typename deduce_mat<A>::type\n    operator*( B b, A const & a );\n\n} }\n----\n====\n\nReturns: :: A matrix that is the result of multiplying the matrix `a` by the scalar `b`.\n\nNOTE: The <<deduce_mat,`deduce_mat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n'''\n\n[[mat_eq]]\n==== `operator==`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::rows==mat_traits<B>::rows &&\n    //  mat_traits<A>::cols==mat_traits<B>::cols\n    template <class A,class B>\n    bool operator==( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: `true` if each element of `a` compares equal to its corresponding element of `b`, `false` otherwise.\n\n'''\n\n[[mat_neq]]\n==== `operator!=`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::rows==mat_traits<B>::rows &&\n    //  mat_traits<A>::cols==mat_traits<B>::cols\n    template <class A,class B>\n    bool operator!=( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: `!( a <<mat_eq,=\\=>> b )`.\n\n'''\n\n[[mat_cmp]]\n==== `cmp`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_mat<B>::value &&\n    //  mat_traits<A>::rows==mat_traits<B>::rows &&\n    //  mat_traits<A>::cols==mat_traits<B>::cols\n    template <class A,class B,class Cmp>\n    bool cmp( A const & a, B const & b, Cmp pred );\n\n} }\n----\n====\n\nReturns: :: Similar to <<mat_eq,`operator==`>>, except that the individual elements of `a` and `b` are passed to the binary predicate `pred` for comparison.\n\n'''\n\n[[mat_inverse]]\n==== `inverse`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_scalar<B>::value\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    \n    template <class A,class B>\n    typename deduce_mat<A>::type\n    inverse( A const & a, B det );\n    \n    template <class A>\n    typename deduce_mat<A>::type\n    inverse( A const & a );\n\n} }\n----\n====\n\nPreconditions: :: `det!=<<scalar_traits,scalar_traits>><typename <<mat_traits,mat_traits<A>::scalar_type>>>::value(0)`\n\nReturns: :: Both overloads compute the inverse of `a`. The first overload takes the pre-computed determinant of `a`.\n\nThrows: :: The second overload computes the determinant automatically and throws <<zero_determinant_error,`zero_determinant_error`>> if the computed determinant is zero.\n\nNOTE: The <<deduce_mat,`deduce_mat`>> template can be specialized to deduce the desired return type from the type `A`.\n\n'''\n\n[[zero_mat]]\n==== `zero_mat`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class T,int D>\n    -unspecified-return-type- zero_mat();\n    \n    template <class T,int R,int C>\n    -unspecified-return-type- zero_mat();\n\n} }\n----\n====\n\nReturns: :: A read-only matrix of unspecified type with <<mat_traits,`scalar_type`>> `T`, `R` rows and `C` columns (or `D` rows and `D` columns), with all elements equal to <<scalar_traits,`scalar_traits<T>::value(0)`>>.\n\n'''\n\n[[mat_set_zero]]\n==== `set_zero`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value\n    template <class A>\n    void set_zero( A & a );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(a,\n    zero_mat<\n        typename mat_traits<A>::scalar_type,\n        mat_traits<A>::rows,\n        mat_traits<A>::cols>());\n----\n\n'''\n\n[[identity_mat]]\n==== `identity_mat`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n----\nnamespace boost { namespace qvm {\n\n    template <class S,int D>\n    -unspecified-return-type- identity_mat();\n\n} }\n----\n====\n\nReturns: :: An identity matrix of size `D` x `D` and scalar type `S`.\n\n'''\n\n[[mat_set_identity]]\n==== `set_identity`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value &&\n    //  mat_traits<A>::cols==mat_traits<A>::rows\n    template <class A>\n    void set_identity( A & a );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(\n    a,\n    identity_mat<\n        typename mat_traits<A>::scalar_type,\n        mat_traits<A>::rows,\n        mat_traits<A>::cols>());\n----\n\n'''\n\n[[rot_mat]]\n==== `rot_mat` / Euler angles\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_vec<A>::value && vec_traits<A>::dim==3\n    template <int Dim,class A,class Angle>\n    -unspecified-return-type-\n    rot_mat( A const & axis, Angle angle );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_xzy( Angle x1, Angle z2, Angle y3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_xyz( Angle x1, Angle y2, Angle z3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_yxz( Angle y1, Angle x2, Angle z3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_yzx( Angle y1, Angle z2, Angle x3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_zyx( Angle z1, Angle y2, Angle x3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_zxy( Angle z1, Angle x2, Angle y3 );\n\n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_xzx( Angle x1, Angle z2, Angle x3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_xyx( Angle x1, Angle y2, Angle x3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_yxy( Angle y1, Angle x2, Angle y3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_yzy( Angle y1, Angle z2, Angle y3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_zyz( Angle z1, Angle y2, Angle z3 );\n    \n    template <int Dim,class Angle>\n    -unspecified-return-type-\n    rot_mat_zxz( Angle z1, Angle y2, Angle z3 );\n\n} }\n----\n====\n\nReturns: :: A matrix of unspecified type, of `Dim` rows and `Dim` columns parameter, which performs a rotation around the `axis` at `angle` radians, or Tait–Bryan angles (x-y-z, y-z-x, z-x-y, x-z-y, z-y-x, y-x-z), or proper Euler angles (z-x-z, x-y-x, y-z-y, z-y-z, x-z-x, y-x-y). See https://en.wikipedia.org/wiki/Euler_angles[Euler angles].\n\nThrows: :: In case the axis vector has zero magnitude, throws <<zero_magnitude_error,`zero_magnitude_error`>>.\n\nNOTE: These functions are not view proxies; they return a temp object.\n\n'''\n\n[[mat_set_rot]]\n==== `set_rot` / Euler angles\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols &&\n    //  is_vec<B>::value && vec_traits<B>::dim==3\n    template <class A>\n    void set_rot( A & a, B const & axis, typename vec_traits<B>::scalar_type angle );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_xzy( A & a, Angle x1, Angle z2, Angle y3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_xyz( A & a, Angle x1, Angle y2, Angle z3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_yxz( A & a, Angle y1, Angle x2, Angle z3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_yzx( A & a, Angle y1, Angle z2, Angle x3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_zyx( A & a, Angle z1, Angle y2, Angle x3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_zxy( A & a, Angle z1, Angle x2, Angle y3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_xzx( A & a, Angle x1, Angle z2, Angle x3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_xyx( A & a, Angle x1, Angle y2, Angle x3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_yxy( A & a, Angle y1, Angle x2, Angle y3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_yzy( A & a, Angle y1, Angle z2, Angle y3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_zyz( A & a, Angle z1, Angle y2, Angle z3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_zxz( A & a, Angle z1, Angle x2, Angle z3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void set_rot_xzy( A & a, Angle x1, Angle z2, Angle y3 );\n\n} }\n----\n====\n\nEffects: :: Assigns the return value of the corresponding <<rot_mat,`rot_mat`>> function to `a`.\n\n'''\n        \n[[mat_rotate]]\n==== `rotate` / Euler angles\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols &&\n    //  is_vec<B>::value && vec_traits<B>::dim==3\n    template <class A,class B>\n    void rotate( A & a, B const & axis, typename mat_traits<A>::scalar_type angle );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_xzy( A & a, Angle x1, Angle z2, Angle y3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_xyz( A & a, Angle x1, Angle y2, Angle z3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_yxz( A & a, Angle y1, Angle x2, Angle z3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_yzx( A & a, Angle y1, Angle z2, Angle x3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_zyx( A & a, Angle z1, Angle y2, Angle x3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_zxy( A & a, Angle z1, Angle x2, Angle y3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_xzx( A & a, Angle x1, Angle z2, Angle x3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_xyx( A & a, Angle x1, Angle y2, Angle x3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_yxy( A & a, Angle y1, Angle x2, Angle y3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_yzy( A & a, Angle y1, Angle z2, Angle y3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_zyz( A & a, Angle z1, Angle y2, Angle z3 );\n    \n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A,class Angle>\n    void rotate_zxz( A & a, Angle z1, Angle x2, Angle z3 );\n\n} }\n----\n====\n\nEffects: :: Multiplies the matrix `a` in-place by the return value of the corresponding <<rot_mat,`rot_mat`>> function.\n\n'''\n\n[[rotx_mat]]\n==== `rotx_mat`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int Dim,class Angle>\n    -unspecified-return-type- rotx_mat( Angle const & angle );\n\n} }\n----\n====\n\nReturns: :: A <<view_proxy,view proxy>> matrix of unspecified type, of `Dim` rows and `Dim` columns and scalar type `Angle`, which performs a rotation around the `X` axis at `angle` radians.\n\n'''\n\n[[mat_set_rotx]]\n==== `set_rotx`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A>\n    void set_rotx( A & a, typename mat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(\n    a,\n    rotx_mat<mat_traits<A>::rows>(angle));\n----\n\n'''\n\n[[mat_rotate_x]]\n==== `rotate_x`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A>\n    void rotate_x( A & a, typename mat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if: `a <<mat_mul_eq,*\\=>> <<rotx_mat,rotx_mat>><<<mat_traits,mat_traits<A>::rows>>>(angle)`.\n\n\n'''\n\n[[roty_mat]]\n==== `roty_mat`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int Dim,class Angle>\n    -unspecified-return-type- roty_mat( Angle const & angle );\n\n} }\n----\n====\n\nReturns: :: A <<view_proxy,view proxy>> matrix of unspecified type, of `Dim` rows and `Dim` columns and scalar type `Angle`, which performs a rotation around the `Y` axis at `angle` radians.\n\n'''\n\n[[mat_set_roty]]\n==== `set_roty`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A>\n    void set_roty( A & a, typename mat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(\n    a,\n    roty_mat<mat_traits<A>::rows>(angle));\n----\n\n'''\n\n[[mat_rotate_y]]\n==== `rotate_y`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A>\n    void rotate_y( A & a, typename mat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if: `a <<mat_mul_eq,*\\=>> <<roty_mat,roty_mat>><<<mat_traits,mat_traits<A>::rows>>>(angle)`.\n\n'''\n\n[[rotz_mat]]\n==== `rotz_mat`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int Dim,class Angle>\n    -unspecified-return-type- rotz_mat( Angle const & angle );\n\n} }\n----\n====\n\nReturns: :: A <<view_proxy,view proxy>> matrix of unspecified type, of `Dim` rows and `Dim` columns and scalar type `Angle`, which performs a rotation around the `Z` axis at `angle` radians.\n\n'''\n\n[[mat_set_rotz]]\n==== `set_rotz`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A>\n    void set_rotz( A & a, typename mat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if:\n+\n[source,c++]\n----\nassign(\n    a,\n    rotz_mat<mat_traits<A>::rows>(angle));\n----\n\n'''\n\n[[mat_rotate_z]]\n==== `rotate_z`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows>=3 &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A>\n    void rotate_z( A & a, typename mat_traits<A>::scalar_type angle );\n\n} }\n----\n====\n\nEffects: :: As if: `a <<mat_mul_eq,*\\=>> <<rotz_mat,rotz_mat>><<<mat_traits,mat_traits<A>::rows>>>(angle)`.\n\n'''\n\n[[determinant]]\n==== `determinant`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && mat_traits<A>::rows==mat_traits<A>::cols\n    template <class A>\n    mat_traits<A>::scalar_type\n    determinant( A const & a );\n\n} }\n----\n====\n\nThis function computes the https://en.wikipedia.org/wiki/Determinant[determinant] of the square matrix `a`.\n\n'''\n\n[[perspective_lh]]\n==== `perspective_lh`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class T>\n    -unspecified-return-type-\n    perspective_lh( T fov_y, T aspect, T zn, T zf );\n\n} }\n----\n====\n\nReturns: :: A 4x4 projection matrix of unspecified type of the following form:\n+\n[cols=\"^v,^v,^v,^v\",width=\"50%\"]\n|====\n| `xs` | 0 |  0 | 0\n| 0 | `ys` | 0 | 0\n| 0 | 0 | `zf`/(`zf`-`zn`) |  -`zn`*`zf`/(`zf`-`zn`)\n| 0 | 0 | 1 | 0\n|====\n+\nwhere `ys` = cot(`fov_y`/2) and `xs` = `ys`/`aspect`.\n\n'''\n\n[[perspective_rh]]\n==== `perspective_rh`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <class T>\n    -unspecified-return-type-\n    perspective_rh( T fov_y, T aspect, T zn, T zf );\n\n} }\n----\n====\n\nReturns: :: A 4x4 projection matrix of unspecified type of the following form:\n+\n[cols=\"^v,^v,^v,^v\",width=\"50%\"]\n|====\n| `xs` | 0 | 0 | 0\n| 0 | `ys` | 0 | 0\n| 0 | 0 | `zf`/(`zn`-`zf`) | `zn`*`zf`/(`zn`-`zf`)\n| 0 | 0 | -1 | 0\n|====\n+\nwhere `ys` = cot(`fov_y`/2), and `xs` = `ys`/`aspect`.\n\n'''\n\n[[mat_scalar_cast]]\n==== `scalar_cast`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value\n    template <class Scalar,class A>\n    -unspecified-return_type- scalar_cast( A const & a );\n\n} }\n----\n====\n\nReturns: :: A read-only <<view_proxy,view proxy>> of `a` that looks like a matrix of the same dimensions as `a`, but with <<mat_traits,`scalar_type`>> `Scalar` and elements constructed from the corresponding elements of `a`.\n\n'''\n\n[[mref]]\n==== `mref`\n\n====\n.#include <boost/qvm/mat_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value\n    template <class A>\n    -unspecified-return-type- mref( A & a );\n\n} }\n----\n====\n\nReturns: :: An identity view proxy of `a`; that is, it simply accesses the elements of `a`.\n\nTIP: `mref` allows calling Boost QVM operations when `a` is of built-in type, for example a plain old C array.\n\n'''\n\n=== Generic quaternion-vector operations\n\n[[quat_vec_mul]]\n==== `operator*`\n\n====\n.#include <boost/qvm/quat_vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_vec<B>::value &&\n    //  mat_traits<A>::cols==vec_traits<B>::dim\n    template <class A,class B>\n    typename deduce_vec2<A,B,mat_traits<A>::rows>::type\n    operator*( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: The result of transforming the vector `b` by the quaternion `a`.\n\nNOTE: The <<deduce_vec2,`deduce_vec2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n'''\n\n=== Generic matrix-vector operations\n\n[[mat_vec_mul]]\n==== `operator*`\n\n====\n.#include <boost/qvm/mat_vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_vec<B>::value &&\n    //  mat_traits<A>::cols==vec_traits<B>::dim\n    template <class A,class B>\n    typename deduce_vec2<A,B,mat_traits<A>::rows>::type\n    operator*( A const & a, B const & b );\n\n} }\n----\n====\n\nReturns: :: The result of multiplying the matrix `a` and the vector `b`, where `b` is interpreted as a matrix-column. The resulting matrix-row is returned as a vector type.\n\nNOTE: The <<deduce_vec2,`deduce_vec2`>> template can be specialized to deduce the desired return type, given the types `A` and `B`.\n\n'''\n\n[[transform_vector]]\n==== `transform_vector`\n\n====\n.#include <boost/qvm/mat_vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_vec<B>::value &&\n    //  mat_traits<A>::rows==4 && mat_traits<A>::cols==4 &&\n    //  vec_traits<B>::dim==3\n    template <class A,class B>\n    deduce_vec2<A,B,3> >::type\n    transform_vector( A const & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: As if: `return a <<mat_vec_mul,*>> <<swizzling,XYZ0>>(b)`.\n\n'''\n\n[[transform_point]]\n==== `transform_pointt`\n\n====\n.#include <boost/qvm/mat_vec_operations.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value && is_vec<B>::value &&\n    //  mat_traits<A>::rows==4 && mat_traits<A>::cols==4 &&\n    //  vec_traits<B>::dim==3\n    template <class A,class B>\n    deduce_vec2<A,B,3> >::type\n    transform_point( A const & a, B const & b );\n\n} }\n----\n====\n\nEffects: :: As if: `return a <<mat_vec_mul,*>> <<swizzling,XYZ1>>(b)`.\n\n'''\n\n=== Generic matrix-to-matrix view proxies\n\n[[del_row]]\n==== `del_row`\n\n====\n.#include <boost/qvm/map_mat_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int R>\n    -unspecified-return-type- del_row();\n\n} }\n----\n====\n\nThe expression `del_row<R>(m)` returns an lvalue <<view_proxy,view proxy>> that looks like the matrix `m` with row `R` deleted.\n\n'''\n\n[[del_col]]\n==== `del_col`\n\n====\n.#include <boost/qvm/map_mat_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int C>\n    -unspecified-return-type- del_col();\n\n} }\n----\n====\n\nThe expression `del_col<C>(m)` returns an lvalue <<view_proxy,view proxy>> that looks like the matrix `m` with column `C` deleted.\n\n'''\n\n[[del_row_col]]\n==== `del_row_col`\n\n====\n.#include <boost/qvm/map_mat_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int R,int C>\n    -unspecified-return-type- del_row_col();\n\n} }\n----\n====\n\nThe expression `del_row_col<R,C>(m)` returns an lvalue <<view_proxy,view proxy>> that looks like the matrix `m` with row `R` and column `C` deleted.\n\n'''\n\n[[neg_row]]\n==== `neg_row`\n\n====\n.#include <boost/qvm/map_mat_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int R>\n    -unspecified-return-type- neg_row();\n\n} }\n----\n====\n\nThe expression `neg_row<R>(m)` returns a read-only <<view_proxy,view proxy>> that looks like the matrix `m` with row `R` negated.\n\n'''\n\n[[neg_col]]\n==== `neg_col`\n\n====\n.#include <boost/qvm/map_mat_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int C>\n    -unspecified-return-type- neg_col();\n\n} }\n----\n====\n\n The expression `neg_col<C>(m)` returns a read-only <<view_proxy,`view proxy`>> that looks like the matrix `m` with column `C` negated.\n\n'''\n\n[[swap_rows]]\n==== `swap_rows`\n\n====\n.#include <boost/qvm/map_mat_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int R1,int R2>\n    -unspecified-return-type- swap_rows();\n\n} }\n----\n====\n\nThe expression `swap_rows<R1,R2>(m)` returns an lvalue <<view_proxy,view proxy>> that looks like the matrix `m` with rows `R1` and `R2` swapped.\n\n'''\n\n[[swap_cols]]\n==== `swap_cols`\n\n====\n.#include <boost/qvm/map_mat_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    template <int C1,int C2>\n    -unspecified-return-type- swap_cols();\n\n} }\n----\n====\n\nThe expression `swap_cols<C1,C2>(m)` returns an lvalue <<view_proxy,view proxy>> that looks like the matrix `m` with columns `C1` and `C2` swapped.\n\n'''\n\n[[transposed]]\n==== `transposed`\n\n====\n.#include <boost/qvm/map_mat_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    -unspecified-return-type- transposed();\n\n} }\n----\n====\n\nThe expression `transposed(m)` returns an lvalue <<view_proxy,view proxy>> that transposes the matrix `m`.\n\n'''\n\n=== Generic vector-to-matrix view proxies\n\n[[col_mat]]\n==== `col_mat`\n\n====\n.#include <boost/qvm/map_vec_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_vec<A>::value\n    template <iclass A>\n    -unspecified-return-type- col_mat( A & a );\n\n} }\n----\n====\n\nThe expression `col_mat(v)` returns an lvalue <<view_proxy,view proxy>> that accesses the vector `v` as a matrix-column.\n\n'''\n\n[[row_mat]]\n==== `row_mat`\n\n====\n.#include <boost/qvm/map_vec_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_vec<A>::value\n    template <iclass A>\n    -unspecified-return-type- row_mat( A & a );\n\n} }\n----\n====\n\nThe expression `row_mat(v)` returns an lvalue <<view_proxy,view proxy>> that accesses the vector `v` as a matrix-row.\n\n'''\n\n[[translation_mat]]\n==== `translation_mat`\n\n====\n.#include <boost/qvm/map_vec_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_vec<A>::value\n    template <iclass A>\n    -unspecified-return-type- translation_mat( A & a );\n\n} }\n----\n====\n\nThe expression `translation_mat(v)` returns an lvalue <<view_proxy,view proxy>> that accesses the vector `v` as translation matrix of size 1 + <<vec_traits,`vec_traits<A>::dim`>>.\n\n'''\n\n[[diag_mat]]\n==== `diag_mat`\n\n====\n.#include <boost/qvm/map_vec_mat.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_vec<A>::value\n    template <iclass A>\n    -unspecified-return-type- diag_mat( A & a );\n\n} }\n----\n====\n\nThe expression `diag_mat(v)` returns an lvalue <<view_proxy,view proxy>> that accesses the vector `v` as a square matrix of the same dimensions in which the elements of `v` appear as the main diagonal and all other elements are zero.\n\nTIP: If `v` is a 3D vector, the expression `diag_mat(XYZ1(v))` can be used as a scaling 4D matrix.\n\n'''\n\n=== Generic matrix-to-vector view proxies\n\n[[col]]\n==== `col`\n\n====\n.#include <boost/qvm/map_mat_vec.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value\n    template <int C,class A>\n    -unspecified-return-type- col( A & a );\n\n} }\n----\n====\n\nThe expression `col<C>(m)` returns an lvalue <<view_proxy,view proxy>> that accesses column `C` of the matrix `m` as a vector.\n\n'''\n\n[[row]]\n==== `row`\n\n====\n.#include <boost/qvm/map_mat_vec.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value\n    template <int C,class A>\n    -unspecified-return-type- row( A & a );\n\n} }\n----\n====\n\nThe expression `row<R>(m)` returns an lvalue <<view_proxy,view proxy>> that accesses row `R` of the matrix `m` as a vector.\n\n'''\n\n[[diag]]\n==== `diag`\n\n====\n.#include <boost/qvm/map_mat_vec.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if: is_mat<A>::value\n    template <class A>\n    -unspecified-return-type- diag( A & a );\n\n} }\n----\n====\n\nThe expression `diag(m)` returns an lvalue <<view_proxy,view proxy>> that accesses the main diagonal of the matrix `m` as a vector.\n\n'''\n\n[[translation]]\n==== `translation`\n\n====\n.#include <boost/qvm/map_mat_vec.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    //Only enabled if:\n    //  is_mat<A>::value &&\n    //  mat_traits<A>::rows==mat_traits<A>::cols && mat_traits<A>::rows>=3\n    template <class A>\n    -unspecified-return-type- translation( A & a );\n\n} }\n----\n====\n\nThe expression `translation(m)` returns an lvalue <<view_proxy,view proxy>> that accesses the translation component of the square matrix `m`, which is a vector of size `D`-1, where `D` is the size of `m`.\n\n'''\n\n=== Exceptions\n\n[[error]]\n==== `error`\n\n====\n.#include <boost/qvm/error.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    struct error: virtual boost::exception, virtual std::exception { };        \n\n} }\n----\n====\n\nThis is the base for all exceptions thorwn by Boost QVM.\n\n'''\n\n[[zero_magnitude_error]]\n==== `zero_magnitude_error`\n\n====\n.#include <boost/qvm/error.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    struct zero_magnitude_error: virtual error { };        \n\n} }\n----\n====\n\nThis exception indicates that an operation requires a vector or a quaternion with non-zero magnitude, but the computed magnitude is zero.\n\n'''\n\n[[zero_determinant_error]]\n==== `zero_determinant_error`\n\n====\n.#include <boost/qvm/error.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    struct zero_determinant_error: virtual error { };        \n\n} }\n----\n====\n\nThis exception indicates that an operation requires a matrix with non-zero determinant, but the computed determinant is zero.\n\n'''\n\n=== Macros and configuration: BOOST_QVM_\n\n[[BOOST_QVM_INLINE]]\n==== `INLINE`\n===== `BOOST_QVM_INLINE`\n\n====\n.#include <boost/qvm/inline.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    #ifndef BOOST_QVM_INLINE\n    #define BOOST_QVM_INLINE inline\n    #endif\n\n} }\n----\n====\n\nThis macro is not used directly by Boost QVM, except as the default value of other macros from `<boost/qvm/inline.hpp>`. A user-defined `BOOST_QVM_INLINE` should expand to a value that is valid substitution of the `inline` keyword in function definitions.\n\n'''\n\n[[BOOST_QVM_FORCE_INLINE]]\n==== `FORCE_INLINE`\n===== `BOOST_QVM_FORCE_INLINE`\n\n====\n.#include <boost/qvm/inline.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    #ifndef BOOST_QVM_FORCE_INLINE\n    #define BOOST_QVM_FORCE_INLINE /*platform-specific*/\n    #endif\n\n} }\n----\n====\n\nThis macro is not used directly by Boost QVM, except as the default value of other macros from `<boost/qvm/inline.hpp>`. A user-defined `BOOST_QVM_FORCE_INLINE` should expand to a value that is valid substitution of the `inline` keyword in function definitions, to indicate that the compiler must inline the function. Of course, actual inlining may or may not occur.\n\n'''\n\n[[BOOST_QVM_INLINE_TRIVIAL]]\n==== `INLINE_TRIVIAL`\n===== `BOOST_QVM_INLINE_TRIVIAL`\n\n====\n.#include <boost/qvm/inline.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    #ifndef BOOST_QVM_INLINE_TRIVIAL\n    #define BOOST_QVM_INLINE_TRIVIAL BOOST_QVM_FORCE_INLINE\n    #endif\n\n} }\n----\n====\n\nBoost QVM uses `BOOST_QVM_INLINE_TRIVIAL` in definitions of functions that are not critical for the overall performance of the library but are extremely simple (such as one-liners) and therefore should always be inlined.\n\n'''\n\n[[BOOST_QVM_INLINE_CRITICAL]]\n==== `INLINE_CRITICAL`\n===== `BOOST_QVM_INLINE_CRITICAL`\n\n====\n.#include <boost/qvm/inline.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    #ifndef BOOST_QVM_INLINE_CRITICAL\n    #define BOOST_QVM_INLINE_CRITICAL BOOST_QVM_FORCE_INLINE\n    #endif\n\n} }\n----\n====\n\nBoost QVM uses `BOOST_QVM_INLINE_CRITICAL` in definitions of functions that are critical for the overall performance of the library, such as functions that access individual vector and matrix elements.\n\n'''\n\n[[BOOST_QVM_INLINE_OPERATIONS]]\n==== `INLINE_OPERATIONS`\n===== `BOOST_QVM_INLINE_OPERATIONS`\n\n====\n.#include <boost/qvm/inline.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    #ifndef BOOST_QVM_INLINE_OPERATIONS\n    #define BOOST_QVM_INLINE_OPERATIONS BOOST_QVM_INLINE\n    #endif\n\n} }\n----\n====\n\nBoost QVM uses `BOOST_QVM_INLINE_OPERATIONS` in definitions of functions that implement various high-level operations, such as matrix multiplication, computing the magnitude of a vector, etc.\n\n'''\n\n[[BOOST_QVM_INLINE_RECURSION]]\n==== `INLINE_RECURSION`\n===== `BOOST_QVM_INLINE_RECURSION`\n\n====\n.#include <boost/qvm/inline.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    #ifndef BOOST_QVM_INLINE_RECURSION\n    #define BOOST_QVM_INLINE_RECURSION BOOST_QVM_INLINE_OPERATIONS\n    #endif\n\n} }\n----\n====\n\nBoost QVM uses `BOOST_QVM_INLINE_RECURSION` in definitions of recursive functions that are not critical for the overall performance of the library (definitions of all critical functions, including critical recursive functions, use <<BOOST_QVM_INLINE_CRITICAL,`BOOST_QVM_INLINE_CRITICAL`>>).\n\n'''\n\n[[BOOST_QVM_ASSERT]]\n==== `ASSERT`\n===== `BOOST_QVM_ASSERT`\n\n====\n.#include <boost/qvm/assert.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n#ifndef BOOST_QVM_ASSERT\n#include <boost/assert.hpp>\n#define BOOST_QVM_ASSERT BOOST_ASSERT\n#endif\n\n} }\n----\n====\n\nThis is the macro Boost QVM uses to assert on precondition violations and logic errors. A user-defined `BOOST_QVM_ASSERT` should have the semantics of the standard `assert`.\n\n'''\n\n[[BOOST_QVM_STATIC_ASSERT]]\n==== `STATIC_ASSERT`\n===== `BOOST_QVM_STATIC_ASSERT`\n\n====\n.#include <boost/qvm/static_assert.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    #ifndef BOOST_QVM_STATIC_ASSERT\n    #include <boost/static_assert.hpp>\n    #define BOOST_QVM_STATIC_ASSERT BOOST_STATIC_ASSERT\n    #endif\n\n} }\n----\n====\n\nAll static assertions in Boost QVM use the `BOOST_QVM_STATIC_ASSERT` macro.\n\n'''\n\n[[BOOST_QVM_THROW_EXCEPTION]]\n==== `THROW_EXCEPTION`\n===== `BOOST_QVM_THROW_EXCEPTION`\n\n====\n.#include <boost/qvm/throw_exception.hpp>\n[source,c++]\n----\nnamespace boost { namespace qvm {\n\n    #ifndef BOOST_QVM_THROW_EXCEPTION\n    #include <boost/throw_exception.hpp>\n    #define BOOST_QVM_THROW_EXCEPTION BOOST_THROW_EXCEPTION\n    #endif\n\n} }\n----\n====\n\nThis macro is used whenever Boost QVM throws an exception. Users who override the standard `BOOST_QVM_THROW_EXCEPTION` behavior must ensure that when invoked, the substituted implementation does not return control to the caller. Below is a list of all QVM functions that invoke `BOOST_QVM_THROW_EXCEPTION`:\n\n* Quaternion operations:\n** <<quat_inverse,`inverse`>>\n** <<rot_quat,`rot_quat`>>\n** <<quat_normalize,`normalize`>>\n** <<quat_normalized,`normalized`>>\n* Vector operations:\n** <<vec_normalize,`normalize`>>\n** <<vec_normalized,`normalized`>>\n* Matrix operations:\n** <<mat_inverse,`inverse`>>\n** <<rot_mat,`rot_mat`>>\n\n== Design rationale\n\nIn graphics and simulation applications, there is a need for a library that makes it easy to perform 2D and 3D transformations efficiently. {CPP} makes it possible to define vector and matrix types and to overload various operators to implement the standard algebraic operations. Because this is a relatively straightforward process, there are many such libraries in existence, each with its own types and operator overrloads. Such libraries are typically part of a higher level system, such as a graphics engine or a 3D modeling API. As a result, it is typical for programmers to have to integrate and to translate between several different quaternion, vector and matrix types that come with the various APIs they use.\n\nOn the other hand, performance considerations often lead to matrix and vector types becoming coupled with a particular platform, or to (over time) acquire various `#ifdefs` needed to enable optimizations through platform-specific compiler features that control the physical format or layout of their elements. But such optimizations may interfere with ease of use and portability; for example on some platforms requiring 16-byte alignment for matrix types makes them incompatible with standard containers.\n\nBoost QVM solves both of these issues by decoupling the standard algebraic functions from the types they operate on -- without compromising type safety.\n\nKey design features of Boost QVM:\n\n- Emphasis on 2, 3 and 4-dimensional operations (including quaternions and zero-overhead <<swizzling,swizzling>>) as needed in graphics and simulation applications.\n\n- Zero-overhead <<view_proxy,view proxies>> that can be used to access any object with quaternion, vector or matrix semantics through a read-only or lvalue reference of a different type. For example, `<<col,col>><C>(m)` binds the `C`-th column of a matrix `m` as a mutable vector type without the overhead of a temporary.\n\n- Integration of various user-defined or 3rd-party quaternion, vector or matrix types into a coherent type-safe system. This enables the user to build algebraic expressions using objects of diverse types that would otherwise be incompatible.\n\n- When users need to implement platform-specific or even project-specific optimizations in a given subsystem, Boost QVM makes it simple to define custom new types that automatically aquire the full set of algebraic operations so they can interface seamlessly with the rest of the program. At the same time, the user can define a limited number of overloads for the new types as needed to implement specific optimizations.\n\n== Code generator\n\nWhile Boost QVM defines generic functions that operate on matrix and vector types of arbitrary static dimensions, it also provides a code generator that can be used to create compatible header files that define much simpler specializations of these functions for specific dimensions. This is useful during debugging since the generated code is much easier to read than the template metaprogramming-heavy generic implementations. It is also potentially friendlier to the optimizer.\n\nThe code generator is a command-line utility program. Its source code can be found in the `boost/libs/qvm/gen` directory. It was used to generate the following headers that ship with Boost QVM:\n\n* 2D, 3D and 4D matrix operations:\n** `boost/qvm/gen/mat_operations2.hpp` (matrices of size 2x2, 2x1 and 1x2, included by `boost/qvm/mat_operations2.hpp`)\n** `boost/qvm/gen/mat_operations3.hpp` (matrices of size 3x3, 3x1 and 1x3, included by `boost/qvm/mat_operations3.hpp`)\n** `boost/qvm/gen/mat_operations4.hpp` (matrices of size 4x4, 4x1 and 1x4, included by `boost/qvm/mat_operations4.hpp`)\n* 2D, 3D and 4D vector operations:\n** `boost/qvm/gen/v2.hpp` (included by `boost/qvm/vec_operations2.hpp`)\n** `boost/qvm/gen/v3.hpp` (included by `boost/qvm/vec_operations3.hpp`)\n** `boost/qvm/gen/v4.hpp` (included by `boost/qvm/vec_operations4.hpp`)\n* 2D, 3D and 4D vector-matrix operations:\n** `boost/qvm/gen/vm2.hpp` (included by `boost/qvm/vec_mat_operations2.hpp`)\n** `boost/qvm/gen/vm3.hpp` (included by `boost/qvm/vec_mat_operations3.hpp`)\n** `boost/qvm/gen/vm4.hpp` (included by `boost/qvm/vec_mat_operations4.hpp`)\n* 2D, 3D and 4D vector swizzling operations:\n** `boost/qvm/gen/sw2.hpp` (included by `boost/qvm/swizzle2.hpp`)\n** `boost/qvm/gen/sw3.hpp` (included by `boost/qvm/swizzle3.hpp`)\n** `boost/qvm/gen/sw4.hpp` (included by `boost/qvm/swizzle4.hpp`)\n\nAny such generated headers must be included before the corresponding generic header file is included. For example, if one creates a header `boost/qvm/gen/m5.hpp`, it must be included before `boost/qvm/mat_operations.hpp` in included. However, the generic headers (`boost/qvm/mat_operations.hpp`, `boost/qvm/vec_operations.hpp`, `boost/qvm/vec_mat_operations.hpp` and `boost/qvm/swizzle.hpp`) already include the generated headers from the list above, so the generated headers don't need to be included manually.\n\nNOTE: headers under `boost/qvm/gen` are not part of the public interface of Boost QVM. For example, `boost/qvm/gen/mat_operations2.hpp` should not be included directly; `#include <boost/qvm/mat_operations2.hpp>` instead.\n\n== Known quirks and issues\n\n=== Capturing view proxies with `auto`\n\nBy design, <<view_proxy,view proxies>> must not return temporary objects. They return reference to an argument they take by (`const`) reference, cast to reference of unspecified type that is not copyable. Because of this, the return value of a view proxy can not be captured by value with `auto`:\n\n[source,c++]\n----\nauto tr = transposed(m); //Error: the return type of transposed can not be copied.\n----\n\nThe correct use of auto with view proxies is:\n\n[source,c++]\n----\nauto & tr = transposed(m);\n----\n\nNOTE: Many view proxies are not read-only, that is, they're lvalues; changes made on the view proxy operate on the original object. This is another reason why they can not be captured by value with  `auto`.\n\n'''\n\n=== Binding QVM overloads from an unrelated namespace\n\nThe operator overloads in namespace `boost::qvm` are designed to work with user-defined types. Typically it is sufficient to make these operators available in the namespace where the operator is used, by `using namespace boost::qvm`. A problem arises if the scope that uses the operator is not controlled by the user. For example:\n\n[source,c++]\n----\nnamespace ns1 {\n\n    struct float2 { float x, y; };\n    \n}\n\nnamespace ns2 {\n\n    using namespace boost::qvm;\n\n    void f() {\n        ns1::float2 a, b;\n        a==b; //OK\n        ns1::float2 arr1[2], arr2[2];\n        std::equal(arr1,arr1+2,arr2); //Error: operator== is inaccessible from namespace std\n    }\n\n}\n----\n\nIn the `std::equal` expression above, even though `boost::qvm::operator==` is made visible in namespace `ns2` by `using namespace boost::qvm`, the call originates from namespace `std`. In this case the compiler can't bind `boost::qvm::operator==` because only namespace `ns1` is visible through ADL, and it does not contain a suitable declaration. The solution is to declare `operator==` in namespace ns1, which can be done like this:\n\n[source,c++]\n----\nnamespace ns1 {\n\n    using boost::qvm::operator==;\n\n}\n----\n\n'''\n\n=== Link errors when calling math functions with int arguments\n\nBoost QVM does not call standard math functions (e.g. sin, cos, etc.) directly. Instead, it calls function templates declared in `boost/qvm/math.hpp` in namespace `boost::qvm`. This allows the user to specialize these templates for user-defined scalar types.\n\nBoost QVM itself defines specializations of the math function templates only for `float` and `double`, but it does not provide generic definitions. This is done to protect the user from unintentionally writing code that binds standard math functions that take `double` when passing arguments of lesser types, which would be suboptimal.\n\nBecause of this, a call to e.g. `<<rot_mat,rot_mat>>(axis,1)` will compile successfully but fail to link, since it calls e.g. `boost::qvm::sin<int>`, which is undefined. Because rotations by integer number of radians are rarely needed, in QVM there is no protection against such errors. In such cases the solution is to use `rot_mat(axis,1.0f)` instead.\n\n== Q&A\n\n[qanda]\nWhat is the motivation behind Boost QVM? Why not just use uBLAS/Eigen/CML/GLM/etc?:: The primary domain of Boost QVM is realtime graphics and simulation applications, so it is not a complete linear algebra library. While (naturally) there is some overlap with such libraries, QVM puts the emphasis on 2, 3 and 4 dimensional zero-overhead operations (hence domain-specific features like Swizzling).\n\nHow does the `qvm::<<vec,vec>>` (or `qvm::<<mat,mat>>`, or `qvm::<<quat,quat>>`) template compare to vector types from other libraries?:: The `qvm::vec` template is not in any way central to the vector operations defined by QVM. The operations are designed to work with any user-defined vector type or with 3rd-party vector types (e.g. `D3DVECTOR`), while the `qvm::vec` template is simply a default return type for expressions that use arguments of different types that would be incompatible outside of QVM. For example, if the <<deduce_mat2,`deduce_mat2`>> hasn't been specialized, calling <<cross,`cross`>> with a user-defined type `vec3` and a user-defined type `float3` returns a `qvm::vec`.\n\nWhy doesn't QVM use [] or () to access vector and matrix elements?:: Because it's designed to work with user-defined types, and the {CPP} standard requires these operators to be members. Of course if a user-defined type defines `operator[]` or `operator()` they are available for use with other QVM functions, but QVM defines its own mechanisms for <<quat_access,accessing quaternion elements>>, <<vec_access,accessing vector elements>> (as well as <<swizzling,swizzling>>), and <<mat_access,accessing matrix elements>>.\n\n'''\n\n[.text-right]\n(C) 2008-2018 Emil Dotchevski and Reverge Studios, Inc.\n",
  "versions": [
    {
      "ref": "master",
      "manifest": "targets = [ \"//:qvm\" ]\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-assert\"\nversion = \"branch=master\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-core\"\nversion = \"branch=master\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-exception\"\nversion = \"branch=master\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-static_assert\"\nversion = \"branch=master\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-throw_exception\"\nversion = \"branch=master\"\n",
      "lockFile": "manifest = \"0fd25a8cc53906ed1a61bf81251e26683be1d649a50f725c442416de7596135c\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-assert\"\ntarget = \"//:assert\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-core\"\ntarget = \"//:core\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-exception\"\ntarget = \"//:exception\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-static_assert\"\ntarget = \"//:static-assert\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/boost-throw_exception\"\ntarget = \"//:throw-exception\"\n\n[lock.\"github.com/buckaroo-pm/boost-assert\"]\nversions = [ \"branch=master\" ]\nrevision = \"f9d6a7b63ef2902777b6078fdebc54e7a57aac03\"\n\n[lock.\"github.com/buckaroo-pm/boost-config\"]\nversions = [ \"branch=master\" ]\nrevision = \"4392ed19b232ed2dde7623843d7e30ef669d860e\"\n\n[lock.\"github.com/buckaroo-pm/boost-core\"]\nversions = [ \"branch=master\" ]\nrevision = \"84411b155dae6f08ea749bdeb1e71aecd0718d52\"\n\n[lock.\"github.com/buckaroo-pm/boost-detail\"]\nversions = [ \"branch=master\" ]\nrevision = \"e8b834a93f7ba935aa63a3d6690804f3bd2b0963\"\n\n[lock.\"github.com/buckaroo-pm/boost-exception\"]\nversions = [ \"branch=master\" ]\nrevision = \"c43bde6de716aeaa1958f523576599c384791da2\"\n\n[lock.\"github.com/buckaroo-pm/boost-preprocessor\"]\nversions = [ \"branch=master\" ]\nrevision = \"4d01d0f9c0ae3ae3cd20e3cbfddbc9909ce8e064\"\n\n[lock.\"github.com/buckaroo-pm/boost-static_assert\"]\nversions = [ \"branch=master\" ]\nrevision = \"fdc2df7f811436674a1c55c766b8830a8cd02e96\"\n\n[lock.\"github.com/buckaroo-pm/boost-throw_exception\"]\nversions = [ \"branch=master\" ]\nrevision = \"3951e0ca1d6b909bbc815858acbe2449c4a53eed\"\n\n[lock.\"github.com/buckaroo-pm/boost-type_traits\"]\nversions = [ \"branch=master\" ]\nrevision = \"4d0a507c0d1a1011c5a98d57acc9f6b755141e4f\"\n\n[lock.\"github.com/buckaroo-pm/boost-utility\"]\nversions = [ \"branch=master\" ]\nrevision = \"f04cf922658a7e03776631a96c3ad346ad179d5f\"\n",
      "buck": "load('//:buckaroo_macros.bzl', 'buckaroo_deps')\nload('//:subdir_glob.bzl', 'subdir_glob')\n\nprebuilt_cxx_library(\n  name = 'qvm',\n  header_only = True,\n  header_namespace = 'boost',\n  exported_headers = subdir_glob([\n    ('include/boost', '**/*.hpp'),\n  ]),\n  deps = buckaroo_deps(),\n  visibility = [\n    'PUBLIC',\n  ],\n)\n",
      "bazel": "",
      "deps": [
        {
          "uri": "github.com/buckaroo-pm/boost-assert",
          "name": "buckaroo-pm/boost-assert",
          "version": "branch=master"
        },
        {
          "uri": "github.com/buckaroo-pm/boost-core",
          "name": "buckaroo-pm/boost-core",
          "version": "branch=master"
        },
        {
          "uri": "github.com/buckaroo-pm/boost-exception",
          "name": "buckaroo-pm/boost-exception",
          "version": "branch=master"
        },
        {
          "uri": "github.com/buckaroo-pm/boost-static_assert",
          "name": "buckaroo-pm/boost-static_assert",
          "version": "branch=master"
        },
        {
          "uri": "github.com/buckaroo-pm/boost-throw_exception",
          "name": "buckaroo-pm/boost-throw_exception",
          "version": "branch=master"
        }
      ],
      "lock": [
        {
          "uri": "github.com/buckaroo-pm/boost-assert",
          "name": "buckaroo-pm/boost-assert",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "f9d6a7b63ef2902777b6078fdebc54e7a57aac03"
          }
        },
        {
          "uri": "github.com/buckaroo-pm/boost-config",
          "name": "buckaroo-pm/boost-config",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "4392ed19b232ed2dde7623843d7e30ef669d860e"
          }
        },
        {
          "uri": "github.com/buckaroo-pm/boost-core",
          "name": "buckaroo-pm/boost-core",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "84411b155dae6f08ea749bdeb1e71aecd0718d52"
          }
        },
        {
          "uri": "github.com/buckaroo-pm/boost-detail",
          "name": "buckaroo-pm/boost-detail",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "e8b834a93f7ba935aa63a3d6690804f3bd2b0963"
          }
        },
        {
          "uri": "github.com/buckaroo-pm/boost-exception",
          "name": "buckaroo-pm/boost-exception",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "c43bde6de716aeaa1958f523576599c384791da2"
          }
        },
        {
          "uri": "github.com/buckaroo-pm/boost-preprocessor",
          "name": "buckaroo-pm/boost-preprocessor",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "4d01d0f9c0ae3ae3cd20e3cbfddbc9909ce8e064"
          }
        },
        {
          "uri": "github.com/buckaroo-pm/boost-static_assert",
          "name": "buckaroo-pm/boost-static_assert",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "fdc2df7f811436674a1c55c766b8830a8cd02e96"
          }
        },
        {
          "uri": "github.com/buckaroo-pm/boost-throw_exception",
          "name": "buckaroo-pm/boost-throw_exception",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "3951e0ca1d6b909bbc815858acbe2449c4a53eed"
          }
        },
        {
          "uri": "github.com/buckaroo-pm/boost-type_traits",
          "name": "buckaroo-pm/boost-type_traits",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "4d0a507c0d1a1011c5a98d57acc9f6b755141e4f"
          }
        },
        {
          "uri": "github.com/buckaroo-pm/boost-utility",
          "name": "buckaroo-pm/boost-utility",
          "spec": {
            "versions": [
              "branch=master"
            ],
            "revision": "f04cf922658a7e03776631a96c3ad346ad179d5f"
          }
        }
      ]
    }
  ],
  "updated": "2019-02-01T17:22:51Z",
  "updatedUpstream": "2020-12-24T06:15:47Z",
  "contributors": [
    {
      "login": "danieljames",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/7543?v=4"
    },
    {
      "login": "giomasce",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/101675?v=4"
    },
    {
      "login": "dlm",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/163419?v=4"
    },
    {
      "login": "mclow",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/167192?u=2aa259cac18f2121fec31e4e0e982ae454891b0c&v=4"
    },
    {
      "login": "purpleKarrot",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/185240?u=1e460c214ce0f4d75441a7456e69f474942c75d7&v=4"
    },
    {
      "login": "ericniebler",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/225757?v=4"
    },
    {
      "login": "vprus",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/225915?v=4"
    },
    {
      "login": "Beman",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/226112?v=4"
    },
    {
      "login": "mjcaisse",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/230295?u=03f8b6d6c0a2fe63b6d14f5c42e80c8c58ba56cc&v=4"
    },
    {
      "login": "zajo",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/609498?u=0f337111ad705da5bc80d505b24f019832b2ce0a&v=4"
    },
    {
      "login": "ldionne",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/700834?u=3d2dd80d43f96e6fd22219498790622944a25f19&v=4"
    },
    {
      "login": "glenfe",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/712180?u=f15319dfd6ca8062678725e9510d916b821db766&v=4"
    },
    {
      "login": "awulkiew",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/1226951?v=4"
    },
    {
      "login": "Kojoley",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/2743474?v=4"
    },
    {
      "login": "pdimov",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/3116174?v=4"
    },
    {
      "login": "jzmaddock",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/5011768?v=4"
    },
    {
      "login": "DionHo",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/10433608?v=4"
    },
    {
      "login": "agate-pris",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/12880631?u=c80b38181772e546fc82706cf779ad82b0436426&v=4"
    },
    {
      "login": "traviscibot",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/33116358?u=2e4c996d9e7d5f883d638b01f063e5dee363ecdd&v=4"
    }
  ],
  "fundingLinks": [],
  "contactLinks": [],
  "stars": 49,
  "forks": 24,
  "topics": []
}