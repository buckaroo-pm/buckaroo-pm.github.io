<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/google-benchmark/logo.png"/></div><div><h1>buckaroo-pm/google-benchmark</h1><div style="max-width:600px">A microbenchmark support library</div><br/><div><b>5064</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">benchmark</span></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><h1>Benchmark</h1><p><a href="https://travis-ci.org/google/benchmark"><img src="https://travis-ci.org/google/benchmark.svg?branch=master" alt="Build Status"/></a>
<a href="https://ci.appveyor.com/project/google/benchmark/branch/master"><img src="https://ci.appveyor.com/api/projects/status/u0qsyp7t1tk7cpxs/branch/master?svg=true" alt="Build status"/></a>
<a href="https://coveralls.io/r/google/benchmark"><img src="https://coveralls.io/repos/google/benchmark/badge.svg" alt="Coverage Status"/></a>
<a href="https://slackin-iqtfqnpzxd.now.sh/"><img src="https://slackin-iqtfqnpzxd.now.sh/badge.svg" alt="slackin"/></a></p><p>A library to benchmark code snippets, similar to unit tests. Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#include &lt;benchmark/benchmark.h&gt;
</span>
<!-- -->static void BM_SomeFunction(benchmark::State&amp; state) {
<!-- -->  // Perform setup here
<!-- -->  for (auto _ : state) {
<!-- -->    // This code gets timed
<!-- -->    SomeFunction();
<!-- -->  }
<!-- -->}
<!-- -->// Register the function as a benchmark
<!-- -->BENCHMARK(BM_SomeFunction);
<!-- -->// Run the benchmark
<!-- -->BENCHMARK_MAIN();
</code></pre><p>To get started, see <a href="#requirements">Requirements</a> and
<a href="#installation">Installation</a>. See <a href="#usage">Usage</a> for a full example and the
<a href="#user-guide">User Guide</a> for a more comprehensive feature overview.</p><p>It may also help to read the <a href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md">Google Test documentation</a>
as some of the structural aspects of the APIs are similar.</p><h3>Resources</h3><p><a href="https://groups.google.com/d/forum/benchmark-discuss">Discussion group</a></p><p>IRC channel: <a href="https://freenode.net">freenode</a> #googlebenchmark</p><p><a href="docs/tools.md">Additional Tooling Documentation</a></p><p><a href="docs/AssemblyTests.md">Assembly Testing Documentation</a></p><h2>Requirements</h2><p>The library can be used with C++03. However, it requires C++11 to build,
including compiler and standard library support.</p><p>The following minimum versions are required to build the library:</p><ul><li>GCC 4.8</li><li>Clang 3.4</li><li>Visual Studio 14 2015</li><li>Intel 2015 Update 1</li></ul><h2>Installation</h2><p>This describes the installation process using cmake. As pre-requisites, you&#x27;ll
need git and cmake installed.</p><p><em>See <a href="dependencies.md">dependencies.md</a> for more details regarding supported
versions of build tools.</em></p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-bash" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:slategray"># Check out the library.</span><span>
</span><span>$ </span><span class="token" style="color:#DD4A68">git</span><span> clone https://github.com/google/benchmark.git
</span><span></span><span class="token" style="color:slategray"># Benchmark requires Google Test as a dependency. Add the source tree as a subdirectory.</span><span>
</span><span>$ </span><span class="token" style="color:#DD4A68">git</span><span> clone https://github.com/google/googletest.git benchmark/googletest
</span><span></span><span class="token" style="color:slategray"># Go to the library root directory</span><span>
</span><span>$ </span><span class="token" style="color:#DD4A68">cd</span><span> benchmark
</span><span></span><span class="token" style="color:slategray"># Make a build directory to place the build output.</span><span>
</span><span>$ </span><span class="token" style="color:#DD4A68">mkdir</span><span> build </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;&amp;</span><span> </span><span class="token" style="color:#DD4A68">cd</span><span> build
</span><span></span><span class="token" style="color:slategray"># Generate a Makefile with cmake.</span><span>
</span><span></span><span class="token" style="color:slategray"># Use cmake -G &lt;generator&gt; to generate a different file type.</span><span>
</span><span>$ cmake </span><span class="token" style="color:#999">..</span><span>/
</span><span></span><span class="token" style="color:slategray"># Build the library.</span><span>
</span><span></span><span class="token" style="color:slategray"># Use make -j&lt;number_of_parallel_jobs&gt; to speed up the build process, e.g. make -j8 .</span><span>
</span><span>$ </span><span class="token" style="color:#DD4A68">make</span></code></pre><p>This builds the <code>benchmark</code> and <code>benchmark_main</code> libraries and tests.
On a unix system, the build directory should now look something like this:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>/benchmark
</span>  /build
<!-- -->    /src
<!-- -->      /libbenchmark.a
<!-- -->      /libbenchmark_main.a
<!-- -->    /test
<!-- -->      ...
</code></pre><p>Next, you can run the tests to check the build.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-bash" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>$ </span><span class="token" style="color:#DD4A68">make</span><span> </span><span class="token" style="color:#DD4A68">test</span></code></pre><p>If you want to install the library globally, also run:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>sudo make install</span></code></pre><p>Note that Google Benchmark requires Google Test to build and run the tests. This
dependency can be provided two ways:</p><ul><li>Checkout the Google Test sources into <code>benchmark/googletest</code> as above.</li><li>Otherwise, if <code>-DBENCHMARK_DOWNLOAD_DEPENDENCIES=ON</code> is specified during
configuration, the library will automatically download and build any required
dependencies.</li></ul><p>If you do not wish to build and run the tests, add <code>-DBENCHMARK_ENABLE_GTEST_TESTS=OFF</code>
to <code>CMAKE_ARGS</code>.</p><h3>Debug vs Release</h3><p>By default, benchmark builds as a debug library. You will see a warning in the
output when this is the case. To build it as a release library instead, use:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cmake -DCMAKE_BUILD_TYPE=Release</span></code></pre><p>To enable link-time optimisation, use</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cmake -DCMAKE_BUILD_TYPE=Release -DBENCHMARK_ENABLE_LTO=true</span></code></pre><p>If you are using gcc, you might need to set <code>GCC_AR</code> and <code>GCC_RANLIB</code> cmake
cache variables, if autodetection fails.</p><p>If you are using clang, you may need to set <code>LLVMAR_EXECUTABLE</code>,
<code>LLVMNM_EXECUTABLE</code> and <code>LLVMRANLIB_EXECUTABLE</code> cmake cache variables.</p><h3>Stable and Experimental Library Versions</h3><p>The main branch contains the latest stable version of the benchmarking library;
the API of which can be considered largely stable, with source breaking changes
being made only upon the release of a new major version.</p><p>Newer, experimental, features are implemented and tested on the
<a href="https://github.com/google/benchmark/tree/v2"><code>v2</code> branch</a>. Users who wish
to use, test, and provide feedback on the new features are encouraged to try
this branch. However, this branch provides no stability guarantees and reserves
the right to change and break the API at any time.</p><h2>Usage</h2><h3>Basic usage</h3><p>Define a function that executes the code to measure, register it as a benchmark
function using the <code>BENCHMARK</code> macro, and ensure an appropriate <code>main</code> function
is available:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#include &lt;benchmark/benchmark.h&gt;
</span>
<!-- -->static void BM_StringCreation(benchmark::State&amp; state) {
<!-- -->  for (auto _ : state)
<!-- -->    std::string empty_string;
<!-- -->}
<!-- -->// Register the function as a benchmark
<!-- -->BENCHMARK(BM_StringCreation);
<!-- -->
<!-- -->// Define another benchmark
<!-- -->static void BM_StringCopy(benchmark::State&amp; state) {
<!-- -->  std::string x = &quot;hello&quot;;
<!-- -->  for (auto _ : state)
<!-- -->    std::string copy(x);
<!-- -->}
<!-- -->BENCHMARK(BM_StringCopy);
<!-- -->
<!-- -->BENCHMARK_MAIN();
</code></pre><p>To run the benchmark, compile and link against the <code>benchmark</code> library
(libbenchmark.a/.so). If you followed the build steps above, this
library will be under the build directory you created.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-bash" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:slategray"># Example on linux after running the build steps above. Assumes the</span><span>
</span><span></span><span class="token" style="color:slategray"># `benchmark` and `build` directories are under the current directory.</span><span>
</span><span>$ g++ -std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span>c++11 -isystem benchmark/include -Lbuild/src -lpthread </span><span class="token" style="color:#999">\</span><span>
</span>  -lbenchmark mybenchmark.cc -o mybenchmark
</code></pre><p>Alternatively, link against the <code>benchmark_main</code> library and remove
<code>BENCHMARK_MAIN();</code> above to get the same behavior.</p><p>The compiled executable will run all benchmarks by default. Pass the <code>--help</code>
flag for option information or see the guide below.</p><h3>Platform-specific instructions</h3><p>When the library is built using GCC it is necessary to link with the pthread
library due to how GCC implements <code>std::thread</code>. Failing to link to pthread will
lead to runtime exceptions (unless you&#x27;re using libc++), not linker errors. See
<a href="https://github.com/google/benchmark/issues/67">issue #67</a> for more details. You
can link to pthread by adding <code>-pthread</code> to your linker command. Note, you can
also use <code>-lpthread</code>, but there are potential issues with ordering of command
line parameters if you use that.</p><p>If you&#x27;re running benchmarks on Windows, the shlwapi library (<code>-lshlwapi</code>) is
also required.</p><p>If you&#x27;re running benchmarks on solaris, you&#x27;ll want the kstat library linked in
too (<code>-lkstat</code>).</p><h2>User Guide</h2><h3>Command Line</h3><p><a href="#output-formats">Output Formats</a></p><p><a href="#output-files">Output Files</a></p><p><a href="#running-a-subset-of-benchmarks">Running a Subset of Benchmarks</a></p><p><a href="#result-comparison">Result Comparison</a></p><h3>Library</h3><p><a href="#runtime-and-reporting-considerations">Runtime and Reporting Considerations</a></p><p><a href="#passing-arguments">Passing Arguments</a></p><p><a href="#asymptotic-complexity">Calculating Asymptotic Complexity</a></p><p><a href="#templated-benchmarks">Templated Benchmarks</a></p><p><a href="#fixtures">Fixtures</a></p><p><a href="#custom-counters">Custom Counters</a></p><p><a href="#multithreaded-benchmarks">Multithreaded Benchmarks</a></p><p><a href="#cpu-timers">CPU Timers</a></p><p><a href="#manual-timing">Manual Timing</a></p><p><a href="#setting-the-time-unit">Setting the Time Unit</a></p><p><a href="#preventing-optimization">Preventing Optimization</a></p><p><a href="#reporting-statistics">Reporting Statistics</a></p><p><a href="#custom-statistics">Custom Statistics</a></p><p><a href="#using-register-benchmark">Using RegisterBenchmark</a></p><p><a href="#exiting-with-an-error">Exiting with an Error</a></p><p><a href="#a-faster-keep-running-loop">A Faster KeepRunning Loop</a></p><p><a href="#disabling-cpu-frequency-scaling">Disabling CPU Frequency Scaling</a></p>&lt;a name=&quot;output-formats&quot; /&gt;<h3>Output Formats</h3><p>The library supports multiple output formats. Use the
<code>--benchmark_format=&lt;console|json|csv&gt;</code> flag to set the format type. <code>console</code>
is the default format.</p><p>The Console format is intended to be a human readable format. By default
the format generates color output. Context is output on stderr and the
tabular data on stdout. Example tabular output looks like:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>Benchmark                               Time(ns)    CPU(ns) Iterations
</span>----------------------------------------------------------------------
<!-- -->BM_SetInsert/1024/1                        28928      29349      23853  133.097kB/s   33.2742k items/s
<!-- -->BM_SetInsert/1024/8                        32065      32913      21375  949.487kB/s   237.372k items/s
<!-- -->BM_SetInsert/1024/10                       33157      33648      21431  1.13369MB/s   290.225k items/s
</code></pre><p>The JSON format outputs human readable json split into two top level attributes.
The <code>context</code> attribute contains information about the run in general, including
information about the CPU and the date.
The <code>benchmarks</code> attribute contains a list of every benchmark run. Example json
output looks like:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-json" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#999">{</span><span>
</span><span>  </span><span class="token" style="color:#905">&quot;context&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>    </span><span class="token" style="color:#905">&quot;date&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#690">&quot;2015/03/17-18:40:25&quot;</span><span class="token" style="color:#999">,</span><span>
</span><span>    </span><span class="token" style="color:#905">&quot;num_cpus&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">40</span><span class="token" style="color:#999">,</span><span>
</span><span>    </span><span class="token" style="color:#905">&quot;mhz_per_cpu&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">2801</span><span class="token" style="color:#999">,</span><span>
</span><span>    </span><span class="token" style="color:#905">&quot;cpu_scaling_enabled&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">false</span><span class="token" style="color:#999">,</span><span>
</span><span>    </span><span class="token" style="color:#905">&quot;build_type&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#690">&quot;debug&quot;</span><span>
</span><span>  </span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">,</span><span>
</span><span>  </span><span class="token" style="color:#905">&quot;benchmarks&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#999">[</span><span>
</span><span>    </span><span class="token" style="color:#999">{</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;name&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#690">&quot;BM_SetInsert/1024/1&quot;</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;iterations&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">94877</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;real_time&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">29275</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;cpu_time&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">29836</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;bytes_per_second&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">134066</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;items_per_second&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">33516</span><span>
</span><span>    </span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">,</span><span>
</span><span>    </span><span class="token" style="color:#999">{</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;name&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#690">&quot;BM_SetInsert/1024/8&quot;</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;iterations&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">21609</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;real_time&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">32317</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;cpu_time&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">32429</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;bytes_per_second&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">986770</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;items_per_second&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">246693</span><span>
</span><span>    </span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">,</span><span>
</span><span>    </span><span class="token" style="color:#999">{</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;name&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#690">&quot;BM_SetInsert/1024/10&quot;</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;iterations&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">21393</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;real_time&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">32724</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;cpu_time&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">33355</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;bytes_per_second&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">1199226</span><span class="token" style="color:#999">,</span><span>
</span><span>      </span><span class="token" style="color:#905">&quot;items_per_second&quot;</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#905">299807</span><span>
</span><span>    </span><span class="token" style="color:#999">}</span><span>
</span><span>  </span><span class="token" style="color:#999">]</span><span>
</span><span></span><span class="token" style="color:#999">}</span></code></pre><p>The CSV format outputs comma-separated values. The <code>context</code> is output on stderr
and the CSV itself on stdout. Example CSV output looks like:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>name,iterations,real_time,cpu_time,bytes_per_second,items_per_second,label
</span>&quot;BM_SetInsert/1024/1&quot;,65465,17890.7,8407.45,475768,118942,
<!-- -->&quot;BM_SetInsert/1024/8&quot;,116606,18810.1,9766.64,3.27646e+06,819115,
<!-- -->&quot;BM_SetInsert/1024/10&quot;,106365,17238.4,8421.53,4.74973e+06,1.18743e+06,
</code></pre>&lt;a name=&quot;output-files&quot; /&gt;<h3>Output Files</h3><p>Write benchmark results to a file with the <code>--benchmark_out=&lt;filename&gt;</code> option.
Specify the output format with <code>--benchmark_out_format={json|console|csv}</code>. Note that Specifying
<code>--benchmark_out</code> does not suppress the console output.</p>&lt;a name=&quot;running-a-subset-of-benchmarks&quot; /&gt;<h3>Running a Subset of Benchmarks</h3><p>The <code>--benchmark_filter=&lt;regex&gt;</code> option can be used to only run the benchmarks
which match the specified <code>&lt;regex&gt;</code>. For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-bash" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>$ ./run_benchmarks.x --benchmark_filter</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span>BM_memcpy/32
</span><span>Run on </span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">1</span><span> X </span><span class="token" style="color:#905">2300</span><span> MHz CPU </span><span class="token" style="color:#999">)</span><span>
</span><span></span><span class="token" style="color:#905">2016</span><span>-06-25 </span><span class="token" style="color:#905">19</span><span>:34:24
</span>Benchmark              Time           CPU Iterations
<!-- -->----------------------------------------------------
<span>BM_memcpy/32          </span><span class="token" style="color:#905">11</span><span> ns         </span><span class="token" style="color:#905">11</span><span> ns   </span><span class="token" style="color:#905">79545455</span><span>
</span><span>BM_memcpy/32k       </span><span class="token" style="color:#905">2181</span><span> ns       </span><span class="token" style="color:#905">2185</span><span> ns     </span><span class="token" style="color:#905">324074</span><span>
</span><span>BM_memcpy/32          </span><span class="token" style="color:#905">12</span><span> ns         </span><span class="token" style="color:#905">12</span><span> ns   </span><span class="token" style="color:#905">54687500</span><span>
</span><span>BM_memcpy/32k       </span><span class="token" style="color:#905">1834</span><span> ns       </span><span class="token" style="color:#905">1837</span><span> ns     </span><span class="token" style="color:#905">357143</span></code></pre>&lt;a name=&quot;result-comparison&quot; /&gt;<h3>Result comparison</h3><p>It is possible to compare the benchmarking results. See <a href="docs/tools.md">Additional Tooling Documentation</a></p>&lt;a name=&quot;runtime-and-reporting-considerations&quot; /&gt;<h3>Runtime and Reporting Considerations</h3><p>When the benchmark binary is executed, each benchmark function is run serially.
The number of iterations to run is determined dynamically by running the
benchmark a few times and measuring the time taken and ensuring that the
ultimate result will be statistically stable. As such, faster benchmark
functions will be run for more iterations than slower benchmark functions, and
the number of iterations is thus reported.</p><p>In all cases, the number of iterations for which the benchmark is run is
governed by the amount of time the benchmark takes. Concretely, the number of
iterations is at least one, not more than 1e9, until CPU time is greater than
the minimum time, or the wallclock time is 5x minimum time. The minimum time is
set per benchmark by calling <code>MinTime</code> on the registered benchmark object.</p><p>Average timings are then reported over the iterations run. If multiple
repetitions are requested using the <code>--benchmark_repetitions</code> command-line
option, or at registration time, the benchmark function will be run several
times and statistical results across these repetitions will also be reported.</p><p>As well as the per-benchmark entries, a preamble in the report will include
information about the machine on which the benchmarks are run.</p>&lt;a name=&quot;passing-arguments&quot; /&gt;<h3>Passing Arguments</h3><p>Sometimes a family of benchmarks can be implemented with just one routine that
takes an extra argument to specify which one of the family of benchmarks to
run. For example, the following code defines a family of benchmarks for
measuring the speed of <code>memcpy()</code> calls of different lengths:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_memcpy(benchmark::State&amp; state) {
</span>  char* src = new char[state.range(0)];
<!-- -->  char* dst = new char[state.range(0)];
<!-- -->  memset(src, &#x27;x&#x27;, state.range(0));
<!-- -->  for (auto _ : state)
<!-- -->    memcpy(dst, src, state.range(0));
<!-- -->  state.SetBytesProcessed(int64_t(state.iterations()) *
<!-- -->                          int64_t(state.range(0)));
<!-- -->  delete[] src;
<!-- -->  delete[] dst;
<!-- -->}
<!-- -->BENCHMARK(BM_memcpy)-&gt;Arg(8)-&gt;Arg(64)-&gt;Arg(512)-&gt;Arg(1&lt;&lt;10)-&gt;Arg(8&lt;&lt;10);
</code></pre><p>The preceding code is quite repetitive, and can be replaced with the following
short-hand. The following invocation will pick a few appropriate arguments in
the specified range and will generate a benchmark for each such argument.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>BENCHMARK(BM_memcpy)-&gt;Range(8, 8&lt;&lt;10);</span></code></pre><p>By default the arguments in the range are generated in multiples of eight and
the command above selects [ 8, 64, 512, 4k, 8k ]. In the following code the
range multiplier is changed to multiples of two.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>BENCHMARK(BM_memcpy)-&gt;RangeMultiplier(2)-&gt;Range(8, 8&lt;&lt;10);</span></code></pre><p>Now arguments generated are [ 8, 16, 32, 64, 128, 256, 512, 1024, 2k, 4k, 8k ].</p><p>The preceding code shows a method of defining a sparse range.  The following
example shows a method of defining a dense range. It is then used to benchmark
the performance of <code>std::vector</code> initialization for uniformly increasing sizes.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_DenseRange(benchmark::State&amp; state) {
</span>  for(auto _ : state) {
<!-- -->    std::vector&lt;int&gt; v(state.range(0), state.range(0));
<!-- -->    benchmark::DoNotOptimize(v.data());
<!-- -->    benchmark::ClobberMemory();
<!-- -->  }
<!-- -->}
<!-- -->BENCHMARK(BM_DenseRange)-&gt;DenseRange(0, 1024, 128);
</code></pre><p>Now arguments generated are [ 0, 128, 256, 384, 512, 640, 768, 896, 1024 ].</p><p>You might have a benchmark that depends on two or more inputs. For example, the
following code defines a family of benchmarks for measuring the speed of set
insertion.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_SetInsert(benchmark::State&amp; state) {
</span>  std::set&lt;int&gt; data;
<!-- -->  for (auto _ : state) {
<!-- -->    state.PauseTiming();
<!-- -->    data = ConstructRandomSet(state.range(0));
<!-- -->    state.ResumeTiming();
<!-- -->    for (int j = 0; j &lt; state.range(1); ++j)
<!-- -->      data.insert(RandomNumber());
<!-- -->  }
<!-- -->}
<!-- -->BENCHMARK(BM_SetInsert)
<!-- -->    -&gt;Args({1&lt;&lt;10, 128})
<!-- -->    -&gt;Args({2&lt;&lt;10, 128})
<!-- -->    -&gt;Args({4&lt;&lt;10, 128})
<!-- -->    -&gt;Args({8&lt;&lt;10, 128})
<!-- -->    -&gt;Args({1&lt;&lt;10, 512})
<!-- -->    -&gt;Args({2&lt;&lt;10, 512})
<!-- -->    -&gt;Args({4&lt;&lt;10, 512})
<!-- -->    -&gt;Args({8&lt;&lt;10, 512});
</code></pre><p>The preceding code is quite repetitive, and can be replaced with the following
short-hand. The following macro will pick a few appropriate arguments in the
product of the two specified ranges and will generate a benchmark for each such
pair.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>BENCHMARK(BM_SetInsert)-&gt;Ranges({{1&lt;&lt;10, 8&lt;&lt;10}, {128, 512}});</span></code></pre><p>For more complex patterns of inputs, passing a custom function to <code>Apply</code> allows
programmatic specification of an arbitrary set of arguments on which to run the
benchmark. The following example enumerates a dense range on one parameter,
and a sparse range on the second.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void CustomArguments(benchmark::internal::Benchmark* b) {
</span>  for (int i = 0; i &lt;= 10; ++i)
<!-- -->    for (int j = 32; j &lt;= 1024*1024; j *= 8)
<!-- -->      b-&gt;Args({i, j});
<!-- -->}
<!-- -->BENCHMARK(BM_SetInsert)-&gt;Apply(CustomArguments);
</code></pre><h4>Passing Arbitrary Arguments to a Benchmark</h4><p>In C++11 it is possible to define a benchmark that takes an arbitrary number
of extra arguments. The <code>BENCHMARK_CAPTURE(func, test_case_name, ...args)</code>
macro creates a benchmark that invokes <code>func</code>  with the <code>benchmark::State</code> as
the first argument followed by the specified <code>args...</code>.
The <code>test_case_name</code> is appended to the name of the benchmark and
should describe the values passed.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>template &lt;class ...ExtraArgs&gt;
</span>void BM_takes_args(benchmark::State&amp; state, ExtraArgs&amp;&amp;... extra_args) {
<!-- -->  [...]
<!-- -->}
<!-- -->// Registers a benchmark named &quot;BM_takes_args/int_string_test&quot; that passes
<!-- -->// the specified values to `extra_args`.
<!-- -->BENCHMARK_CAPTURE(BM_takes_args, int_string_test, 42, std::string(&quot;abc&quot;));
</code></pre><p>Note that elements of <code>...args</code> may refer to global variables. Users should
avoid modifying global state inside of a benchmark.</p>&lt;a name=&quot;asymptotic-complexity&quot; /&gt;<h3>Calculating Asymptotic Complexity (Big O)</h3><p>Asymptotic complexity might be calculated for a family of benchmarks. The
following code will calculate the coefficient for the high-order term in the
running time and the normalized root-mean square error of string comparison.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_StringCompare(benchmark::State&amp; state) {
</span>  std::string s1(state.range(0), &#x27;-&#x27;);
<!-- -->  std::string s2(state.range(0), &#x27;-&#x27;);
<!-- -->  for (auto _ : state) {
<!-- -->    benchmark::DoNotOptimize(s1.compare(s2));
<!-- -->  }
<!-- -->  state.SetComplexityN(state.range(0));
<!-- -->}
<!-- -->BENCHMARK(BM_StringCompare)
<!-- -->    -&gt;RangeMultiplier(2)-&gt;Range(1&lt;&lt;10, 1&lt;&lt;18)-&gt;Complexity(benchmark::oN);
</code></pre><p>As shown in the following invocation, asymptotic complexity might also be
calculated automatically.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>BENCHMARK(BM_StringCompare)
</span>    -&gt;RangeMultiplier(2)-&gt;Range(1&lt;&lt;10, 1&lt;&lt;18)-&gt;Complexity();
</code></pre><p>The following code will specify asymptotic complexity with a lambda function,
that might be used to customize high-order term calculation.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>BENCHMARK(BM_StringCompare)-&gt;RangeMultiplier(2)
</span>    -&gt;Range(1&lt;&lt;10, 1&lt;&lt;18)-&gt;Complexity([](int64_t n)-&gt;double{return n; });
</code></pre>&lt;a name=&quot;templated-benchmarks&quot; /&gt;<h3>Templated Benchmarks</h3><p>This example produces and consumes messages of size <code>sizeof(v)</code> <code>range_x</code>
times. It also outputs throughput in the absence of multiprogramming.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>template &lt;class Q&gt; void BM_Sequential(benchmark::State&amp; state) {
</span>  Q q;
<!-- -->  typename Q::value_type v;
<!-- -->  for (auto _ : state) {
<!-- -->    for (int i = state.range(0); i--; )
<!-- -->      q.push(v);
<!-- -->    for (int e = state.range(0); e--; )
<!-- -->      q.Wait(&amp;v);
<!-- -->  }
<!-- -->  // actually messages, not bytes:
<!-- -->  state.SetBytesProcessed(
<!-- -->      static_cast&lt;int64_t&gt;(state.iterations())*state.range(0));
<!-- -->}
<!-- -->BENCHMARK_TEMPLATE(BM_Sequential, WaitQueue&lt;int&gt;)-&gt;Range(1&lt;&lt;0, 1&lt;&lt;10);
</code></pre><p>Three macros are provided for adding benchmark templates.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#ifdef BENCHMARK_HAS_CXX11
</span>#define BENCHMARK_TEMPLATE(func, ...) // Takes any number of parameters.
<!-- -->#else // C++ &lt; C++11
<!-- -->#define BENCHMARK_TEMPLATE(func, arg1)
<!-- -->#endif
<!-- -->#define BENCHMARK_TEMPLATE1(func, arg1)
<!-- -->#define BENCHMARK_TEMPLATE2(func, arg1, arg2)
</code></pre>&lt;a name=&quot;fixtures&quot; /&gt;<h3>Fixtures</h3><p>Fixture tests are created by first defining a type that derives from
<code>::benchmark::Fixture</code> and then creating/registering the tests using the
following macros:</p><ul><li><code>BENCHMARK_F(ClassName, Method)</code></li><li><code>BENCHMARK_DEFINE_F(ClassName, Method)</code></li><li><code>BENCHMARK_REGISTER_F(ClassName, Method)</code></li></ul><p>For Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>class MyFixture : public benchmark::Fixture {
</span>public:
<!-- -->  void SetUp(const ::benchmark::State&amp; state) {
<!-- -->  }
<!-- -->
<!-- -->  void TearDown(const ::benchmark::State&amp; state) {
<!-- -->  }
<!-- -->};
<!-- -->
<!-- -->BENCHMARK_F(MyFixture, FooTest)(benchmark::State&amp; st) {
<!-- -->   for (auto _ : st) {
<!-- -->     ...
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->BENCHMARK_DEFINE_F(MyFixture, BarTest)(benchmark::State&amp; st) {
<!-- -->   for (auto _ : st) {
<!-- -->     ...
<!-- -->  }
<!-- -->}
<!-- -->/* BarTest is NOT registered */
<!-- -->BENCHMARK_REGISTER_F(MyFixture, BarTest)-&gt;Threads(2);
<!-- -->/* BarTest is now registered */
</code></pre><h4>Templated Fixtures</h4><p>Also you can create templated fixture by using the following macros:</p><ul><li><code>BENCHMARK_TEMPLATE_F(ClassName, Method, ...)</code></li><li><code>BENCHMARK_TEMPLATE_DEFINE_F(ClassName, Method, ...)</code></li></ul><p>For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>template&lt;typename T&gt;
</span>class MyFixture : public benchmark::Fixture {};
<!-- -->
<!-- -->BENCHMARK_TEMPLATE_F(MyFixture, IntTest, int)(benchmark::State&amp; st) {
<!-- -->   for (auto _ : st) {
<!-- -->     ...
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->BENCHMARK_TEMPLATE_DEFINE_F(MyFixture, DoubleTest, double)(benchmark::State&amp; st) {
<!-- -->   for (auto _ : st) {
<!-- -->     ...
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->BENCHMARK_REGISTER_F(MyFixture, DoubleTest)-&gt;Threads(2);
</code></pre>&lt;a name=&quot;custom-counters&quot; /&gt;<h3>Custom Counters</h3><p>You can add your own counters with user-defined names. The example below
will add columns &quot;Foo&quot;, &quot;Bar&quot; and &quot;Baz&quot; in its output:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void UserCountersExample1(benchmark::State&amp; state) {
</span>  double numFoos = 0, numBars = 0, numBazs = 0;
<!-- -->  for (auto _ : state) {
<!-- -->    // ... count Foo,Bar,Baz events
<!-- -->  }
<!-- -->  state.counters[&quot;Foo&quot;] = numFoos;
<!-- -->  state.counters[&quot;Bar&quot;] = numBars;
<!-- -->  state.counters[&quot;Baz&quot;] = numBazs;
<!-- -->}
</code></pre><p>The <code>state.counters</code> object is a <code>std::map</code> with <code>std::string</code> keys
and <code>Counter</code> values. The latter is a <code>double</code>-like class, via an implicit
conversion to <code>double&amp;</code>. Thus you can use all of the standard arithmetic
assignment operators (<code>=,+=,-=,*=,/=</code>) to change the value of each counter.</p><p>In multithreaded benchmarks, each counter is set on the calling thread only.
When the benchmark finishes, the counters from each thread will be summed;
the resulting sum is the value which will be shown for the benchmark.</p><p>The <code>Counter</code> constructor accepts three parameters: the value as a <code>double</code>
; a bit flag which allows you to show counters as rates, and/or as per-thread
iteration, and/or as per-thread averages, and/or iteration invariants,
and/or finally inverting the result; and a flag specifying the &#x27;unit&#x27; - i.e.
is 1k a 1000 (default, <code>benchmark::Counter::OneK::kIs1000</code>), or 1024
(<code>benchmark::Counter::OneK::kIs1024</code>)?</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>  // sets a simple counter
</span>  state.counters[&quot;Foo&quot;] = numFoos;
<!-- -->
<!-- -->  // Set the counter as a rate. It will be presented divided
<!-- -->  // by the duration of the benchmark.
<!-- -->  // Meaning: per one second, how many &#x27;foo&#x27;s are processed?
<!-- -->  state.counters[&quot;FooRate&quot;] = Counter(numFoos, benchmark::Counter::kIsRate);
<!-- -->
<!-- -->  // Set the counter as a rate. It will be presented divided
<!-- -->  // by the duration of the benchmark, and the result inverted.
<!-- -->  // Meaning: how many seconds it takes to process one &#x27;foo&#x27;?
<!-- -->  state.counters[&quot;FooInvRate&quot;] = Counter(numFoos, benchmark::Counter::kIsRate | benchmark::Counter::kInvert);
<!-- -->
<!-- -->  // Set the counter as a thread-average quantity. It will
<!-- -->  // be presented divided by the number of threads.
<!-- -->  state.counters[&quot;FooAvg&quot;] = Counter(numFoos, benchmark::Counter::kAvgThreads);
<!-- -->
<!-- -->  // There&#x27;s also a combined flag:
<!-- -->  state.counters[&quot;FooAvgRate&quot;] = Counter(numFoos,benchmark::Counter::kAvgThreadsRate);
<!-- -->
<!-- -->  // This says that we process with the rate of state.range(0) bytes every iteration:
<!-- -->  state.counters[&quot;BytesProcessed&quot;] = Counter(state.range(0), benchmark::Counter::kIsIterationInvariantRate, benchmark::Counter::OneK::kIs1024);
</code></pre><p>When you&#x27;re compiling in C++11 mode or later you can use <code>insert()</code> with
<code>std::initializer_list</code>:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>  // With C++11, this can be done:
</span>  state.counters.insert({{&quot;Foo&quot;, numFoos}, {&quot;Bar&quot;, numBars}, {&quot;Baz&quot;, numBazs}});
<!-- -->  // ... instead of:
<!-- -->  state.counters[&quot;Foo&quot;] = numFoos;
<!-- -->  state.counters[&quot;Bar&quot;] = numBars;
<!-- -->  state.counters[&quot;Baz&quot;] = numBazs;
</code></pre><h4>Counter Reporting</h4><p>When using the console reporter, by default, user counters are printed at
the end after the table, the same way as <code>bytes_processed</code> and
<code>items_processed</code>. This is best for cases in which there are few counters,
or where there are only a couple of lines per benchmark. Here&#x27;s an example of
the default output:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>------------------------------------------------------------------------------
</span>Benchmark                        Time           CPU Iterations UserCounters...
<!-- -->------------------------------------------------------------------------------
<!-- -->BM_UserCounter/threads:8      2248 ns      10277 ns      68808 Bar=16 Bat=40 Baz=24 Foo=8
<!-- -->BM_UserCounter/threads:1      9797 ns       9788 ns      71523 Bar=2 Bat=5 Baz=3 Foo=1024m
<!-- -->BM_UserCounter/threads:2      4924 ns       9842 ns      71036 Bar=4 Bat=10 Baz=6 Foo=2
<!-- -->BM_UserCounter/threads:4      2589 ns      10284 ns      68012 Bar=8 Bat=20 Baz=12 Foo=4
<!-- -->BM_UserCounter/threads:8      2212 ns      10287 ns      68040 Bar=16 Bat=40 Baz=24 Foo=8
<!-- -->BM_UserCounter/threads:16     1782 ns      10278 ns      68144 Bar=32 Bat=80 Baz=48 Foo=16
<!-- -->BM_UserCounter/threads:32     1291 ns      10296 ns      68256 Bar=64 Bat=160 Baz=96 Foo=32
<!-- -->BM_UserCounter/threads:4      2615 ns      10307 ns      68040 Bar=8 Bat=20 Baz=12 Foo=4
<!-- -->BM_Factorial                    26 ns         26 ns   26608979 40320
<!-- -->BM_Factorial/real_time          26 ns         26 ns   26587936 40320
<!-- -->BM_CalculatePiRange/1           16 ns         16 ns   45704255 0
<!-- -->BM_CalculatePiRange/8           73 ns         73 ns    9520927 3.28374
<!-- -->BM_CalculatePiRange/64         609 ns        609 ns    1140647 3.15746
<!-- -->BM_CalculatePiRange/512       4900 ns       4901 ns     142696 3.14355
</code></pre><p>If this doesn&#x27;t suit you, you can print each counter as a table column by
passing the flag <code>--benchmark_counters_tabular=true</code> to the benchmark
application. This is best for cases in which there are a lot of counters, or
a lot of lines per individual benchmark. Note that this will trigger a
reprinting of the table header any time the counter set changes between
individual benchmarks. Here&#x27;s an example of corresponding output when
<code>--benchmark_counters_tabular=true</code> is passed:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>---------------------------------------------------------------------------------------
</span>Benchmark                        Time           CPU Iterations    Bar   Bat   Baz   Foo
<!-- -->---------------------------------------------------------------------------------------
<!-- -->BM_UserCounter/threads:8      2198 ns       9953 ns      70688     16    40    24     8
<!-- -->BM_UserCounter/threads:1      9504 ns       9504 ns      73787      2     5     3     1
<!-- -->BM_UserCounter/threads:2      4775 ns       9550 ns      72606      4    10     6     2
<!-- -->BM_UserCounter/threads:4      2508 ns       9951 ns      70332      8    20    12     4
<!-- -->BM_UserCounter/threads:8      2055 ns       9933 ns      70344     16    40    24     8
<!-- -->BM_UserCounter/threads:16     1610 ns       9946 ns      70720     32    80    48    16
<!-- -->BM_UserCounter/threads:32     1192 ns       9948 ns      70496     64   160    96    32
<!-- -->BM_UserCounter/threads:4      2506 ns       9949 ns      70332      8    20    12     4
<!-- -->--------------------------------------------------------------
<!-- -->Benchmark                        Time           CPU Iterations
<!-- -->--------------------------------------------------------------
<!-- -->BM_Factorial                    26 ns         26 ns   26392245 40320
<!-- -->BM_Factorial/real_time          26 ns         26 ns   26494107 40320
<!-- -->BM_CalculatePiRange/1           15 ns         15 ns   45571597 0
<!-- -->BM_CalculatePiRange/8           74 ns         74 ns    9450212 3.28374
<!-- -->BM_CalculatePiRange/64         595 ns        595 ns    1173901 3.15746
<!-- -->BM_CalculatePiRange/512       4752 ns       4752 ns     147380 3.14355
<!-- -->BM_CalculatePiRange/4k       37970 ns      37972 ns      18453 3.14184
<!-- -->BM_CalculatePiRange/32k     303733 ns     303744 ns       2305 3.14162
<!-- -->BM_CalculatePiRange/256k   2434095 ns    2434186 ns        288 3.1416
<!-- -->BM_CalculatePiRange/1024k  9721140 ns    9721413 ns         71 3.14159
<!-- -->BM_CalculatePi/threads:8      2255 ns       9943 ns      70936
</code></pre><p>Note above the additional header printed when the benchmark changes from
<code>BM_UserCounter</code> to <code>BM_Factorial</code>. This is because <code>BM_Factorial</code> does
not have the same counter set as <code>BM_UserCounter</code>.</p>&lt;a name=&quot;multithreaded-benchmarks&quot;/&gt;<h3>Multithreaded Benchmarks</h3><p>In a multithreaded test (benchmark invoked by multiple threads simultaneously),
it is guaranteed that none of the threads will start until all have reached
the start of the benchmark loop, and all will have finished before any thread
exits the benchmark loop. (This behavior is also provided by the <code>KeepRunning()</code>
API) As such, any global setup or teardown can be wrapped in a check against the thread
index:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_MultiThreaded(benchmark::State&amp; state) {
</span>  if (state.thread_index == 0) {
<!-- -->    // Setup code here.
<!-- -->  }
<!-- -->  for (auto _ : state) {
<!-- -->    // Run the test as normal.
<!-- -->  }
<!-- -->  if (state.thread_index == 0) {
<!-- -->    // Teardown code here.
<!-- -->  }
<!-- -->}
<!-- -->BENCHMARK(BM_MultiThreaded)-&gt;Threads(2);
</code></pre><p>If the benchmarked code itself uses threads and you want to compare it to
single-threaded code, you may want to use real-time (&quot;wallclock&quot;) measurements
for latency comparisons:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>BENCHMARK(BM_test)-&gt;Range(8, 8&lt;&lt;10)-&gt;UseRealTime();</span></code></pre><p>Without <code>UseRealTime</code>, CPU time is used by default.</p>&lt;a name=&quot;cpu-timers&quot; /&gt;<h3>CPU Timers</h3><p>By default, the CPU timer only measures the time spent by the main thread.
If the benchmark itself uses threads internally, this measurement may not
be what you are looking for. Instead, there is a way to measure the total
CPU usage of the process, by all the threads.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>void callee(int i);
</span>
<!-- -->static void MyMain(int size) {
<!-- -->#pragma omp parallel for
<!-- -->  for(int i = 0; i &lt; size; i++)
<!-- -->    callee(i);
<!-- -->}
<!-- -->
<!-- -->static void BM_OpenMP(benchmark::State&amp; state) {
<!-- -->  for (auto _ : state)
<!-- -->    MyMain(state.range(0);
<!-- -->}
<!-- -->
<!-- -->// Measure the time spent by the main thread, use it to decide for how long to
<!-- -->// run the benchmark loop. Depending on the internal implementation detail may
<!-- -->// measure to anywhere from near-zero (the overhead spent before/after work
<!-- -->// handoff to worker thread[s]) to the whole single-thread time.
<!-- -->BENCHMARK(BM_OpenMP)-&gt;Range(8, 8&lt;&lt;10);
<!-- -->
<!-- -->// Measure the user-visible time, the wall clock (literally, the time that
<!-- -->// has passed on the clock on the wall), use it to decide for how long to
<!-- -->// run the benchmark loop. This will always be meaningful, an will match the
<!-- -->// time spent by the main thread in single-threaded case, in general decreasing
<!-- -->// with the number of internal threads doing the work.
<!-- -->BENCHMARK(BM_OpenMP)-&gt;Range(8, 8&lt;&lt;10)-&gt;UseRealTime();
<!-- -->
<!-- -->// Measure the total CPU consumption, use it to decide for how long to
<!-- -->// run the benchmark loop. This will always measure to no less than the
<!-- -->// time spent by the main thread in single-threaded case.
<!-- -->BENCHMARK(BM_OpenMP)-&gt;Range(8, 8&lt;&lt;10)-&gt;MeasureProcessCPUTime();
<!-- -->
<!-- -->// A mixture of the last two. Measure the total CPU consumption, but use the
<!-- -->// wall clock to decide for how long to run the benchmark loop.
<!-- -->BENCHMARK(BM_OpenMP)-&gt;Range(8, 8&lt;&lt;10)-&gt;MeasureProcessCPUTime()-&gt;UseRealTime();
</code></pre><h4>Controlling Timers</h4><p>Normally, the entire duration of the work loop (<code>for (auto _ : state) {}</code>)
is measured. But sometimes, it is necessary to do some work inside of
that loop, every iteration, but without counting that time to the benchmark time.
That is possible, although it is not recommended, since it has high overhead.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_SetInsert_With_Timer_Control(benchmark::State&amp; state) {
</span>  std::set&lt;int&gt; data;
<!-- -->  for (auto _ : state) {
<!-- -->    state.PauseTiming(); // Stop timers. They will not count until they are resumed.
<!-- -->    data = ConstructRandomSet(state.range(0)); // Do something that should not be measured
<!-- -->    state.ResumeTiming(); // And resume timers. They are now counting again.
<!-- -->    // The rest will be measured.
<!-- -->    for (int j = 0; j &lt; state.range(1); ++j)
<!-- -->      data.insert(RandomNumber());
<!-- -->  }
<!-- -->}
<!-- -->BENCHMARK(BM_SetInsert_With_Timer_Control)-&gt;Ranges({{1&lt;&lt;10, 8&lt;&lt;10}, {128, 512}});
</code></pre>&lt;a name=&quot;manual-timing&quot; /&gt;<h3>Manual Timing</h3><p>For benchmarking something for which neither CPU time nor real-time are
correct or accurate enough, completely manual timing is supported using
the <code>UseManualTime</code> function.</p><p>When <code>UseManualTime</code> is used, the benchmarked code must call
<code>SetIterationTime</code> once per iteration of the benchmark loop to
report the manually measured time.</p><p>An example use case for this is benchmarking GPU execution (e.g. OpenCL
or CUDA kernels, OpenGL or Vulkan or Direct3D draw calls), which cannot
be accurately measured using CPU time or real-time. Instead, they can be
measured accurately using a dedicated API, and these measurement results
can be reported back with <code>SetIterationTime</code>.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_ManualTiming(benchmark::State&amp; state) {
</span>  int microseconds = state.range(0);
<!-- -->  std::chrono::duration&lt;double, std::micro&gt; sleep_duration {
<!-- -->    static_cast&lt;double&gt;(microseconds)
<!-- -->  };
<!-- -->
<!-- -->  for (auto _ : state) {
<!-- -->    auto start = std::chrono::high_resolution_clock::now();
<!-- -->    // Simulate some useful workload with a sleep
<!-- -->    std::this_thread::sleep_for(sleep_duration);
<!-- -->    auto end   = std::chrono::high_resolution_clock::now();
<!-- -->
<!-- -->    auto elapsed_seconds =
<!-- -->      std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(
<!-- -->        end - start);
<!-- -->
<!-- -->    state.SetIterationTime(elapsed_seconds.count());
<!-- -->  }
<!-- -->}
<!-- -->BENCHMARK(BM_ManualTiming)-&gt;Range(1, 1&lt;&lt;17)-&gt;UseManualTime();
</code></pre>&lt;a name=&quot;setting-the-time-unit&quot; /&gt;<h3>Setting the Time Unit</h3><p>If a benchmark runs a few milliseconds it may be hard to visually compare the
measured times, since the output data is given in nanoseconds per default. In
order to manually set the time unit, you can specify it manually:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>BENCHMARK(BM_test)-&gt;Unit(benchmark::kMillisecond);</span></code></pre>&lt;a name=&quot;preventing-optimization&quot; /&gt;<h3>Preventing Optimization</h3><p>To prevent a value or expression from being optimized away by the compiler
the <code>benchmark::DoNotOptimize(...)</code> and <code>benchmark::ClobberMemory()</code>
functions can be used.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_test(benchmark::State&amp; state) {
</span>  for (auto _ : state) {
<!-- -->      int x = 0;
<!-- -->      for (int i=0; i &lt; 64; ++i) {
<!-- -->        benchmark::DoNotOptimize(x += i);
<!-- -->      }
<!-- -->  }
<!-- -->}
</code></pre><p><code>DoNotOptimize(&lt;expr&gt;)</code> forces the  <em>result</em> of <code>&lt;expr&gt;</code> to be stored in either
memory or a register. For GNU based compilers it acts as read/write barrier
for global memory. More specifically it forces the compiler to flush pending
writes to memory and reload any other values as necessary.</p><p>Note that <code>DoNotOptimize(&lt;expr&gt;)</code> does not prevent optimizations on <code>&lt;expr&gt;</code>
in any way. <code>&lt;expr&gt;</code> may even be removed entirely when the result is already
known. For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>  /* Example 1: `&lt;expr&gt;` is removed entirely. */
</span>  int foo(int x) { return x + 42; }
<!-- -->  while (...) DoNotOptimize(foo(0)); // Optimized to DoNotOptimize(42);
<!-- -->
<!-- -->  /*  Example 2: Result of &#x27;&lt;expr&gt;&#x27; is only reused */
<!-- -->  int bar(int) __attribute__((const));
<!-- -->  while (...) DoNotOptimize(bar(0)); // Optimized to:
<!-- -->  // int __result__ = bar(0);
<!-- -->  // while (...) DoNotOptimize(__result__);
</code></pre><p>The second tool for preventing optimizations is <code>ClobberMemory()</code>. In essence
<code>ClobberMemory()</code> forces the compiler to perform all pending writes to global
memory. Memory managed by block scope objects must be &quot;escaped&quot; using
<code>DoNotOptimize(...)</code> before it can be clobbered. In the below example
<code>ClobberMemory()</code> prevents the call to <code>v.push_back(42)</code> from being optimized
away.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_vector_push_back(benchmark::State&amp; state) {
</span>  for (auto _ : state) {
<!-- -->    std::vector&lt;int&gt; v;
<!-- -->    v.reserve(1);
<!-- -->    benchmark::DoNotOptimize(v.data()); // Allow v.data() to be clobbered.
<!-- -->    v.push_back(42);
<!-- -->    benchmark::ClobberMemory(); // Force 42 to be written to memory.
<!-- -->  }
<!-- -->}
</code></pre><p>Note that <code>ClobberMemory()</code> is only available for GNU or MSVC based compilers.</p>&lt;a name=&quot;reporting-statistics&quot; /&gt;<h3>Statistics: Reporting the Mean, Median and Standard Deviation of Repeated Benchmarks</h3><p>By default each benchmark is run once and that single result is reported.
However benchmarks are often noisy and a single result may not be representative
of the overall behavior. For this reason it&#x27;s possible to repeatedly rerun the
benchmark.</p><p>The number of runs of each benchmark is specified globally by the
<code>--benchmark_repetitions</code> flag or on a per benchmark basis by calling
<code>Repetitions</code> on the registered benchmark object. When a benchmark is run more
than once the mean, median and standard deviation of the runs will be reported.</p><p>Additionally the <code>--benchmark_report_aggregates_only={true|false}</code>,
<code>--benchmark_display_aggregates_only={true|false}</code> flags or
<code>ReportAggregatesOnly(bool)</code>, <code>DisplayAggregatesOnly(bool)</code> functions can be
used to change how repeated tests are reported. By default the result of each
repeated run is reported. When <code>report aggregates only</code> option is <code>true</code>,
only the aggregates (i.e. mean, median and standard deviation, maybe complexity
measurements if they were requested) of the runs is reported, to both the
reporters - standard output (console), and the file.
However when only the <code>display aggregates only</code> option is <code>true</code>,
only the aggregates are displayed in the standard output, while the file
output still contains everything.
Calling <code>ReportAggregatesOnly(bool)</code> / <code>DisplayAggregatesOnly(bool)</code> on a
registered benchmark object overrides the value of the appropriate flag for that
benchmark.</p>&lt;a name=&quot;custom-statistics&quot; /&gt;<h3>Custom Statistics</h3><p>While having mean, median and standard deviation is nice, this may not be
enough for everyone. For example you may want to know what the largest
observation is, e.g. because you have some real-time constraints. This is easy.
The following code will specify a custom statistic to be calculated, defined
by a lambda function.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>void BM_spin_empty(benchmark::State&amp; state) {
</span>  for (auto _ : state) {
<!-- -->    for (int x = 0; x &lt; state.range(0); ++x) {
<!-- -->      benchmark::DoNotOptimize(x);
<!-- -->    }
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->BENCHMARK(BM_spin_empty)
<!-- -->  -&gt;ComputeStatistics(&quot;max&quot;, [](const std::vector&lt;double&gt;&amp; v) -&gt; double {
<!-- -->    return *(std::max_element(std::begin(v), std::end(v)));
<!-- -->  })
<!-- -->  -&gt;Arg(512);
</code></pre>&lt;a name=&quot;using-register-benchmark&quot; /&gt;<h3>Using RegisterBenchmark(name, fn, args...)</h3><p>The <code>RegisterBenchmark(name, func, args...)</code> function provides an alternative
way to create and register benchmarks.
<code>RegisterBenchmark(name, func, args...)</code> creates, registers, and returns a
pointer to a new benchmark with the specified <code>name</code> that invokes
<code>func(st, args...)</code> where <code>st</code> is a <code>benchmark::State</code> object.</p><p>Unlike the <code>BENCHMARK</code> registration macros, which can only be used at the global
scope, the <code>RegisterBenchmark</code> can be called anywhere. This allows for
benchmark tests to be registered programmatically.</p><p>Additionally <code>RegisterBenchmark</code> allows any callable object to be registered
as a benchmark. Including capturing lambdas and function objects.</p><p>For Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>auto BM_test = [](benchmark::State&amp; st, auto Inputs) { /* ... */ };
</span>
<!-- -->int main(int argc, char** argv) {
<!-- -->  for (auto&amp; test_input : { /* ... */ })
<!-- -->      benchmark::RegisterBenchmark(test_input.name(), BM_test, test_input);
<!-- -->  benchmark::Initialize(&amp;argc, argv);
<!-- -->  benchmark::RunSpecifiedBenchmarks();
<!-- -->}
</code></pre>&lt;a name=&quot;exiting-with-an-error&quot; /&gt;<h3>Exiting with an Error</h3><p>When errors caused by external influences, such as file I/O and network
communication, occur within a benchmark the
<code>State::SkipWithError(const char* msg)</code> function can be used to skip that run
of benchmark and report the error. Note that only future iterations of the
<code>KeepRunning()</code> are skipped. For the ranged-for version of the benchmark loop
Users must explicitly exit the loop, otherwise all iterations will be performed.
Users may explicitly return to exit the benchmark immediately.</p><p>The <code>SkipWithError(...)</code> function may be used at any point within the benchmark,
including before and after the benchmark loop.</p><p>For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_test(benchmark::State&amp; state) {
</span>  auto resource = GetResource();
<!-- -->  if (!resource.good()) {
<!-- -->      state.SkipWithError(&quot;Resource is not good!&quot;);
<!-- -->      // KeepRunning() loop will not be entered.
<!-- -->  }
<!-- -->  while (state.KeepRunning()) {
<!-- -->      auto data = resource.read_data();
<!-- -->      if (!resource.good()) {
<!-- -->        state.SkipWithError(&quot;Failed to read data!&quot;);
<!-- -->        break; // Needed to skip the rest of the iteration.
<!-- -->     }
<!-- -->     do_stuff(data);
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->static void BM_test_ranged_fo(benchmark::State &amp; state) {
<!-- -->  state.SkipWithError(&quot;test will not be entered&quot;);
<!-- -->  for (auto _ : state) {
<!-- -->    state.SkipWithError(&quot;Failed!&quot;);
<!-- -->    break; // REQUIRED to prevent all further iterations.
<!-- -->  }
<!-- -->}
</code></pre>&lt;a name=&quot;a-faster-keep-running-loop&quot; /&gt;<h3>A Faster KeepRunning Loop</h3><p>In C++11 mode, a ranged-based for loop should be used in preference to
the <code>KeepRunning</code> loop for running the benchmarks. For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>static void BM_Fast(benchmark::State &amp;state) {
</span>  for (auto _ : state) {
<!-- -->    FastOperation();
<!-- -->  }
<!-- -->}
<!-- -->BENCHMARK(BM_Fast);
</code></pre><p>The reason the ranged-for loop is faster than using <code>KeepRunning</code>, is
because <code>KeepRunning</code> requires a memory load and store of the iteration count
ever iteration, whereas the ranged-for variant is able to keep the iteration count
in a register.</p><p>For example, an empty inner loop of using the ranged-based for method looks like:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-asm" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span># Loop Init
</span>  mov rbx, qword ptr [r14 + 104]
<!-- -->  call benchmark::State::StartKeepRunning()
<!-- -->  test rbx, rbx
<!-- -->  je .LoopEnd
<!-- -->.LoopHeader: # =&gt;This Inner Loop Header: Depth=1
<!-- -->  add rbx, -1
<!-- -->  jne .LoopHeader
<!-- -->.LoopEnd:
</code></pre><p>Compared to an empty <code>KeepRunning</code> loop, which looks like:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-asm" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>.LoopHeader: # in Loop: Header=BB0_3 Depth=1
</span>  cmp byte ptr [rbx], 1
<!-- -->  jne .LoopInit
<!-- -->.LoopBody: # =&gt;This Inner Loop Header: Depth=1
<!-- -->  mov rax, qword ptr [rbx + 8]
<!-- -->  lea rcx, [rax + 1]
<!-- -->  mov qword ptr [rbx + 8], rcx
<!-- -->  cmp rax, qword ptr [rbx + 104]
<!-- -->  jb .LoopHeader
<!-- -->  jmp .LoopEnd
<!-- -->.LoopInit:
<!-- -->  mov rdi, rbx
<!-- -->  call benchmark::State::StartKeepRunning()
<!-- -->  jmp .LoopBody
<!-- -->.LoopEnd:
</code></pre><p>Unless C++03 compatibility is required, the ranged-for variant of writing
the benchmark loop should be preferred.</p>&lt;a name=&quot;disabling-cpu-frequency-scaling&quot; /&gt;<h3>Disabling CPU Frequency Scaling</h3><p>If you see this error:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>***WARNING*** CPU scaling is enabled, the benchmark real time measurements may be noisy and will incur extra overhead.</span></code></pre><p>you might want to disable the CPU frequency scaling while running the benchmark:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-bash" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#DD4A68">sudo</span><span> cpupower frequency-set --governor performance
</span>./mybench
<span></span><span class="token" style="color:#DD4A68">sudo</span><span> cpupower frequency-set --governor powersave</span></code></pre></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/google-benchmark","name":"google/benchmark","licence":"Apache-2.0","description":"A microbenchmark support library","readme":"# Benchmark\n[![Build Status](https://travis-ci.org/google/benchmark.svg?branch=master)](https://travis-ci.org/google/benchmark)\n[![Build status](https://ci.appveyor.com/api/projects/status/u0qsyp7t1tk7cpxs/branch/master?svg=true)](https://ci.appveyor.com/project/google/benchmark/branch/master)\n[![Coverage Status](https://coveralls.io/repos/google/benchmark/badge.svg)](https://coveralls.io/r/google/benchmark)\n[![slackin](https://slackin-iqtfqnpzxd.now.sh/badge.svg)](https://slackin-iqtfqnpzxd.now.sh/)\n\n\nA library to benchmark code snippets, similar to unit tests. Example:\n\n```c++\n#include \u003cbenchmark/benchmark.h\u003e\n\nstatic void BM_SomeFunction(benchmark::State\u0026 state) {\n  // Perform setup here\n  for (auto _ : state) {\n    // This code gets timed\n    SomeFunction();\n  }\n}\n// Register the function as a benchmark\nBENCHMARK(BM_SomeFunction);\n// Run the benchmark\nBENCHMARK_MAIN();\n```\n\nTo get started, see [Requirements](#requirements) and\n[Installation](#installation). See [Usage](#usage) for a full example and the\n[User Guide](#user-guide) for a more comprehensive feature overview.\n\nIt may also help to read the [Google Test documentation](https://github.com/google/googletest/blob/master/googletest/docs/primer.md)\nas some of the structural aspects of the APIs are similar.\n\n### Resources\n\n[Discussion group](https://groups.google.com/d/forum/benchmark-discuss)\n\nIRC channel: [freenode](https://freenode.net) #googlebenchmark\n\n[Additional Tooling Documentation](docs/tools.md)\n\n[Assembly Testing Documentation](docs/AssemblyTests.md)\n\n## Requirements\n\nThe library can be used with C++03. However, it requires C++11 to build,\nincluding compiler and standard library support.\n\nThe following minimum versions are required to build the library:\n\n* GCC 4.8\n* Clang 3.4\n* Visual Studio 14 2015\n* Intel 2015 Update 1\n\n## Installation\n\nThis describes the installation process using cmake. As pre-requisites, you'll\nneed git and cmake installed.\n\n_See [dependencies.md](dependencies.md) for more details regarding supported\nversions of build tools._\n\n```bash\n# Check out the library.\n$ git clone https://github.com/google/benchmark.git\n# Benchmark requires Google Test as a dependency. Add the source tree as a subdirectory.\n$ git clone https://github.com/google/googletest.git benchmark/googletest\n# Go to the library root directory\n$ cd benchmark\n# Make a build directory to place the build output.\n$ mkdir build \u0026\u0026 cd build\n# Generate a Makefile with cmake.\n# Use cmake -G \u003cgenerator\u003e to generate a different file type.\n$ cmake ../\n# Build the library.\n# Use make -j\u003cnumber_of_parallel_jobs\u003e to speed up the build process, e.g. make -j8 .\n$ make\n```\nThis builds the `benchmark` and `benchmark_main` libraries and tests.\nOn a unix system, the build directory should now look something like this:\n\n```\n/benchmark\n  /build\n    /src\n      /libbenchmark.a\n      /libbenchmark_main.a\n    /test\n      ...\n```\n\nNext, you can run the tests to check the build.\n\n```bash\n$ make test\n```\n\nIf you want to install the library globally, also run:\n\n```\nsudo make install\n```\n\nNote that Google Benchmark requires Google Test to build and run the tests. This\ndependency can be provided two ways:\n\n* Checkout the Google Test sources into `benchmark/googletest` as above.\n* Otherwise, if `-DBENCHMARK_DOWNLOAD_DEPENDENCIES=ON` is specified during\n  configuration, the library will automatically download and build any required\n  dependencies.\n\nIf you do not wish to build and run the tests, add `-DBENCHMARK_ENABLE_GTEST_TESTS=OFF`\nto `CMAKE_ARGS`.\n\n### Debug vs Release\n\nBy default, benchmark builds as a debug library. You will see a warning in the\noutput when this is the case. To build it as a release library instead, use:\n\n```\ncmake -DCMAKE_BUILD_TYPE=Release\n```\n\nTo enable link-time optimisation, use\n\n```\ncmake -DCMAKE_BUILD_TYPE=Release -DBENCHMARK_ENABLE_LTO=true\n```\n\nIf you are using gcc, you might need to set `GCC_AR` and `GCC_RANLIB` cmake\ncache variables, if autodetection fails.\n\nIf you are using clang, you may need to set `LLVMAR_EXECUTABLE`,\n`LLVMNM_EXECUTABLE` and `LLVMRANLIB_EXECUTABLE` cmake cache variables.\n\n\n### Stable and Experimental Library Versions\n\nThe main branch contains the latest stable version of the benchmarking library;\nthe API of which can be considered largely stable, with source breaking changes\nbeing made only upon the release of a new major version.\n\nNewer, experimental, features are implemented and tested on the\n[`v2` branch](https://github.com/google/benchmark/tree/v2). Users who wish\nto use, test, and provide feedback on the new features are encouraged to try\nthis branch. However, this branch provides no stability guarantees and reserves\nthe right to change and break the API at any time.\n\n## Usage\n### Basic usage\nDefine a function that executes the code to measure, register it as a benchmark\nfunction using the `BENCHMARK` macro, and ensure an appropriate `main` function\nis available:\n\n```c++\n#include \u003cbenchmark/benchmark.h\u003e\n\nstatic void BM_StringCreation(benchmark::State\u0026 state) {\n  for (auto _ : state)\n    std::string empty_string;\n}\n// Register the function as a benchmark\nBENCHMARK(BM_StringCreation);\n\n// Define another benchmark\nstatic void BM_StringCopy(benchmark::State\u0026 state) {\n  std::string x = \"hello\";\n  for (auto _ : state)\n    std::string copy(x);\n}\nBENCHMARK(BM_StringCopy);\n\nBENCHMARK_MAIN();\n```\n\nTo run the benchmark, compile and link against the `benchmark` library\n(libbenchmark.a/.so). If you followed the build steps above, this\nlibrary will be under the build directory you created.\n\n```bash\n# Example on linux after running the build steps above. Assumes the\n# `benchmark` and `build` directories are under the current directory.\n$ g++ -std=c++11 -isystem benchmark/include -Lbuild/src -lpthread \\\n  -lbenchmark mybenchmark.cc -o mybenchmark\n```\n\nAlternatively, link against the `benchmark_main` library and remove\n`BENCHMARK_MAIN();` above to get the same behavior.\n\nThe compiled executable will run all benchmarks by default. Pass the `--help`\nflag for option information or see the guide below.\n\n### Platform-specific instructions\n\nWhen the library is built using GCC it is necessary to link with the pthread\nlibrary due to how GCC implements `std::thread`. Failing to link to pthread will\nlead to runtime exceptions (unless you're using libc++), not linker errors. See\n[issue #67](https://github.com/google/benchmark/issues/67) for more details. You\ncan link to pthread by adding `-pthread` to your linker command. Note, you can\nalso use `-lpthread`, but there are potential issues with ordering of command\nline parameters if you use that.\n\nIf you're running benchmarks on Windows, the shlwapi library (`-lshlwapi`) is\nalso required.\n\nIf you're running benchmarks on solaris, you'll want the kstat library linked in\ntoo (`-lkstat`).\n\n## User Guide\n\n### Command Line\n[Output Formats](#output-formats)\n\n[Output Files](#output-files)\n\n[Running a Subset of Benchmarks](#running-a-subset-of-benchmarks)\n\n[Result Comparison](#result-comparison)\n\n### Library\n[Runtime and Reporting Considerations](#runtime-and-reporting-considerations)\n\n[Passing Arguments](#passing-arguments)\n\n[Calculating Asymptotic Complexity](#asymptotic-complexity)\n\n[Templated Benchmarks](#templated-benchmarks)\n\n[Fixtures](#fixtures)\n\n[Custom Counters](#custom-counters)\n\n[Multithreaded Benchmarks](#multithreaded-benchmarks)\n\n[CPU Timers](#cpu-timers)\n\n[Manual Timing](#manual-timing)\n\n[Setting the Time Unit](#setting-the-time-unit)\n\n[Preventing Optimization](#preventing-optimization)\n\n[Reporting Statistics](#reporting-statistics)\n\n[Custom Statistics](#custom-statistics)\n\n[Using RegisterBenchmark](#using-register-benchmark)\n\n[Exiting with an Error](#exiting-with-an-error)\n\n[A Faster KeepRunning Loop](#a-faster-keep-running-loop)\n\n[Disabling CPU Frequency Scaling](#disabling-cpu-frequency-scaling)\n\n\u003ca name=\"output-formats\" /\u003e\n\n### Output Formats\n\nThe library supports multiple output formats. Use the\n`--benchmark_format=\u003cconsole|json|csv\u003e` flag to set the format type. `console`\nis the default format.\n\nThe Console format is intended to be a human readable format. By default\nthe format generates color output. Context is output on stderr and the\ntabular data on stdout. Example tabular output looks like:\n```\nBenchmark                               Time(ns)    CPU(ns) Iterations\n----------------------------------------------------------------------\nBM_SetInsert/1024/1                        28928      29349      23853  133.097kB/s   33.2742k items/s\nBM_SetInsert/1024/8                        32065      32913      21375  949.487kB/s   237.372k items/s\nBM_SetInsert/1024/10                       33157      33648      21431  1.13369MB/s   290.225k items/s\n```\n\nThe JSON format outputs human readable json split into two top level attributes.\nThe `context` attribute contains information about the run in general, including\ninformation about the CPU and the date.\nThe `benchmarks` attribute contains a list of every benchmark run. Example json\noutput looks like:\n```json\n{\n  \"context\": {\n    \"date\": \"2015/03/17-18:40:25\",\n    \"num_cpus\": 40,\n    \"mhz_per_cpu\": 2801,\n    \"cpu_scaling_enabled\": false,\n    \"build_type\": \"debug\"\n  },\n  \"benchmarks\": [\n    {\n      \"name\": \"BM_SetInsert/1024/1\",\n      \"iterations\": 94877,\n      \"real_time\": 29275,\n      \"cpu_time\": 29836,\n      \"bytes_per_second\": 134066,\n      \"items_per_second\": 33516\n    },\n    {\n      \"name\": \"BM_SetInsert/1024/8\",\n      \"iterations\": 21609,\n      \"real_time\": 32317,\n      \"cpu_time\": 32429,\n      \"bytes_per_second\": 986770,\n      \"items_per_second\": 246693\n    },\n    {\n      \"name\": \"BM_SetInsert/1024/10\",\n      \"iterations\": 21393,\n      \"real_time\": 32724,\n      \"cpu_time\": 33355,\n      \"bytes_per_second\": 1199226,\n      \"items_per_second\": 299807\n    }\n  ]\n}\n```\n\nThe CSV format outputs comma-separated values. The `context` is output on stderr\nand the CSV itself on stdout. Example CSV output looks like:\n```\nname,iterations,real_time,cpu_time,bytes_per_second,items_per_second,label\n\"BM_SetInsert/1024/1\",65465,17890.7,8407.45,475768,118942,\n\"BM_SetInsert/1024/8\",116606,18810.1,9766.64,3.27646e+06,819115,\n\"BM_SetInsert/1024/10\",106365,17238.4,8421.53,4.74973e+06,1.18743e+06,\n```\n\n\u003ca name=\"output-files\" /\u003e\n\n### Output Files\n\nWrite benchmark results to a file with the `--benchmark_out=\u003cfilename\u003e` option.\nSpecify the output format with `--benchmark_out_format={json|console|csv}`. Note that Specifying\n`--benchmark_out` does not suppress the console output.\n\n\u003ca name=\"running-a-subset-of-benchmarks\" /\u003e\n\n### Running a Subset of Benchmarks\n\nThe `--benchmark_filter=\u003cregex\u003e` option can be used to only run the benchmarks\nwhich match the specified `\u003cregex\u003e`. For example:\n\n```bash\n$ ./run_benchmarks.x --benchmark_filter=BM_memcpy/32\nRun on (1 X 2300 MHz CPU )\n2016-06-25 19:34:24\nBenchmark              Time           CPU Iterations\n----------------------------------------------------\nBM_memcpy/32          11 ns         11 ns   79545455\nBM_memcpy/32k       2181 ns       2185 ns     324074\nBM_memcpy/32          12 ns         12 ns   54687500\nBM_memcpy/32k       1834 ns       1837 ns     357143\n```\n\n\u003ca name=\"result-comparison\" /\u003e\n\n### Result comparison\n\nIt is possible to compare the benchmarking results. See [Additional Tooling Documentation](docs/tools.md)\n\n\u003ca name=\"runtime-and-reporting-considerations\" /\u003e\n\n### Runtime and Reporting Considerations\n\nWhen the benchmark binary is executed, each benchmark function is run serially.\nThe number of iterations to run is determined dynamically by running the\nbenchmark a few times and measuring the time taken and ensuring that the\nultimate result will be statistically stable. As such, faster benchmark\nfunctions will be run for more iterations than slower benchmark functions, and\nthe number of iterations is thus reported.\n\nIn all cases, the number of iterations for which the benchmark is run is\ngoverned by the amount of time the benchmark takes. Concretely, the number of\niterations is at least one, not more than 1e9, until CPU time is greater than\nthe minimum time, or the wallclock time is 5x minimum time. The minimum time is\nset per benchmark by calling `MinTime` on the registered benchmark object.\n\nAverage timings are then reported over the iterations run. If multiple\nrepetitions are requested using the `--benchmark_repetitions` command-line\noption, or at registration time, the benchmark function will be run several\ntimes and statistical results across these repetitions will also be reported.\n\nAs well as the per-benchmark entries, a preamble in the report will include\ninformation about the machine on which the benchmarks are run.\n\n\u003ca name=\"passing-arguments\" /\u003e\n\n### Passing Arguments\n\nSometimes a family of benchmarks can be implemented with just one routine that\ntakes an extra argument to specify which one of the family of benchmarks to\nrun. For example, the following code defines a family of benchmarks for\nmeasuring the speed of `memcpy()` calls of different lengths:\n\n```c++\nstatic void BM_memcpy(benchmark::State\u0026 state) {\n  char* src = new char[state.range(0)];\n  char* dst = new char[state.range(0)];\n  memset(src, 'x', state.range(0));\n  for (auto _ : state)\n    memcpy(dst, src, state.range(0));\n  state.SetBytesProcessed(int64_t(state.iterations()) *\n                          int64_t(state.range(0)));\n  delete[] src;\n  delete[] dst;\n}\nBENCHMARK(BM_memcpy)-\u003eArg(8)-\u003eArg(64)-\u003eArg(512)-\u003eArg(1\u003c\u003c10)-\u003eArg(8\u003c\u003c10);\n```\n\nThe preceding code is quite repetitive, and can be replaced with the following\nshort-hand. The following invocation will pick a few appropriate arguments in\nthe specified range and will generate a benchmark for each such argument.\n\n```c++\nBENCHMARK(BM_memcpy)-\u003eRange(8, 8\u003c\u003c10);\n```\n\nBy default the arguments in the range are generated in multiples of eight and\nthe command above selects [ 8, 64, 512, 4k, 8k ]. In the following code the\nrange multiplier is changed to multiples of two.\n\n```c++\nBENCHMARK(BM_memcpy)-\u003eRangeMultiplier(2)-\u003eRange(8, 8\u003c\u003c10);\n```\nNow arguments generated are [ 8, 16, 32, 64, 128, 256, 512, 1024, 2k, 4k, 8k ].\n\nThe preceding code shows a method of defining a sparse range.  The following\nexample shows a method of defining a dense range. It is then used to benchmark\nthe performance of `std::vector` initialization for uniformly increasing sizes.\n\n```c++\nstatic void BM_DenseRange(benchmark::State\u0026 state) {\n  for(auto _ : state) {\n    std::vector\u003cint\u003e v(state.range(0), state.range(0));\n    benchmark::DoNotOptimize(v.data());\n    benchmark::ClobberMemory();\n  }\n}\nBENCHMARK(BM_DenseRange)-\u003eDenseRange(0, 1024, 128);\n```\nNow arguments generated are [ 0, 128, 256, 384, 512, 640, 768, 896, 1024 ].\n\nYou might have a benchmark that depends on two or more inputs. For example, the\nfollowing code defines a family of benchmarks for measuring the speed of set\ninsertion.\n\n```c++\nstatic void BM_SetInsert(benchmark::State\u0026 state) {\n  std::set\u003cint\u003e data;\n  for (auto _ : state) {\n    state.PauseTiming();\n    data = ConstructRandomSet(state.range(0));\n    state.ResumeTiming();\n    for (int j = 0; j \u003c state.range(1); ++j)\n      data.insert(RandomNumber());\n  }\n}\nBENCHMARK(BM_SetInsert)\n    -\u003eArgs({1\u003c\u003c10, 128})\n    -\u003eArgs({2\u003c\u003c10, 128})\n    -\u003eArgs({4\u003c\u003c10, 128})\n    -\u003eArgs({8\u003c\u003c10, 128})\n    -\u003eArgs({1\u003c\u003c10, 512})\n    -\u003eArgs({2\u003c\u003c10, 512})\n    -\u003eArgs({4\u003c\u003c10, 512})\n    -\u003eArgs({8\u003c\u003c10, 512});\n```\n\nThe preceding code is quite repetitive, and can be replaced with the following\nshort-hand. The following macro will pick a few appropriate arguments in the\nproduct of the two specified ranges and will generate a benchmark for each such\npair.\n\n```c++\nBENCHMARK(BM_SetInsert)-\u003eRanges({{1\u003c\u003c10, 8\u003c\u003c10}, {128, 512}});\n```\n\nFor more complex patterns of inputs, passing a custom function to `Apply` allows\nprogrammatic specification of an arbitrary set of arguments on which to run the\nbenchmark. The following example enumerates a dense range on one parameter,\nand a sparse range on the second.\n\n```c++\nstatic void CustomArguments(benchmark::internal::Benchmark* b) {\n  for (int i = 0; i \u003c= 10; ++i)\n    for (int j = 32; j \u003c= 1024*1024; j *= 8)\n      b-\u003eArgs({i, j});\n}\nBENCHMARK(BM_SetInsert)-\u003eApply(CustomArguments);\n```\n\n#### Passing Arbitrary Arguments to a Benchmark\n\nIn C++11 it is possible to define a benchmark that takes an arbitrary number\nof extra arguments. The `BENCHMARK_CAPTURE(func, test_case_name, ...args)`\nmacro creates a benchmark that invokes `func`  with the `benchmark::State` as\nthe first argument followed by the specified `args...`.\nThe `test_case_name` is appended to the name of the benchmark and\nshould describe the values passed.\n\n```c++\ntemplate \u003cclass ...ExtraArgs\u003e\nvoid BM_takes_args(benchmark::State\u0026 state, ExtraArgs\u0026\u0026... extra_args) {\n  [...]\n}\n// Registers a benchmark named \"BM_takes_args/int_string_test\" that passes\n// the specified values to `extra_args`.\nBENCHMARK_CAPTURE(BM_takes_args, int_string_test, 42, std::string(\"abc\"));\n```\nNote that elements of `...args` may refer to global variables. Users should\navoid modifying global state inside of a benchmark.\n\n\u003ca name=\"asymptotic-complexity\" /\u003e\n\n### Calculating Asymptotic Complexity (Big O)\n\nAsymptotic complexity might be calculated for a family of benchmarks. The\nfollowing code will calculate the coefficient for the high-order term in the\nrunning time and the normalized root-mean square error of string comparison.\n\n```c++\nstatic void BM_StringCompare(benchmark::State\u0026 state) {\n  std::string s1(state.range(0), '-');\n  std::string s2(state.range(0), '-');\n  for (auto _ : state) {\n    benchmark::DoNotOptimize(s1.compare(s2));\n  }\n  state.SetComplexityN(state.range(0));\n}\nBENCHMARK(BM_StringCompare)\n    -\u003eRangeMultiplier(2)-\u003eRange(1\u003c\u003c10, 1\u003c\u003c18)-\u003eComplexity(benchmark::oN);\n```\n\nAs shown in the following invocation, asymptotic complexity might also be\ncalculated automatically.\n\n```c++\nBENCHMARK(BM_StringCompare)\n    -\u003eRangeMultiplier(2)-\u003eRange(1\u003c\u003c10, 1\u003c\u003c18)-\u003eComplexity();\n```\n\nThe following code will specify asymptotic complexity with a lambda function,\nthat might be used to customize high-order term calculation.\n\n```c++\nBENCHMARK(BM_StringCompare)-\u003eRangeMultiplier(2)\n    -\u003eRange(1\u003c\u003c10, 1\u003c\u003c18)-\u003eComplexity([](int64_t n)-\u003edouble{return n; });\n```\n\n\u003ca name=\"templated-benchmarks\" /\u003e\n\n### Templated Benchmarks\n\nThis example produces and consumes messages of size `sizeof(v)` `range_x`\ntimes. It also outputs throughput in the absence of multiprogramming.\n\n```c++\ntemplate \u003cclass Q\u003e void BM_Sequential(benchmark::State\u0026 state) {\n  Q q;\n  typename Q::value_type v;\n  for (auto _ : state) {\n    for (int i = state.range(0); i--; )\n      q.push(v);\n    for (int e = state.range(0); e--; )\n      q.Wait(\u0026v);\n  }\n  // actually messages, not bytes:\n  state.SetBytesProcessed(\n      static_cast\u003cint64_t\u003e(state.iterations())*state.range(0));\n}\nBENCHMARK_TEMPLATE(BM_Sequential, WaitQueue\u003cint\u003e)-\u003eRange(1\u003c\u003c0, 1\u003c\u003c10);\n```\n\nThree macros are provided for adding benchmark templates.\n\n```c++\n#ifdef BENCHMARK_HAS_CXX11\n#define BENCHMARK_TEMPLATE(func, ...) // Takes any number of parameters.\n#else // C++ \u003c C++11\n#define BENCHMARK_TEMPLATE(func, arg1)\n#endif\n#define BENCHMARK_TEMPLATE1(func, arg1)\n#define BENCHMARK_TEMPLATE2(func, arg1, arg2)\n```\n\n\u003ca name=\"fixtures\" /\u003e\n\n### Fixtures\n\nFixture tests are created by first defining a type that derives from\n`::benchmark::Fixture` and then creating/registering the tests using the\nfollowing macros:\n\n* `BENCHMARK_F(ClassName, Method)`\n* `BENCHMARK_DEFINE_F(ClassName, Method)`\n* `BENCHMARK_REGISTER_F(ClassName, Method)`\n\nFor Example:\n\n```c++\nclass MyFixture : public benchmark::Fixture {\npublic:\n  void SetUp(const ::benchmark::State\u0026 state) {\n  }\n\n  void TearDown(const ::benchmark::State\u0026 state) {\n  }\n};\n\nBENCHMARK_F(MyFixture, FooTest)(benchmark::State\u0026 st) {\n   for (auto _ : st) {\n     ...\n  }\n}\n\nBENCHMARK_DEFINE_F(MyFixture, BarTest)(benchmark::State\u0026 st) {\n   for (auto _ : st) {\n     ...\n  }\n}\n/* BarTest is NOT registered */\nBENCHMARK_REGISTER_F(MyFixture, BarTest)-\u003eThreads(2);\n/* BarTest is now registered */\n```\n\n#### Templated Fixtures\n\nAlso you can create templated fixture by using the following macros:\n\n* `BENCHMARK_TEMPLATE_F(ClassName, Method, ...)`\n* `BENCHMARK_TEMPLATE_DEFINE_F(ClassName, Method, ...)`\n\nFor example:\n```c++\ntemplate\u003ctypename T\u003e\nclass MyFixture : public benchmark::Fixture {};\n\nBENCHMARK_TEMPLATE_F(MyFixture, IntTest, int)(benchmark::State\u0026 st) {\n   for (auto _ : st) {\n     ...\n  }\n}\n\nBENCHMARK_TEMPLATE_DEFINE_F(MyFixture, DoubleTest, double)(benchmark::State\u0026 st) {\n   for (auto _ : st) {\n     ...\n  }\n}\n\nBENCHMARK_REGISTER_F(MyFixture, DoubleTest)-\u003eThreads(2);\n```\n\n\u003ca name=\"custom-counters\" /\u003e\n\n### Custom Counters\n\nYou can add your own counters with user-defined names. The example below\nwill add columns \"Foo\", \"Bar\" and \"Baz\" in its output:\n\n```c++\nstatic void UserCountersExample1(benchmark::State\u0026 state) {\n  double numFoos = 0, numBars = 0, numBazs = 0;\n  for (auto _ : state) {\n    // ... count Foo,Bar,Baz events\n  }\n  state.counters[\"Foo\"] = numFoos;\n  state.counters[\"Bar\"] = numBars;\n  state.counters[\"Baz\"] = numBazs;\n}\n```\n\nThe `state.counters` object is a `std::map` with `std::string` keys\nand `Counter` values. The latter is a `double`-like class, via an implicit\nconversion to `double\u0026`. Thus you can use all of the standard arithmetic\nassignment operators (`=,+=,-=,*=,/=`) to change the value of each counter.\n\nIn multithreaded benchmarks, each counter is set on the calling thread only.\nWhen the benchmark finishes, the counters from each thread will be summed;\nthe resulting sum is the value which will be shown for the benchmark.\n\nThe `Counter` constructor accepts three parameters: the value as a `double`\n; a bit flag which allows you to show counters as rates, and/or as per-thread\niteration, and/or as per-thread averages, and/or iteration invariants,\nand/or finally inverting the result; and a flag specifying the 'unit' - i.e.\nis 1k a 1000 (default, `benchmark::Counter::OneK::kIs1000`), or 1024\n(`benchmark::Counter::OneK::kIs1024`)?\n\n```c++\n  // sets a simple counter\n  state.counters[\"Foo\"] = numFoos;\n\n  // Set the counter as a rate. It will be presented divided\n  // by the duration of the benchmark.\n  // Meaning: per one second, how many 'foo's are processed?\n  state.counters[\"FooRate\"] = Counter(numFoos, benchmark::Counter::kIsRate);\n\n  // Set the counter as a rate. It will be presented divided\n  // by the duration of the benchmark, and the result inverted.\n  // Meaning: how many seconds it takes to process one 'foo'?\n  state.counters[\"FooInvRate\"] = Counter(numFoos, benchmark::Counter::kIsRate | benchmark::Counter::kInvert);\n\n  // Set the counter as a thread-average quantity. It will\n  // be presented divided by the number of threads.\n  state.counters[\"FooAvg\"] = Counter(numFoos, benchmark::Counter::kAvgThreads);\n\n  // There's also a combined flag:\n  state.counters[\"FooAvgRate\"] = Counter(numFoos,benchmark::Counter::kAvgThreadsRate);\n\n  // This says that we process with the rate of state.range(0) bytes every iteration:\n  state.counters[\"BytesProcessed\"] = Counter(state.range(0), benchmark::Counter::kIsIterationInvariantRate, benchmark::Counter::OneK::kIs1024);\n```\n\nWhen you're compiling in C++11 mode or later you can use `insert()` with\n`std::initializer_list`:\n\n```c++\n  // With C++11, this can be done:\n  state.counters.insert({{\"Foo\", numFoos}, {\"Bar\", numBars}, {\"Baz\", numBazs}});\n  // ... instead of:\n  state.counters[\"Foo\"] = numFoos;\n  state.counters[\"Bar\"] = numBars;\n  state.counters[\"Baz\"] = numBazs;\n```\n\n#### Counter Reporting\n\nWhen using the console reporter, by default, user counters are printed at\nthe end after the table, the same way as ``bytes_processed`` and\n``items_processed``. This is best for cases in which there are few counters,\nor where there are only a couple of lines per benchmark. Here's an example of\nthe default output:\n\n```\n------------------------------------------------------------------------------\nBenchmark                        Time           CPU Iterations UserCounters...\n------------------------------------------------------------------------------\nBM_UserCounter/threads:8      2248 ns      10277 ns      68808 Bar=16 Bat=40 Baz=24 Foo=8\nBM_UserCounter/threads:1      9797 ns       9788 ns      71523 Bar=2 Bat=5 Baz=3 Foo=1024m\nBM_UserCounter/threads:2      4924 ns       9842 ns      71036 Bar=4 Bat=10 Baz=6 Foo=2\nBM_UserCounter/threads:4      2589 ns      10284 ns      68012 Bar=8 Bat=20 Baz=12 Foo=4\nBM_UserCounter/threads:8      2212 ns      10287 ns      68040 Bar=16 Bat=40 Baz=24 Foo=8\nBM_UserCounter/threads:16     1782 ns      10278 ns      68144 Bar=32 Bat=80 Baz=48 Foo=16\nBM_UserCounter/threads:32     1291 ns      10296 ns      68256 Bar=64 Bat=160 Baz=96 Foo=32\nBM_UserCounter/threads:4      2615 ns      10307 ns      68040 Bar=8 Bat=20 Baz=12 Foo=4\nBM_Factorial                    26 ns         26 ns   26608979 40320\nBM_Factorial/real_time          26 ns         26 ns   26587936 40320\nBM_CalculatePiRange/1           16 ns         16 ns   45704255 0\nBM_CalculatePiRange/8           73 ns         73 ns    9520927 3.28374\nBM_CalculatePiRange/64         609 ns        609 ns    1140647 3.15746\nBM_CalculatePiRange/512       4900 ns       4901 ns     142696 3.14355\n```\n\nIf this doesn't suit you, you can print each counter as a table column by\npassing the flag `--benchmark_counters_tabular=true` to the benchmark\napplication. This is best for cases in which there are a lot of counters, or\na lot of lines per individual benchmark. Note that this will trigger a\nreprinting of the table header any time the counter set changes between\nindividual benchmarks. Here's an example of corresponding output when\n`--benchmark_counters_tabular=true` is passed:\n\n```\n---------------------------------------------------------------------------------------\nBenchmark                        Time           CPU Iterations    Bar   Bat   Baz   Foo\n---------------------------------------------------------------------------------------\nBM_UserCounter/threads:8      2198 ns       9953 ns      70688     16    40    24     8\nBM_UserCounter/threads:1      9504 ns       9504 ns      73787      2     5     3     1\nBM_UserCounter/threads:2      4775 ns       9550 ns      72606      4    10     6     2\nBM_UserCounter/threads:4      2508 ns       9951 ns      70332      8    20    12     4\nBM_UserCounter/threads:8      2055 ns       9933 ns      70344     16    40    24     8\nBM_UserCounter/threads:16     1610 ns       9946 ns      70720     32    80    48    16\nBM_UserCounter/threads:32     1192 ns       9948 ns      70496     64   160    96    32\nBM_UserCounter/threads:4      2506 ns       9949 ns      70332      8    20    12     4\n--------------------------------------------------------------\nBenchmark                        Time           CPU Iterations\n--------------------------------------------------------------\nBM_Factorial                    26 ns         26 ns   26392245 40320\nBM_Factorial/real_time          26 ns         26 ns   26494107 40320\nBM_CalculatePiRange/1           15 ns         15 ns   45571597 0\nBM_CalculatePiRange/8           74 ns         74 ns    9450212 3.28374\nBM_CalculatePiRange/64         595 ns        595 ns    1173901 3.15746\nBM_CalculatePiRange/512       4752 ns       4752 ns     147380 3.14355\nBM_CalculatePiRange/4k       37970 ns      37972 ns      18453 3.14184\nBM_CalculatePiRange/32k     303733 ns     303744 ns       2305 3.14162\nBM_CalculatePiRange/256k   2434095 ns    2434186 ns        288 3.1416\nBM_CalculatePiRange/1024k  9721140 ns    9721413 ns         71 3.14159\nBM_CalculatePi/threads:8      2255 ns       9943 ns      70936\n```\nNote above the additional header printed when the benchmark changes from\n``BM_UserCounter`` to ``BM_Factorial``. This is because ``BM_Factorial`` does\nnot have the same counter set as ``BM_UserCounter``.\n\n\u003ca name=\"multithreaded-benchmarks\"/\u003e\n\n### Multithreaded Benchmarks\n\nIn a multithreaded test (benchmark invoked by multiple threads simultaneously),\nit is guaranteed that none of the threads will start until all have reached\nthe start of the benchmark loop, and all will have finished before any thread\nexits the benchmark loop. (This behavior is also provided by the `KeepRunning()`\nAPI) As such, any global setup or teardown can be wrapped in a check against the thread\nindex:\n\n```c++\nstatic void BM_MultiThreaded(benchmark::State\u0026 state) {\n  if (state.thread_index == 0) {\n    // Setup code here.\n  }\n  for (auto _ : state) {\n    // Run the test as normal.\n  }\n  if (state.thread_index == 0) {\n    // Teardown code here.\n  }\n}\nBENCHMARK(BM_MultiThreaded)-\u003eThreads(2);\n```\n\nIf the benchmarked code itself uses threads and you want to compare it to\nsingle-threaded code, you may want to use real-time (\"wallclock\") measurements\nfor latency comparisons:\n\n```c++\nBENCHMARK(BM_test)-\u003eRange(8, 8\u003c\u003c10)-\u003eUseRealTime();\n```\n\nWithout `UseRealTime`, CPU time is used by default.\n\n\u003ca name=\"cpu-timers\" /\u003e\n\n### CPU Timers\n\nBy default, the CPU timer only measures the time spent by the main thread.\nIf the benchmark itself uses threads internally, this measurement may not\nbe what you are looking for. Instead, there is a way to measure the total\nCPU usage of the process, by all the threads.\n\n```c++\nvoid callee(int i);\n\nstatic void MyMain(int size) {\n#pragma omp parallel for\n  for(int i = 0; i \u003c size; i++)\n    callee(i);\n}\n\nstatic void BM_OpenMP(benchmark::State\u0026 state) {\n  for (auto _ : state)\n    MyMain(state.range(0);\n}\n\n// Measure the time spent by the main thread, use it to decide for how long to\n// run the benchmark loop. Depending on the internal implementation detail may\n// measure to anywhere from near-zero (the overhead spent before/after work\n// handoff to worker thread[s]) to the whole single-thread time.\nBENCHMARK(BM_OpenMP)-\u003eRange(8, 8\u003c\u003c10);\n\n// Measure the user-visible time, the wall clock (literally, the time that\n// has passed on the clock on the wall), use it to decide for how long to\n// run the benchmark loop. This will always be meaningful, an will match the\n// time spent by the main thread in single-threaded case, in general decreasing\n// with the number of internal threads doing the work.\nBENCHMARK(BM_OpenMP)-\u003eRange(8, 8\u003c\u003c10)-\u003eUseRealTime();\n\n// Measure the total CPU consumption, use it to decide for how long to\n// run the benchmark loop. This will always measure to no less than the\n// time spent by the main thread in single-threaded case.\nBENCHMARK(BM_OpenMP)-\u003eRange(8, 8\u003c\u003c10)-\u003eMeasureProcessCPUTime();\n\n// A mixture of the last two. Measure the total CPU consumption, but use the\n// wall clock to decide for how long to run the benchmark loop.\nBENCHMARK(BM_OpenMP)-\u003eRange(8, 8\u003c\u003c10)-\u003eMeasureProcessCPUTime()-\u003eUseRealTime();\n```\n\n#### Controlling Timers\n\nNormally, the entire duration of the work loop (`for (auto _ : state) {}`)\nis measured. But sometimes, it is necessary to do some work inside of\nthat loop, every iteration, but without counting that time to the benchmark time.\nThat is possible, although it is not recommended, since it has high overhead.\n\n```c++\nstatic void BM_SetInsert_With_Timer_Control(benchmark::State\u0026 state) {\n  std::set\u003cint\u003e data;\n  for (auto _ : state) {\n    state.PauseTiming(); // Stop timers. They will not count until they are resumed.\n    data = ConstructRandomSet(state.range(0)); // Do something that should not be measured\n    state.ResumeTiming(); // And resume timers. They are now counting again.\n    // The rest will be measured.\n    for (int j = 0; j \u003c state.range(1); ++j)\n      data.insert(RandomNumber());\n  }\n}\nBENCHMARK(BM_SetInsert_With_Timer_Control)-\u003eRanges({{1\u003c\u003c10, 8\u003c\u003c10}, {128, 512}});\n```\n\n\u003ca name=\"manual-timing\" /\u003e\n\n### Manual Timing\n\nFor benchmarking something for which neither CPU time nor real-time are\ncorrect or accurate enough, completely manual timing is supported using\nthe `UseManualTime` function.\n\nWhen `UseManualTime` is used, the benchmarked code must call\n`SetIterationTime` once per iteration of the benchmark loop to\nreport the manually measured time.\n\nAn example use case for this is benchmarking GPU execution (e.g. OpenCL\nor CUDA kernels, OpenGL or Vulkan or Direct3D draw calls), which cannot\nbe accurately measured using CPU time or real-time. Instead, they can be\nmeasured accurately using a dedicated API, and these measurement results\ncan be reported back with `SetIterationTime`.\n\n```c++\nstatic void BM_ManualTiming(benchmark::State\u0026 state) {\n  int microseconds = state.range(0);\n  std::chrono::duration\u003cdouble, std::micro\u003e sleep_duration {\n    static_cast\u003cdouble\u003e(microseconds)\n  };\n\n  for (auto _ : state) {\n    auto start = std::chrono::high_resolution_clock::now();\n    // Simulate some useful workload with a sleep\n    std::this_thread::sleep_for(sleep_duration);\n    auto end   = std::chrono::high_resolution_clock::now();\n\n    auto elapsed_seconds =\n      std::chrono::duration_cast\u003cstd::chrono::duration\u003cdouble\u003e\u003e(\n        end - start);\n\n    state.SetIterationTime(elapsed_seconds.count());\n  }\n}\nBENCHMARK(BM_ManualTiming)-\u003eRange(1, 1\u003c\u003c17)-\u003eUseManualTime();\n```\n\n\u003ca name=\"setting-the-time-unit\" /\u003e\n\n### Setting the Time Unit\n\nIf a benchmark runs a few milliseconds it may be hard to visually compare the\nmeasured times, since the output data is given in nanoseconds per default. In\norder to manually set the time unit, you can specify it manually:\n\n```c++\nBENCHMARK(BM_test)-\u003eUnit(benchmark::kMillisecond);\n```\n\n\u003ca name=\"preventing-optimization\" /\u003e\n\n### Preventing Optimization\n\nTo prevent a value or expression from being optimized away by the compiler\nthe `benchmark::DoNotOptimize(...)` and `benchmark::ClobberMemory()`\nfunctions can be used.\n\n```c++\nstatic void BM_test(benchmark::State\u0026 state) {\n  for (auto _ : state) {\n      int x = 0;\n      for (int i=0; i \u003c 64; ++i) {\n        benchmark::DoNotOptimize(x += i);\n      }\n  }\n}\n```\n\n`DoNotOptimize(\u003cexpr\u003e)` forces the  *result* of `\u003cexpr\u003e` to be stored in either\nmemory or a register. For GNU based compilers it acts as read/write barrier\nfor global memory. More specifically it forces the compiler to flush pending\nwrites to memory and reload any other values as necessary.\n\nNote that `DoNotOptimize(\u003cexpr\u003e)` does not prevent optimizations on `\u003cexpr\u003e`\nin any way. `\u003cexpr\u003e` may even be removed entirely when the result is already\nknown. For example:\n\n```c++\n  /* Example 1: `\u003cexpr\u003e` is removed entirely. */\n  int foo(int x) { return x + 42; }\n  while (...) DoNotOptimize(foo(0)); // Optimized to DoNotOptimize(42);\n\n  /*  Example 2: Result of '\u003cexpr\u003e' is only reused */\n  int bar(int) __attribute__((const));\n  while (...) DoNotOptimize(bar(0)); // Optimized to:\n  // int __result__ = bar(0);\n  // while (...) DoNotOptimize(__result__);\n```\n\nThe second tool for preventing optimizations is `ClobberMemory()`. In essence\n`ClobberMemory()` forces the compiler to perform all pending writes to global\nmemory. Memory managed by block scope objects must be \"escaped\" using\n`DoNotOptimize(...)` before it can be clobbered. In the below example\n`ClobberMemory()` prevents the call to `v.push_back(42)` from being optimized\naway.\n\n```c++\nstatic void BM_vector_push_back(benchmark::State\u0026 state) {\n  for (auto _ : state) {\n    std::vector\u003cint\u003e v;\n    v.reserve(1);\n    benchmark::DoNotOptimize(v.data()); // Allow v.data() to be clobbered.\n    v.push_back(42);\n    benchmark::ClobberMemory(); // Force 42 to be written to memory.\n  }\n}\n```\n\nNote that `ClobberMemory()` is only available for GNU or MSVC based compilers.\n\n\u003ca name=\"reporting-statistics\" /\u003e\n\n### Statistics: Reporting the Mean, Median and Standard Deviation of Repeated Benchmarks\n\nBy default each benchmark is run once and that single result is reported.\nHowever benchmarks are often noisy and a single result may not be representative\nof the overall behavior. For this reason it's possible to repeatedly rerun the\nbenchmark.\n\nThe number of runs of each benchmark is specified globally by the\n`--benchmark_repetitions` flag or on a per benchmark basis by calling\n`Repetitions` on the registered benchmark object. When a benchmark is run more\nthan once the mean, median and standard deviation of the runs will be reported.\n\nAdditionally the `--benchmark_report_aggregates_only={true|false}`,\n`--benchmark_display_aggregates_only={true|false}` flags or\n`ReportAggregatesOnly(bool)`, `DisplayAggregatesOnly(bool)` functions can be\nused to change how repeated tests are reported. By default the result of each\nrepeated run is reported. When `report aggregates only` option is `true`,\nonly the aggregates (i.e. mean, median and standard deviation, maybe complexity\nmeasurements if they were requested) of the runs is reported, to both the\nreporters - standard output (console), and the file.\nHowever when only the `display aggregates only` option is `true`,\nonly the aggregates are displayed in the standard output, while the file\noutput still contains everything.\nCalling `ReportAggregatesOnly(bool)` / `DisplayAggregatesOnly(bool)` on a\nregistered benchmark object overrides the value of the appropriate flag for that\nbenchmark.\n\n\u003ca name=\"custom-statistics\" /\u003e\n\n### Custom Statistics\n\nWhile having mean, median and standard deviation is nice, this may not be\nenough for everyone. For example you may want to know what the largest\nobservation is, e.g. because you have some real-time constraints. This is easy.\nThe following code will specify a custom statistic to be calculated, defined\nby a lambda function.\n\n```c++\nvoid BM_spin_empty(benchmark::State\u0026 state) {\n  for (auto _ : state) {\n    for (int x = 0; x \u003c state.range(0); ++x) {\n      benchmark::DoNotOptimize(x);\n    }\n  }\n}\n\nBENCHMARK(BM_spin_empty)\n  -\u003eComputeStatistics(\"max\", [](const std::vector\u003cdouble\u003e\u0026 v) -\u003e double {\n    return *(std::max_element(std::begin(v), std::end(v)));\n  })\n  -\u003eArg(512);\n```\n\n\u003ca name=\"using-register-benchmark\" /\u003e\n\n### Using RegisterBenchmark(name, fn, args...)\n\nThe `RegisterBenchmark(name, func, args...)` function provides an alternative\nway to create and register benchmarks.\n`RegisterBenchmark(name, func, args...)` creates, registers, and returns a\npointer to a new benchmark with the specified `name` that invokes\n`func(st, args...)` where `st` is a `benchmark::State` object.\n\nUnlike the `BENCHMARK` registration macros, which can only be used at the global\nscope, the `RegisterBenchmark` can be called anywhere. This allows for\nbenchmark tests to be registered programmatically.\n\nAdditionally `RegisterBenchmark` allows any callable object to be registered\nas a benchmark. Including capturing lambdas and function objects.\n\nFor Example:\n```c++\nauto BM_test = [](benchmark::State\u0026 st, auto Inputs) { /* ... */ };\n\nint main(int argc, char** argv) {\n  for (auto\u0026 test_input : { /* ... */ })\n      benchmark::RegisterBenchmark(test_input.name(), BM_test, test_input);\n  benchmark::Initialize(\u0026argc, argv);\n  benchmark::RunSpecifiedBenchmarks();\n}\n```\n\n\u003ca name=\"exiting-with-an-error\" /\u003e\n\n### Exiting with an Error\n\nWhen errors caused by external influences, such as file I/O and network\ncommunication, occur within a benchmark the\n`State::SkipWithError(const char* msg)` function can be used to skip that run\nof benchmark and report the error. Note that only future iterations of the\n`KeepRunning()` are skipped. For the ranged-for version of the benchmark loop\nUsers must explicitly exit the loop, otherwise all iterations will be performed.\nUsers may explicitly return to exit the benchmark immediately.\n\nThe `SkipWithError(...)` function may be used at any point within the benchmark,\nincluding before and after the benchmark loop.\n\nFor example:\n\n```c++\nstatic void BM_test(benchmark::State\u0026 state) {\n  auto resource = GetResource();\n  if (!resource.good()) {\n      state.SkipWithError(\"Resource is not good!\");\n      // KeepRunning() loop will not be entered.\n  }\n  while (state.KeepRunning()) {\n      auto data = resource.read_data();\n      if (!resource.good()) {\n        state.SkipWithError(\"Failed to read data!\");\n        break; // Needed to skip the rest of the iteration.\n     }\n     do_stuff(data);\n  }\n}\n\nstatic void BM_test_ranged_fo(benchmark::State \u0026 state) {\n  state.SkipWithError(\"test will not be entered\");\n  for (auto _ : state) {\n    state.SkipWithError(\"Failed!\");\n    break; // REQUIRED to prevent all further iterations.\n  }\n}\n```\n\u003ca name=\"a-faster-keep-running-loop\" /\u003e\n\n### A Faster KeepRunning Loop\n\nIn C++11 mode, a ranged-based for loop should be used in preference to\nthe `KeepRunning` loop for running the benchmarks. For example:\n\n```c++\nstatic void BM_Fast(benchmark::State \u0026state) {\n  for (auto _ : state) {\n    FastOperation();\n  }\n}\nBENCHMARK(BM_Fast);\n```\n\nThe reason the ranged-for loop is faster than using `KeepRunning`, is\nbecause `KeepRunning` requires a memory load and store of the iteration count\never iteration, whereas the ranged-for variant is able to keep the iteration count\nin a register.\n\nFor example, an empty inner loop of using the ranged-based for method looks like:\n\n```asm\n# Loop Init\n  mov rbx, qword ptr [r14 + 104]\n  call benchmark::State::StartKeepRunning()\n  test rbx, rbx\n  je .LoopEnd\n.LoopHeader: # =\u003eThis Inner Loop Header: Depth=1\n  add rbx, -1\n  jne .LoopHeader\n.LoopEnd:\n```\n\nCompared to an empty `KeepRunning` loop, which looks like:\n\n```asm\n.LoopHeader: # in Loop: Header=BB0_3 Depth=1\n  cmp byte ptr [rbx], 1\n  jne .LoopInit\n.LoopBody: # =\u003eThis Inner Loop Header: Depth=1\n  mov rax, qword ptr [rbx + 8]\n  lea rcx, [rax + 1]\n  mov qword ptr [rbx + 8], rcx\n  cmp rax, qword ptr [rbx + 104]\n  jb .LoopHeader\n  jmp .LoopEnd\n.LoopInit:\n  mov rdi, rbx\n  call benchmark::State::StartKeepRunning()\n  jmp .LoopBody\n.LoopEnd:\n```\n\nUnless C++03 compatibility is required, the ranged-for variant of writing\nthe benchmark loop should be preferred.\n\n\u003ca name=\"disabling-cpu-frequency-scaling\" /\u003e\n\n### Disabling CPU Frequency Scaling\nIf you see this error:\n```\n***WARNING*** CPU scaling is enabled, the benchmark real time measurements may be noisy and will incur extra overhead.\n```\nyou might want to disable the CPU frequency scaling while running the benchmark:\n```bash\nsudo cpupower frequency-set --governor performance\n./mybench\nsudo cpupower frequency-set --governor powersave\n```\n","versions":[{"ref":"master","manifest":"targets = [ \"//:benchmark\" ]\n","lockFile":"manifest = \"e635ffbdaf26bc990986d8a9dc1a8eb214f842495d39e60391835f34f4341935\"\n\n","buck":"load('//:subdir_glob.bzl', 'subdir_glob')\n\ncxx_library(\n  name = 'benchmark',\n  header_namespace = '',\n  exported_headers = subdir_glob([\n    ('include', '**/*.hpp'),\n    ('include', '**/*.h'),\n  ]),\n  headers = subdir_glob([\n    ('src', '**/*.h'),\n  ]),\n  srcs = glob([\n    'src/**/*.cc',\n  ], exclude = [\n    'src/benchmark_main.cc',\n  ]),\n  licenses = [\n    'LICENSE',\n  ],\n  exported_linker_flags = [\n    '-pthread',\n  ],\n  visibility = [\n    'PUBLIC',\n  ],\n)\n\ncxx_binary(\n  name = 'benchmark_main',\n  srcs = [\n    'src/benchmark_main.cc',\n  ],\n  deps = [\n    ':benchmark',\n  ],\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-09-06T07:54:41Z","updatedUpstream":"2021-01-13T19:40:22Z","contributors":[{"login":"ianloic","avatarUrl":"https://avatars2.githubusercontent.com/u/604?v=4"},{"login":"yesudeep","avatarUrl":"https://avatars3.githubusercontent.com/u/3874?u=500ff8aa3e1218a5cc29873a03e35efe1e5d3bdb\u0026v=4"},{"login":"Constellation","avatarUrl":"https://avatars3.githubusercontent.com/u/9023?u=762f3f03adaa12057ce77a2d6061cea367ce727c\u0026v=4"},{"login":"pwnall","avatarUrl":"https://avatars1.githubusercontent.com/u/11460?u=6b2561f5dc40b851f0218da848ed1fa29f4fcfa6\u0026v=4"},{"login":"lenary","avatarUrl":"https://avatars1.githubusercontent.com/u/14548?u=ada5247f730cd19c79af29efd0e28c249d4a59c0\u0026v=4"},{"login":"eddyxu","avatarUrl":"https://avatars0.githubusercontent.com/u/17097?v=4"},{"login":"mumumu","avatarUrl":"https://avatars3.githubusercontent.com/u/26536?u=1811e70e40b05e13c004bac87bb990736ceb8ddc\u0026v=4"},{"login":"mneumann","avatarUrl":"https://avatars0.githubusercontent.com/u/34112?v=4"},{"login":"pphaneuf","avatarUrl":"https://avatars1.githubusercontent.com/u/40400?v=4"},{"login":"rnk","avatarUrl":"https://avatars2.githubusercontent.com/u/50126?u=b5da419f3e0759a66c36051eaddb1f6dd2921a04\u0026v=4"},{"login":"guanqun","avatarUrl":"https://avatars0.githubusercontent.com/u/53862?v=4"},{"login":"mstorsjo","avatarUrl":"https://avatars2.githubusercontent.com/u/69727?v=4"},{"login":"bryan-lunt","avatarUrl":"https://avatars3.githubusercontent.com/u/76123?v=4"},{"login":"LebedevRI","avatarUrl":"https://avatars1.githubusercontent.com/u/88600?v=4"},{"login":"skye","avatarUrl":"https://avatars1.githubusercontent.com/u/88808?v=4"},{"login":"davidreynolds","avatarUrl":"https://avatars3.githubusercontent.com/u/88954?v=4"},{"login":"hydroo","avatarUrl":"https://avatars0.githubusercontent.com/u/111201?u=3a76ce945085f2d2f2c0557e0116e328c3f5c609\u0026v=4"},{"login":"ckennelly","avatarUrl":"https://avatars1.githubusercontent.com/u/135530?v=4"},{"login":"dkruger","avatarUrl":"https://avatars2.githubusercontent.com/u/146851?u=42db0f738c10605d21afc8cf0a9b5bf16ec143f1\u0026v=4"},{"login":"NewProggie","avatarUrl":"https://avatars1.githubusercontent.com/u/162319?u=d8a6119d39f7ef22533d9063935f313583a03246\u0026v=4"},{"login":"cdibona","avatarUrl":"https://avatars1.githubusercontent.com/u/165353?v=4"},{"login":"alexreinking","avatarUrl":"https://avatars2.githubusercontent.com/u/169273?u=787c07702f45b0ab4c8bc487496b333dd67f6cf3\u0026v=4"},{"login":"luismarques","avatarUrl":"https://avatars0.githubusercontent.com/u/171812?v=4"},{"login":"rolandschulz","avatarUrl":"https://avatars0.githubusercontent.com/u/204273?u=0389592789a4e15b2e3308c2dce390afd4b4feec\u0026v=4"},{"login":"yixuan","avatarUrl":"https://avatars2.githubusercontent.com/u/216398?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":5064,"forks":970,"topics":["benchmark"]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"google-benchmark"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>