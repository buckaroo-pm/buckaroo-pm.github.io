<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/attractivechaos-klib/logo.png"/></div><div><h1>buckaroo-pm/attractivechaos-klib</h1><div style="max-width:600px">A standalone and lightweight C library</div><br/><div><b>3170</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">c</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">generic</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">library</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">hashtable</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">b-tree</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">avl-tree</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">sort</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">algorithm</span></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">LockFile</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><h1>Klib: a Generic Library in C</h1><h2>&lt;a name=&quot;overview&quot;&gt;<!-- -->&lt;/a&gt;<!-- -->Overview</h2><p>Klib is a standalone and lightweight C library distributed under <a href="http://en.wikipedia.org/wiki/MIT_License">MIT/X11
license</a>. Most components are independent of external libraries, except the
standard C library, and independent of each other. To use a component of this
library, you only need to copy a couple of files to your source code tree
without worrying about library dependencies.</p><p>Klib strives for efficiency and a small memory footprint. Some components, such
as khash.h, kbtree.h, ksort.h and kvec.h, are among the most efficient
implementations of similar algorithms or data structures in all programming
languages, in terms of both speed and memory use.</p><p>A new documentation is available <a href="http://attractivechaos.github.io/klib/">here</a>
which includes most information in this README file.</p><h4>Common components</h4><ul><li><a href="http://attractivechaos.github.io/klib/#Khash%3A%20generic%20hash%20table:%5B%5BKhash%3A%20generic%20hash%20table%5D%5D">khash.h</a>: generic <a href="https://en.wikipedia.org/wiki/Hash_table">hash table</a> with open addressing.</li><li><a href="http://attractivechaos.github.io/klib/#KBtree%3A%20generic%20ordered%20map:%5B%5BKBtree%3A%20generic%20ordered%20map%5D%5D">kbtree.h</a>: generic search tree based on <a href="http://en.wikipedia.org/wiki/B-tree">B-tree</a>.</li><li><a href="http://attractivechaos.github.io/klib/#KAVL%3A%20generic%20intrusive%20AVL%20tree">kavl.h</a>: generic intrusive <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL tree</a>.</li><li><a href="http://attractivechaos.github.io/klib/#Ksort%3A%20sorting%2C%20shuffling%2C%20heap%20and%20k-small:%5B%5BKsort%3A%20sorting%2C%20shuffling%2C%20heap%20and%20k-small%5D%5D">ksort.h</a>: generic sort, including <a href="http://en.wikipedia.org/wiki/Introsort">introsort</a>, <a href="http://en.wikipedia.org/wiki/Merge_sort">merge sort</a>, <a href="http://en.wikipedia.org/wiki/Heapsort">heap sort</a>, <a href="http://en.wikipedia.org/wiki/Comb_sort">comb sort</a>, <a href="http://en.wikipedia.org/wiki/Fisher-Yates_shuffle">Knuth shuffle</a> and the <a href="http://en.wikipedia.org/wiki/Selection_algorithm">k-small</a> algorithm.</li><li><a href="http://attractivechaos.github.io/klib/#Kseq%3A%20stream%20buffer%20and%20FASTA%2FQ%20parser:%5B%5BKseq%3A%20stream%20buffer%20and%20FASTA%2FQ%20parser%5D%5D">kseq.h</a>: generic stream buffer and a <a href="http://en.wikipedia.org/wiki/FASTA_format">FASTA</a>/<a href="http://en.wikipedia.org/wiki/FASTQ_format">FASTQ</a> format parser.</li><li>kvec.h: generic dynamic array.</li><li>klist.h: generic single-linked list and <a href="http://en.wikipedia.org/wiki/Memory_pool">memory pool</a>.</li><li>kstring.{h,c}: basic string library.</li><li>kmath.{h,c}: numerical routines including <a href="http://en.wikipedia.org/wiki/Mersenne_twister">MT19937-64</a> <a href="http://en.wikipedia.org/wiki/Pseudorandom_generator">pseudorandom generator</a>, basic <a href="http://en.wikipedia.org/wiki/Nonlinear_programming">nonlinear programming</a> and a few special math functions.</li><li><a href="http://attractivechaos.github.io/klib/#Ketopt%3A%20parsing%20command-line%20arguments">ketopt.h</a>: portable command-line argument parser with getopt_long-like API.</li></ul><h4>Components for more specific use cases</h4><ul><li>ksa.c: constructing <a href="http://en.wikipedia.org/wiki/Suffix_array">suffix arrays</a> for strings with multiple sentinels, based on a revised <a href="https://sites.google.com/site/yuta256/sais">SAIS algorithm</a>.</li><li>knetfile.{h,c}: random access to remote files on HTTP or FTP.</li><li>kopen.c: smart stream opening.</li><li>khmm.{h,c}: basic <a href="http://en.wikipedia.org/wiki/Hidden_Markov_model">HMM</a> library.</li><li>ksw.(h,c}: Striped <a href="http://en.wikipedia.org/wiki/Smith-Waterman_algorithm">Smith-Waterman algorithm</a>.</li><li>knhx.{h,c}: <a href="http://en.wikipedia.org/wiki/Newick_format">Newick tree format</a> parser.</li></ul><h2>&lt;a name=&quot;methodology&quot;&gt;<!-- -->&lt;/a&gt;<!-- -->Methodology</h2><p>For the implementation of generic <a href="http://en.wikipedia.org/wiki/Container_(abstract_data_type)">containers</a>, klib extensively uses C
macros. To use these data structures, we usually need to instantiate methods by
expanding a long macro. This makes the source code look unusual or even ugly
and adds difficulty to debugging. Unfortunately, for efficient generic
programming in C that lacks <a href="http://en.wikipedia.org/wiki/Template_(C%2B%2B)">template</a>, using macros is the only
solution. Only with macros, we can write a generic container which, once
instantiated, compete with a type-specific container in efficiency. Some
generic libraries in C, such as <a href="http://en.wikipedia.org/wiki/GLib">Glib</a>, use the <code>void*</code> type to implement
containers. These implementations are usually slower and use more memory than
klib (see <a href="http://attractivechaos.wordpress.com/2008/10/07/another-look-at-my-old-benchmark/">this benchmark</a>).</p><p>To effectively use klib, it is important to understand how it achieves generic
programming. We will use the hash table library as an example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#include &quot;khash.h&quot;
</span>KHASH_MAP_INIT_INT(m32, char)        // instantiate structs and methods
<!-- -->int main() {
<!-- -->    int ret, is_missing;
<!-- -->    khint_t k;
<!-- -->    khash_t(m32) *h = kh_init(m32);  // allocate a hash table
<!-- -->    k = kh_put(m32, h, 5, &amp;ret);     // insert a key to the hash table
<!-- -->    if (!ret) kh_del(m32, h, k);
<!-- -->    kh_value(h, k) = 10;             // set the value
<!-- -->    k = kh_get(m32, h, 10);          // query the hash table
<!-- -->    is_missing = (k == kh_end(h));   // test if the key is present
<!-- -->    k = kh_get(m32, h, 5);
<!-- -->    kh_del(m32, h, k);               // remove a key-value pair
<!-- -->    for (k = kh_begin(h); k != kh_end(h); ++k)  // traverse
<!-- -->        if (kh_exist(h, k))          // test if a bucket contains data
<!-- -->			kh_value(h, k) = 1;
<!-- -->    kh_destroy(m32, h);              // deallocate the hash table
<!-- -->    return 0;
<!-- -->}
</code></pre><p>In this example, the second line instantiates a hash table with <code>unsigned</code> as
the key type and <code>char</code> as the value type. <code>m32</code> names such a type of hash table.
All types and functions associated with this name are macros, which will be
explained later. Macro <code>kh_init()</code> initiates a hash table and <code>kh_destroy()</code>
frees it. <code>kh_put()</code> inserts a key and returns the iterator (or the position)
in the hash table. <code>kh_get()</code> and <code>kh_del()</code> get a key and delete an element,
respectively. Macro <code>kh_exist()</code> tests if an iterator (or a position) is filled
with data.</p><p>An immediate question is this piece of code does not look like a valid C
program (e.g. lacking semicolon, assignment to an <em>apparent</em> function call and
<em>apparent</em> undefined <code>m32</code> &#x27;variable&#x27;). To understand why the code is correct,
let&#x27;s go a bit further into the source code of <code>khash.h</code>, whose skeleton looks
like:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#define KHASH_INIT(name, SCOPE, key_t, val_t, is_map, _hashf, _hasheq) \
</span>  typedef struct { \
<!-- -->    int n_buckets, size, n_occupied, upper_bound; \
<!-- -->    unsigned *flags; \
<!-- -->    key_t *keys; \
<!-- -->    val_t *vals; \
<!-- -->  } kh_##name##_t; \
<!-- -->  SCOPE inline kh_##name##_t *init_##name() { \
<!-- -->    return (kh_##name##_t*)calloc(1, sizeof(kh_##name##_t)); \
<!-- -->  } \
<!-- -->  SCOPE inline int get_##name(kh_##name##_t *h, key_t k) \
<!-- -->  ... \
<!-- -->  SCOPE inline void destroy_##name(kh_##name##_t *h) { \
<!-- -->    if (h) { \
<!-- -->      free(h-&gt;keys); free(h-&gt;flags); free(h-&gt;vals); free(h); \
<!-- -->    } \
<!-- -->  }
<!-- -->
<!-- -->#define _int_hf(key) (unsigned)(key)
<!-- -->#define _int_heq(a, b) (a == b)
<!-- -->#define khash_t(name) kh_##name##_t
<!-- -->#define kh_value(h, k) ((h)-&gt;vals[k])
<!-- -->#define kh_begin(h, k) 0
<!-- -->#define kh_end(h) ((h)-&gt;n_buckets)
<!-- -->#define kh_init(name) init_##name()
<!-- -->#define kh_get(name, h, k) get_##name(h, k)
<!-- -->#define kh_destroy(name, h) destroy_##name(h)
<!-- -->...
<!-- -->#define KHASH_MAP_INIT_INT(name, val_t) \
<!-- -->	KHASH_INIT(name, static, unsigned, val_t, is_map, _int_hf, _int_heq)
</code></pre><p><code>KHASH_INIT()</code> is a huge macro defining all the structs and methods. When this
macro is called, all the code inside it will be inserted by the <a href="http://en.wikipedia.org/wiki/C_preprocessor">C
preprocess</a> to the place where it is called. If the macro is called
multiple times, multiple copies of the code will be inserted. To avoid naming
conflict of hash tables with different key-value types, the library uses <a href="http://en.wikipedia.org/wiki/C_preprocessor#Token_concatenation">token
concatenation</a>, which is a preprocessor feature whereby we can substitute
part of a symbol based on the parameter of the macro. In the end, the C
preprocessor will generate the following code and feed it to the compiler
(macro <code>kh_exist(h,k)</code> is a little complex and not expanded for simplicity):</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>typedef struct {
</span>  int n_buckets, size, n_occupied, upper_bound;
<!-- -->  unsigned *flags;
<!-- -->  unsigned *keys;
<!-- -->  char *vals;
<!-- -->} kh_m32_t;
<!-- -->static inline kh_m32_t *init_m32() {
<!-- -->  return (kh_m32_t*)calloc(1, sizeof(kh_m32_t));
<!-- -->}
<!-- -->static inline int get_m32(kh_m32_t *h, unsigned k)
<!-- -->...
<!-- -->static inline void destroy_m32(kh_m32_t *h) {
<!-- -->  if (h) {
<!-- -->    free(h-&gt;keys); free(h-&gt;flags); free(h-&gt;vals); free(h);
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->int main() {
<!-- -->	int ret, is_missing;
<!-- -->	khint_t k;
<!-- -->	kh_m32_t *h = init_m32();
<!-- -->	k = put_m32(h, 5, &amp;ret);
<!-- -->	if (!ret) del_m32(h, k);
<!-- -->	h-&gt;vals[k] = 10;
<!-- -->	k = get_m32(h, 10);
<!-- -->	is_missing = (k == h-&gt;n_buckets);
<!-- -->	k = get_m32(h, 5);
<!-- -->	del_m32(h, k);
<!-- -->	for (k = 0; k != h-&gt;n_buckets; ++k)
<!-- -->		if (kh_exist(h, k)) h-&gt;vals[k] = 1;
<!-- -->	destroy_m32(h);
<!-- -->	return 0;
<!-- -->}
</code></pre><p>This is the C program we know.</p><p>From this example, we can see that macros and the C preprocessor plays a key
role in klib. Klib is fast partly because the compiler knows the key-value
type at the compile time and is able to optimize the code to the same level
as type-specific code. A generic library written with <code>void*</code> will not get such
performance boost.</p><p>Massively inserting code upon instantiation may remind us of C++&#x27;s slow
compiling speed and huge binary size when STL/boost is in use. Klib is much
better in this respect due to its small code size and component independency.
Inserting several hundreds lines of code won&#x27;t make compiling obviously slower.</p><h2>&lt;a name=&quot;resources&quot;&gt;<!-- -->&lt;/a&gt;<!-- -->Resources</h2><ul><li>Library documentation, if present, is available in the header files. Examples</li></ul><p>can be found in the <a href="https://github.com/attractivechaos/klib/tree/master/test">test/</a> directory.</p><ul><li><strong>Obsolete</strong> documentation of the hash table library can be found at</li></ul><p><a href="http://klib.sourceforge.net/">SourceForge</a>. This README is partly adapted from the old documentation.</p><ul><li><a href="http://attractivechaos.wordpress.com/2008/09/02/implementing-generic-hash-library-in-c/">Blog post</a> describing the hash table library.</li><li><a href="http://attractivechaos.wordpress.com/2008/10/02/using-void-in-generic-c-programming-may-be-inefficient/">Blog post</a> on why using <code>void*</code> for generic programming may be inefficient.</li><li><a href="http://attractivechaos.wordpress.com/2008/10/11/a-generic-buffered-stream-wrapper/">Blog post</a> on the generic stream buffer.</li><li><a href="http://attractivechaos.wordpress.com/2008/09/19/c-array-vs-c-vector/">Blog post</a> evaluating the performance of <code>kvec.h</code>.</li><li><a href="http://attractivechaos.wordpress.com/2008/09/24/b-tree-vs-binary-search-tree/">Blog post</a> arguing B-tree may be a better data structure than a binary search tree.</li><li><a href="http://attractivechaos.wordpress.com/2008/10/07/another-look-at-my-old-benchmark/">Blog post</a> evaluating the performance of <code>khash.h</code> and <code>kbtree.h</code> among many other implementations.</li></ul><p><a href="http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/">An older version</a> of the benchmark is also available.</p><ul><li><a href="http://attractivechaos.wordpress.com/2008/08/28/comparison-of-internal-sorting-algorithms/">Blog post</a> benchmarking internal sorting algorithms and implementations.</li><li><a href="http://attractivechaos.wordpress.com/2008/09/13/calculating-median/">Blog post</a> on the k-small algorithm.</li><li><a href="http://attractivechaos.wordpress.com/2008/08/24/derivative-free-optimization-dfo/">Blog post</a> on the Hooke-Jeeve&#x27;s algorithm for nonlinear programming.</li></ul></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/attractivechaos-klib","name":"attractivechaos/klib","licence":"","description":"A standalone and lightweight C library","readme":"# Klib: a Generic Library in C\n\n## \u003ca name=\"overview\"\u003e\u003c/a\u003eOverview\n\nKlib is a standalone and lightweight C library distributed under [MIT/X11\nlicense][1]. Most components are independent of external libraries, except the\nstandard C library, and independent of each other. To use a component of this\nlibrary, you only need to copy a couple of files to your source code tree\nwithout worrying about library dependencies.\n\nKlib strives for efficiency and a small memory footprint. Some components, such\nas khash.h, kbtree.h, ksort.h and kvec.h, are among the most efficient\nimplementations of similar algorithms or data structures in all programming\nlanguages, in terms of both speed and memory use.\n\nA new documentation is available [here](http://attractivechaos.github.io/klib/)\nwhich includes most information in this README file.\n\n#### Common components\n\n* [khash.h][khash]: generic [hash table][2] with open addressing.\n* [kbtree.h][kbtree]: generic search tree based on [B-tree][3].\n* [kavl.h][kavl]: generic intrusive [AVL tree][wiki-avl].\n* [ksort.h][ksort]: generic sort, including [introsort][4], [merge sort][5], [heap sort][6], [comb sort][7], [Knuth shuffle][8] and the [k-small][9] algorithm.\n* [kseq.h][kseq]: generic stream buffer and a [FASTA][10]/[FASTQ][11] format parser.\n* kvec.h: generic dynamic array.\n* klist.h: generic single-linked list and [memory pool][12].\n* kstring.{h,c}: basic string library.\n* kmath.{h,c}: numerical routines including [MT19937-64][13] [pseudorandom generator][14], basic [nonlinear programming][15] and a few special math functions.\n* [ketopt.h][ketopt]: portable command-line argument parser with getopt\\_long-like API.\n\n#### Components for more specific use cases\n\n* ksa.c: constructing [suffix arrays][16] for strings with multiple sentinels, based on a revised [SAIS algorithm][17].\n* knetfile.{h,c}: random access to remote files on HTTP or FTP.\n* kopen.c: smart stream opening.\n* khmm.{h,c}: basic [HMM][18] library.\n* ksw.(h,c}: Striped [Smith-Waterman algorithm][19].\n* knhx.{h,c}: [Newick tree format][20] parser.\n\n\n## \u003ca name=\"methodology\"\u003e\u003c/a\u003eMethodology\n\nFor the implementation of generic [containers][21], klib extensively uses C\nmacros. To use these data structures, we usually need to instantiate methods by\nexpanding a long macro. This makes the source code look unusual or even ugly\nand adds difficulty to debugging. Unfortunately, for efficient generic\nprogramming in C that lacks [template][22], using macros is the only\nsolution. Only with macros, we can write a generic container which, once\ninstantiated, compete with a type-specific container in efficiency. Some\ngeneric libraries in C, such as [Glib][23], use the `void*` type to implement\ncontainers. These implementations are usually slower and use more memory than\nklib (see [this benchmark][31]).\n\nTo effectively use klib, it is important to understand how it achieves generic\nprogramming. We will use the hash table library as an example:\n\n    #include \"khash.h\"\n    KHASH_MAP_INIT_INT(m32, char)        // instantiate structs and methods\n    int main() {\n        int ret, is_missing;\n        khint_t k;\n        khash_t(m32) *h = kh_init(m32);  // allocate a hash table\n        k = kh_put(m32, h, 5, \u0026ret);     // insert a key to the hash table\n        if (!ret) kh_del(m32, h, k);\n        kh_value(h, k) = 10;             // set the value\n        k = kh_get(m32, h, 10);          // query the hash table\n        is_missing = (k == kh_end(h));   // test if the key is present\n        k = kh_get(m32, h, 5);\n        kh_del(m32, h, k);               // remove a key-value pair\n        for (k = kh_begin(h); k != kh_end(h); ++k)  // traverse\n            if (kh_exist(h, k))          // test if a bucket contains data\n    \t\t\tkh_value(h, k) = 1;\n        kh_destroy(m32, h);              // deallocate the hash table\n        return 0;\n    }\n\nIn this example, the second line instantiates a hash table with `unsigned` as\nthe key type and `char` as the value type. `m32` names such a type of hash table.\nAll types and functions associated with this name are macros, which will be\nexplained later. Macro `kh_init()` initiates a hash table and `kh_destroy()`\nfrees it. `kh_put()` inserts a key and returns the iterator (or the position)\nin the hash table. `kh_get()` and `kh_del()` get a key and delete an element,\nrespectively. Macro `kh_exist()` tests if an iterator (or a position) is filled\nwith data.\n\nAn immediate question is this piece of code does not look like a valid C\nprogram (e.g. lacking semicolon, assignment to an _apparent_ function call and\n_apparent_ undefined `m32` 'variable'). To understand why the code is correct,\nlet's go a bit further into the source code of `khash.h`, whose skeleton looks\nlike:\n\n    #define KHASH_INIT(name, SCOPE, key_t, val_t, is_map, _hashf, _hasheq) \\\n      typedef struct { \\\n        int n_buckets, size, n_occupied, upper_bound; \\\n        unsigned *flags; \\\n        key_t *keys; \\\n        val_t *vals; \\\n      } kh_##name##_t; \\\n      SCOPE inline kh_##name##_t *init_##name() { \\\n        return (kh_##name##_t*)calloc(1, sizeof(kh_##name##_t)); \\\n      } \\\n      SCOPE inline int get_##name(kh_##name##_t *h, key_t k) \\\n      ... \\\n      SCOPE inline void destroy_##name(kh_##name##_t *h) { \\\n        if (h) { \\\n          free(h-\u003ekeys); free(h-\u003eflags); free(h-\u003evals); free(h); \\\n        } \\\n      }\n    \n    #define _int_hf(key) (unsigned)(key)\n    #define _int_heq(a, b) (a == b)\n    #define khash_t(name) kh_##name##_t\n    #define kh_value(h, k) ((h)-\u003evals[k])\n    #define kh_begin(h, k) 0\n    #define kh_end(h) ((h)-\u003en_buckets)\n    #define kh_init(name) init_##name()\n    #define kh_get(name, h, k) get_##name(h, k)\n    #define kh_destroy(name, h) destroy_##name(h)\n    ...\n    #define KHASH_MAP_INIT_INT(name, val_t) \\\n    \tKHASH_INIT(name, static, unsigned, val_t, is_map, _int_hf, _int_heq)\n\n`KHASH_INIT()` is a huge macro defining all the structs and methods. When this\nmacro is called, all the code inside it will be inserted by the [C\npreprocess][37] to the place where it is called. If the macro is called\nmultiple times, multiple copies of the code will be inserted. To avoid naming\nconflict of hash tables with different key-value types, the library uses [token\nconcatenation][36], which is a preprocessor feature whereby we can substitute\npart of a symbol based on the parameter of the macro. In the end, the C\npreprocessor will generate the following code and feed it to the compiler\n(macro `kh_exist(h,k)` is a little complex and not expanded for simplicity):\n\n    typedef struct {\n      int n_buckets, size, n_occupied, upper_bound;\n      unsigned *flags;\n      unsigned *keys;\n      char *vals;\n    } kh_m32_t;\n    static inline kh_m32_t *init_m32() {\n      return (kh_m32_t*)calloc(1, sizeof(kh_m32_t));\n    }\n    static inline int get_m32(kh_m32_t *h, unsigned k)\n    ...\n    static inline void destroy_m32(kh_m32_t *h) {\n      if (h) {\n        free(h-\u003ekeys); free(h-\u003eflags); free(h-\u003evals); free(h);\n      }\n    }\n\n\tint main() {\n\t\tint ret, is_missing;\n\t\tkhint_t k;\n\t\tkh_m32_t *h = init_m32();\n\t\tk = put_m32(h, 5, \u0026ret);\n\t\tif (!ret) del_m32(h, k);\n\t\th-\u003evals[k] = 10;\n\t\tk = get_m32(h, 10);\n\t\tis_missing = (k == h-\u003en_buckets);\n\t\tk = get_m32(h, 5);\n\t\tdel_m32(h, k);\n\t\tfor (k = 0; k != h-\u003en_buckets; ++k)\n\t\t\tif (kh_exist(h, k)) h-\u003evals[k] = 1;\n\t\tdestroy_m32(h);\n\t\treturn 0;\n\t}\n\nThis is the C program we know.\n\nFrom this example, we can see that macros and the C preprocessor plays a key\nrole in klib. Klib is fast partly because the compiler knows the key-value\ntype at the compile time and is able to optimize the code to the same level\nas type-specific code. A generic library written with `void*` will not get such\nperformance boost.\n\nMassively inserting code upon instantiation may remind us of C++'s slow\ncompiling speed and huge binary size when STL/boost is in use. Klib is much\nbetter in this respect due to its small code size and component independency.\nInserting several hundreds lines of code won't make compiling obviously slower.\n\n## \u003ca name=\"resources\"\u003e\u003c/a\u003eResources\n\n* Library documentation, if present, is available in the header files. Examples\ncan be found in the [test/][24] directory.\n* **Obsolete** documentation of the hash table library can be found at\n[SourceForge][25]. This README is partly adapted from the old documentation.\n* [Blog post][26] describing the hash table library.\n* [Blog post][27] on why using `void*` for generic programming may be inefficient.\n* [Blog post][28] on the generic stream buffer.\n* [Blog post][29] evaluating the performance of `kvec.h`.\n* [Blog post][30] arguing B-tree may be a better data structure than a binary search tree.\n* [Blog post][31] evaluating the performance of `khash.h` and `kbtree.h` among many other implementations.\n[An older version][33] of the benchmark is also available.\n* [Blog post][34] benchmarking internal sorting algorithms and implementations.\n* [Blog post][32] on the k-small algorithm.\n* [Blog post][35] on the Hooke-Jeeve's algorithm for nonlinear programming.\n\n[1]: http://en.wikipedia.org/wiki/MIT_License\n[2]: https://en.wikipedia.org/wiki/Hash_table\n[3]: http://en.wikipedia.org/wiki/B-tree\n[4]: http://en.wikipedia.org/wiki/Introsort\n[5]: http://en.wikipedia.org/wiki/Merge_sort\n[6]: http://en.wikipedia.org/wiki/Heapsort\n[7]: http://en.wikipedia.org/wiki/Comb_sort\n[8]: http://en.wikipedia.org/wiki/Fisher-Yates_shuffle\n[9]: http://en.wikipedia.org/wiki/Selection_algorithm\n[10]: http://en.wikipedia.org/wiki/FASTA_format\n[11]: http://en.wikipedia.org/wiki/FASTQ_format\n[12]: http://en.wikipedia.org/wiki/Memory_pool\n[13]: http://en.wikipedia.org/wiki/Mersenne_twister\n[14]: http://en.wikipedia.org/wiki/Pseudorandom_generator\n[15]: http://en.wikipedia.org/wiki/Nonlinear_programming\n[16]: http://en.wikipedia.org/wiki/Suffix_array\n[17]: https://sites.google.com/site/yuta256/sais\n[18]: http://en.wikipedia.org/wiki/Hidden_Markov_model\n[19]: http://en.wikipedia.org/wiki/Smith-Waterman_algorithm\n[20]: http://en.wikipedia.org/wiki/Newick_format\n[21]: http://en.wikipedia.org/wiki/Container_(abstract_data_type)\n[22]: http://en.wikipedia.org/wiki/Template_(C%2B%2B)\n[23]: http://en.wikipedia.org/wiki/GLib\n[24]: https://github.com/attractivechaos/klib/tree/master/test\n[25]: http://klib.sourceforge.net/\n[26]: http://attractivechaos.wordpress.com/2008/09/02/implementing-generic-hash-library-in-c/\n[27]: http://attractivechaos.wordpress.com/2008/10/02/using-void-in-generic-c-programming-may-be-inefficient/\n[28]: http://attractivechaos.wordpress.com/2008/10/11/a-generic-buffered-stream-wrapper/\n[29]: http://attractivechaos.wordpress.com/2008/09/19/c-array-vs-c-vector/\n[30]: http://attractivechaos.wordpress.com/2008/09/24/b-tree-vs-binary-search-tree/\n[31]: http://attractivechaos.wordpress.com/2008/10/07/another-look-at-my-old-benchmark/\n[32]: http://attractivechaos.wordpress.com/2008/09/13/calculating-median/\n[33]: http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/\n[34]: http://attractivechaos.wordpress.com/2008/08/28/comparison-of-internal-sorting-algorithms/\n[35]: http://attractivechaos.wordpress.com/2008/08/24/derivative-free-optimization-dfo/\n[36]: http://en.wikipedia.org/wiki/C_preprocessor#Token_concatenation\n[37]: http://en.wikipedia.org/wiki/C_preprocessor\n\n[wiki-avl]: https://en.wikipedia.org/wiki/AVL_tree\n\n[kbtree]: http://attractivechaos.github.io/klib/#KBtree%3A%20generic%20ordered%20map:%5B%5BKBtree%3A%20generic%20ordered%20map%5D%5D\n[khash]: http://attractivechaos.github.io/klib/#Khash%3A%20generic%20hash%20table:%5B%5BKhash%3A%20generic%20hash%20table%5D%5D\n[kseq]: http://attractivechaos.github.io/klib/#Kseq%3A%20stream%20buffer%20and%20FASTA%2FQ%20parser:%5B%5BKseq%3A%20stream%20buffer%20and%20FASTA%2FQ%20parser%5D%5D\n[ksort]: http://attractivechaos.github.io/klib/#Ksort%3A%20sorting%2C%20shuffling%2C%20heap%20and%20k-small:%5B%5BKsort%3A%20sorting%2C%20shuffling%2C%20heap%20and%20k-small%5D%5D\n[kavl]: http://attractivechaos.github.io/klib/#KAVL%3A%20generic%20intrusive%20AVL%20tree\n[ketopt]: http://attractivechaos.github.io/klib/#Ketopt%3A%20parsing%20command-line%20arguments\n","versions":[{"ref":"master","manifest":"targets = [ \"//:klib\" ]\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/host-pthread\"\nversion = \"branch=master\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/madler-zlib\"\nversion = \"branch=master\"\n","lockFile":"manifest = \"acb7ecceb75915f8d749888ab92443f7c1f9756bc4716f6fe2a4c196fc453db6\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/host-pthread\"\ntarget = \"//:pthread\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/madler-zlib\"\ntarget = \"//:zlib\"\n\n[lock.\"github.com/buckaroo-pm/host-pthread\"]\nversions = [ \"branch=master\" ]\nrevision = \"a62519aa69c8e3243d6065fbf4c1d2de072f86f6\"\n\n[lock.\"github.com/buckaroo-pm/madler-zlib\"]\nversions = [ \"branch=master\" ]\nrevision = \"906f727175ca6a7f8943e375467d6e461a55b68d\"\n","buck":"load('//:tests.bzl', 'createTests')\nload('//:subdir_glob.bzl', 'subdir_glob')\nload('//:buckaroo_macros.bzl', 'buckaroo_deps_from_package')\n\ncxx_library(\n  name = 'klib',\n  header_namespace = '',\n  srcs = glob(['*.c']),\n  exported_headers = subdir_glob([\n    ('','*.h')\n  ]),\n  visibility = [\n    'PUBLIC',\n  ],\n  deps = buckaroo_deps_from_package('github.com/buckaroo-pm/host-pthread')\n)\n\ntest_suite(\n  name = 'test',\n  tests = createTests(glob(['test/*_test.c']))\n)\n","bazel":"","deps":[{"uri":"github.com/buckaroo-pm/host-pthread","name":"buckaroo-pm/host-pthread","version":"branch=master"},{"uri":"github.com/buckaroo-pm/madler-zlib","name":"buckaroo-pm/madler-zlib","version":"branch=master"}],"lock":[{"uri":"github.com/buckaroo-pm/host-pthread","name":"buckaroo-pm/host-pthread","spec":{"versions":["branch=master"],"revision":"a62519aa69c8e3243d6065fbf4c1d2de072f86f6"}},{"uri":"github.com/buckaroo-pm/madler-zlib","name":"buckaroo-pm/madler-zlib","spec":{"versions":["branch=master"],"revision":"906f727175ca6a7f8943e375467d6e461a55b68d"}}]}],"updated":"2019-01-23T14:36:59Z","updatedUpstream":"2021-01-13T22:22:34Z","contributors":[{"login":"johnm","avatarUrl":"https://avatars3.githubusercontent.com/u/8661?v=4"},{"login":"ihh","avatarUrl":"https://avatars2.githubusercontent.com/u/54113?v=4"},{"login":"jmarshall","avatarUrl":"https://avatars3.githubusercontent.com/u/70921?v=4"},{"login":"arrbee","avatarUrl":"https://avatars0.githubusercontent.com/u/103350?u=809e4e0a2c1279baa09850a56c64aefa49c4a3c6\u0026v=4"},{"login":"zhanxw","avatarUrl":"https://avatars3.githubusercontent.com/u/157832?u=466c8c153019afae98d45da41c05049a8c36002b\u0026v=4"},{"login":"lh3","avatarUrl":"https://avatars2.githubusercontent.com/u/480346?v=4"},{"login":"attractivechaos","avatarUrl":"https://avatars2.githubusercontent.com/u/563093?v=4"},{"login":"immerrr","avatarUrl":"https://avatars2.githubusercontent.com/u/579798?v=4"},{"login":"droe","avatarUrl":"https://avatars2.githubusercontent.com/u/749226?u=eb1e62f532b5403f0874f716d1cd2b4d550c64d2\u0026v=4"},{"login":"leecbaker","avatarUrl":"https://avatars0.githubusercontent.com/u/1047159?v=4"},{"login":"zjf","avatarUrl":"https://avatars3.githubusercontent.com/u/1586818?v=4"},{"login":"pmelsted","avatarUrl":"https://avatars2.githubusercontent.com/u/1830628?v=4"},{"login":"jkbonfield","avatarUrl":"https://avatars1.githubusercontent.com/u/2210525?u=3aa71d7dfa4b08d0aae4e1cae19605a3cb3c4967\u0026v=4"},{"login":"jiangzhuti","avatarUrl":"https://avatars2.githubusercontent.com/u/3127813?u=5177634c49fa32fdcb479bd76ea824be3e04ad6a\u0026v=4"},{"login":"daviesrob","avatarUrl":"https://avatars2.githubusercontent.com/u/3234562?v=4"},{"login":"piki","avatarUrl":"https://avatars3.githubusercontent.com/u/3660033?u=aecc5ad678bd8a5ce36cfc11b785c389ffa1e653\u0026v=4"},{"login":"sciascid","avatarUrl":"https://avatars1.githubusercontent.com/u/3881727?u=f5182ebc0b667613754311ac2c564a4e1b784b45\u0026v=4"},{"login":"dnbaker","avatarUrl":"https://avatars2.githubusercontent.com/u/6412885?u=fcde1fe3079c4237b822fc7673c944736dacee8e\u0026v=4"},{"login":"valeriuo","avatarUrl":"https://avatars1.githubusercontent.com/u/6553979?u=96404657a1e5dbcf5090852f86bce62991a7b8b7\u0026v=4"}],"fundingLinks":[],"contactLinks":[],"stars":3170,"forks":442,"topics":["c","generic","library","hashtable","b-tree","avl-tree","sort","algorithm"]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"attractivechaos-klib"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>