<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/cameron314-readerwriterqueue/logo.png"/></div><div><h1>buckaroo-pm/cameron314-readerwriterqueue</h1><div style="max-width:600px">A fast single-producer, single-consumer lock-free queue for C++</div><br/><div><b>1975</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><h1>A single-producer, single-consumer lock-free queue for C++</h1><p>This mini-repository has my very own implementation of a lock-free queue (that I designed from scratch) for C++.</p><p>It only supports a two-thread use case (one consuming, and one producing). The threads can&#x27;t switch roles, though
you could use this queue completely from a single thread if you wish (but that would sort of defeat the purpose!).</p><p>Note: If you need a general-purpose multi-producer, multi-consumer lock free queue, I have <a href="https://github.com/cameron314/concurrentqueue">one of those too</a>.</p><h2>Features</h2><ul><li><a href="http://moodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++#benchmarks">Blazing fast</a></li><li>Compatible with C++11 (supports moving objects instead of making copies)</li><li>Fully generic (templated container of any type) -- just like <code>std::queue</code>, you never need to allocate memory for elements yourself
(which saves you the hassle of writing a lock-free memory manager to hold the elements you&#x27;re queueing)</li><li>Allocates memory up front, in contiguous blocks</li><li>Provides a <code>try_enqueue</code> method which is guaranteed never to allocate memory (the queue starts with an initial capacity)</li><li>Also provides an <code>enqueue</code> method which can dynamically grow the size of the queue as needed</li><li>Also provides <code>try_emplace</code>/<code>emplace</code> convenience methods</li><li>Has a blocking version with <code>wait_dequeue</code></li><li>Completely &quot;wait-free&quot; (no compare-and-swap loop). Enqueue and dequeue are always O(1) (not counting memory allocation)</li><li>On x86, the memory barriers compile down to no-ops, meaning enqueue and dequeue are just a simple series of loads and stores (and branches)</li></ul><h2>Use</h2><p>Simply drop the readerwriterqueue.h and atomicops.h files into your source code and include them :-)
A modern compiler is required (MSVC2010+, GCC 4.7+, ICC 13+, or any C++11 compliant compiler should work).</p><p>Note: If you&#x27;re using GCC, you really do need GCC 4.7 or above -- <a href="http://stackoverflow.com/questions/16429669/stdatomic-thread-fence-has-undefined-reference">4.6 has a bug</a> that prevents the atomic fence primitives
from working correctly.</p><p>Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">using</span><span> </span><span class="token" style="color:#07a">namespace</span><span> moodycamel</span><span class="token" style="color:#999">;</span><span>
</span>
<span>ReaderWriterQueue</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> </span><span class="token" style="color:#DD4A68">q</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">100</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>       </span><span class="token" style="color:slategray">// Reserve space for at least 100 elements up front</span><span>
</span>
<span>q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">enqueue</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">17</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>                       </span><span class="token" style="color:slategray">// Will allocate memory if the queue is full</span><span>
</span><span></span><span class="token" style="color:#07a">bool</span><span> succeeded </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">try_enqueue</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">18</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>  </span><span class="token" style="color:slategray">// Will only succeed if the queue has an empty slot (never allocates)</span><span>
</span><span></span><span class="token" style="color:#DD4A68">assert</span><span class="token" style="color:#999">(</span><span>succeeded</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:#07a">int</span><span> number</span><span class="token" style="color:#999">;</span><span>
</span><span>succeeded </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">try_dequeue</span><span class="token" style="color:#999">(</span><span>number</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>  </span><span class="token" style="color:slategray">// Returns false if the queue was empty</span><span>
</span>
<span></span><span class="token" style="color:#DD4A68">assert</span><span class="token" style="color:#999">(</span><span>succeeded </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;&amp;</span><span> number </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> </span><span class="token" style="color:#905">17</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:slategray">// You can also peek at the front item of the queue (consumer only)</span><span>
</span><span></span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span> front </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">peek</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#DD4A68">assert</span><span class="token" style="color:#999">(</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>front </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> </span><span class="token" style="color:#905">18</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>succeeded </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">try_dequeue</span><span class="token" style="color:#999">(</span><span>number</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#DD4A68">assert</span><span class="token" style="color:#999">(</span><span>succeeded </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;&amp;</span><span> number </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> </span><span class="token" style="color:#905">18</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>front </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">peek</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> 
</span><span></span><span class="token" style="color:#DD4A68">assert</span><span class="token" style="color:#999">(</span><span>front </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> </span><span class="token" style="color:#07a">nullptr</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>           </span><span class="token" style="color:slategray">// Returns nullptr if the queue was empty</span></code></pre><p>The blocking version has the exact same API, with the addition of <code>wait_dequeue</code> and
<code>wait_dequeue_timed</code> methods:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>BlockingReaderWriterQueue</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> q</span><span class="token" style="color:#999">;</span><span>
</span>
<span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>thread </span><span class="token" style="color:#DD4A68">reader</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">[</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>    </span><span class="token" style="color:#07a">int</span><span> item</span><span class="token" style="color:#999">;</span><span>
</span><span>    </span><span class="token" style="color:#07a">for</span><span> </span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">int</span><span> i </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#905">0</span><span class="token" style="color:#999">;</span><span> i </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">!=</span><span> </span><span class="token" style="color:#905">100</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">++</span><span>i</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>        </span><span class="token" style="color:slategray">// Fully-blocking:</span><span>
</span><span>        q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">wait_dequeue</span><span class="token" style="color:#999">(</span><span>item</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span>        </span><span class="token" style="color:slategray">// Blocking with timeout</span><span>
</span><span>        </span><span class="token" style="color:#07a">if</span><span> </span><span class="token" style="color:#999">(</span><span>q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">wait_dequeue_timed</span><span class="token" style="color:#999">(</span><span>item</span><span class="token" style="color:#999">,</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>chrono</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">milliseconds</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">5</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span>
</span><span>            </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">++</span><span>i</span><span class="token" style="color:#999">;</span><span>
</span><span>    </span><span class="token" style="color:#999">}</span><span>
</span><span></span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>thread </span><span class="token" style="color:#DD4A68">writer</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">[</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>    </span><span class="token" style="color:#07a">for</span><span> </span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">int</span><span> i </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#905">0</span><span class="token" style="color:#999">;</span><span> i </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">!=</span><span> </span><span class="token" style="color:#905">100</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">++</span><span>i</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>        q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">enqueue</span><span class="token" style="color:#999">(</span><span>i</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>        std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>this_thread</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">sleep_for</span><span class="token" style="color:#999">(</span><span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>chrono</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">milliseconds</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">10</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>    </span><span class="token" style="color:#999">}</span><span>
</span><span></span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>writer</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">join</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>reader</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">join</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:#DD4A68">assert</span><span class="token" style="color:#999">(</span><span>q</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">size_approx</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> </span><span class="token" style="color:#905">0</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>Note that <code>wait_dequeue</code> will block indefinitely while the queue is empty; this
means care must be taken to only call <code>wait_dequeue</code> if you&#x27;re sure another element
will come along eventually, or if the queue has a static lifetime. This is because
destroying the queue while a thread is waiting on it will invoke undefined behaviour.</p><h2>Disclaimers</h2><p>The queue should only be used on platforms where aligned integer and pointer access is atomic; fortunately, that
includes all modern processors (e.g. x86/x86-64, ARM, and PowerPC). <em>Not</em> for use with a DEC Alpha processor (which has very weak memory ordering) :-)</p><p>Note that it&#x27;s only been tested on x86(-64); if someone has access to other processors I&#x27;d love to run some tests on
anything that&#x27;s not x86-based.</p><p>Finally, I am not an expert. This is my first foray into lock-free programming, and though I&#x27;m confident in the code,
it&#x27;s possible that there are bugs despite the effort I put into designing and testing this data structure.</p><p>Use this code at your own risk; in particular, lock-free programming is a patent minefield, and this code may very
well violate a pending patent (I haven&#x27;t looked). It&#x27;s worth noting that I came up with this algorithm and
implementation from scratch, independent of any existing lock-free queues.</p><h2>More info</h2><p>See the <a href="LICENSE.md">LICENSE.md</a> file for the license (simplified BSD).</p><p>My <a href="http://moodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++">blog post</a> introduces the context that led to this code, and may be of interest if you&#x27;re curious
about lock-free programming.</p></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/cameron314-readerwriterqueue","name":"cameron314/readerwriterqueue","licence":"NOASSERTION","description":"A fast single-producer, single-consumer lock-free queue for C++","readme":"# A single-producer, single-consumer lock-free queue for C++\n\nThis mini-repository has my very own implementation of a lock-free queue (that I designed from scratch) for C++.\n\nIt only supports a two-thread use case (one consuming, and one producing). The threads can't switch roles, though\nyou could use this queue completely from a single thread if you wish (but that would sort of defeat the purpose!).\n\nNote: If you need a general-purpose multi-producer, multi-consumer lock free queue, I have [one of those too][mpmc].\n\n\n## Features\n\n- [Blazing fast][benchmarks]\n- Compatible with C++11 (supports moving objects instead of making copies)\n- Fully generic (templated container of any type) -- just like `std::queue`, you never need to allocate memory for elements yourself\n  (which saves you the hassle of writing a lock-free memory manager to hold the elements you're queueing)\n- Allocates memory up front, in contiguous blocks\n- Provides a `try_enqueue` method which is guaranteed never to allocate memory (the queue starts with an initial capacity)\n- Also provides an `enqueue` method which can dynamically grow the size of the queue as needed\n- Also provides `try_emplace`/`emplace` convenience methods\n- Has a blocking version with `wait_dequeue`\n- Completely \"wait-free\" (no compare-and-swap loop). Enqueue and dequeue are always O(1) (not counting memory allocation)\n- On x86, the memory barriers compile down to no-ops, meaning enqueue and dequeue are just a simple series of loads and stores (and branches)\n\n\n## Use\n\nSimply drop the readerwriterqueue.h and atomicops.h files into your source code and include them :-)\nA modern compiler is required (MSVC2010+, GCC 4.7+, ICC 13+, or any C++11 compliant compiler should work).\n\nNote: If you're using GCC, you really do need GCC 4.7 or above -- [4.6 has a bug][gcc46bug] that prevents the atomic fence primitives\nfrom working correctly.\n\nExample:\n\n```cpp\nusing namespace moodycamel;\n\nReaderWriterQueue\u003cint\u003e q(100);       // Reserve space for at least 100 elements up front\n\nq.enqueue(17);                       // Will allocate memory if the queue is full\nbool succeeded = q.try_enqueue(18);  // Will only succeed if the queue has an empty slot (never allocates)\nassert(succeeded);\n\nint number;\nsucceeded = q.try_dequeue(number);  // Returns false if the queue was empty\n\nassert(succeeded \u0026\u0026 number == 17);\n\n// You can also peek at the front item of the queue (consumer only)\nint* front = q.peek();\nassert(*front == 18);\nsucceeded = q.try_dequeue(number);\nassert(succeeded \u0026\u0026 number == 18);\nfront = q.peek(); \nassert(front == nullptr);           // Returns nullptr if the queue was empty\n```\n\nThe blocking version has the exact same API, with the addition of `wait_dequeue` and\n`wait_dequeue_timed` methods:\n\n```cpp\nBlockingReaderWriterQueue\u003cint\u003e q;\n\nstd::thread reader([\u0026]() {\n    int item;\n    for (int i = 0; i != 100; ++i) {\n        // Fully-blocking:\n        q.wait_dequeue(item);\n\n        // Blocking with timeout\n        if (q.wait_dequeue_timed(item, std::chrono::milliseconds(5)))\n            ++i;\n    }\n});\nstd::thread writer([\u0026]() {\n    for (int i = 0; i != 100; ++i) {\n        q.enqueue(i);\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n});\nwriter.join();\nreader.join();\n\nassert(q.size_approx() == 0);\n```\n    \nNote that `wait_dequeue` will block indefinitely while the queue is empty; this\nmeans care must be taken to only call `wait_dequeue` if you're sure another element\nwill come along eventually, or if the queue has a static lifetime. This is because\ndestroying the queue while a thread is waiting on it will invoke undefined behaviour.\n\n    \n## Disclaimers\n\nThe queue should only be used on platforms where aligned integer and pointer access is atomic; fortunately, that\nincludes all modern processors (e.g. x86/x86-64, ARM, and PowerPC). *Not* for use with a DEC Alpha processor (which has very weak memory ordering) :-)\n\nNote that it's only been tested on x86(-64); if someone has access to other processors I'd love to run some tests on\nanything that's not x86-based.\n\nFinally, I am not an expert. This is my first foray into lock-free programming, and though I'm confident in the code,\nit's possible that there are bugs despite the effort I put into designing and testing this data structure.\n\nUse this code at your own risk; in particular, lock-free programming is a patent minefield, and this code may very\nwell violate a pending patent (I haven't looked). It's worth noting that I came up with this algorithm and\nimplementation from scratch, independent of any existing lock-free queues.\n\n\n## More info\n\nSee the [LICENSE.md][license] file for the license (simplified BSD).\n\nMy [blog post][blog] introduces the context that led to this code, and may be of interest if you're curious\nabout lock-free programming.\n\n\n[blog]: http://moodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++\n[license]: LICENSE.md\n[benchmarks]: http://moodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++#benchmarks\n[gcc46bug]: http://stackoverflow.com/questions/16429669/stdatomic-thread-fence-has-undefined-reference\n[mpmc]: https://github.com/cameron314/concurrentqueue\n","versions":[{"ref":"master","manifest":"targets = [ \"//:readerwriterqueue\" ]\n","lockFile":"manifest = \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\n","buck":"prebuilt_cxx_library(\n  name = 'readerwriterqueue',\n  header_namespace = '',\n  header_only = True,\n  exported_headers = [\n    'atomicops.h',\n    'readerwriterqueue.h',\n  ],\n  visibility = [\n    'PUBLIC',\n  ],\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-09-07T18:27:01Z","updatedUpstream":"2021-01-13T16:47:10Z","contributors":[{"login":"neomantra","avatarUrl":"https://avatars1.githubusercontent.com/u/26842?u=dc4ee0aafab55e8a177088924f7d1f993927cacf\u0026v=4"},{"login":"cameron314","avatarUrl":"https://avatars2.githubusercontent.com/u/116235?v=4"},{"login":"kletoz","avatarUrl":"https://avatars3.githubusercontent.com/u/142893?v=4"},{"login":"smoe","avatarUrl":"https://avatars1.githubusercontent.com/u/207407?u=a14a86806db3c3c4719cda16ba9ed1709caeb718\u0026v=4"},{"login":"nikreiman","avatarUrl":"https://avatars1.githubusercontent.com/u/312573?v=4"},{"login":"joeyo","avatarUrl":"https://avatars2.githubusercontent.com/u/372147?v=4"},{"login":"trilorez","avatarUrl":"https://avatars1.githubusercontent.com/u/3771859?u=f6cf574129c5c5683bca155dcaa3182d85c9531d\u0026v=4"},{"login":"Cleroth","avatarUrl":"https://avatars2.githubusercontent.com/u/4611301?v=4"},{"login":"tbeu","avatarUrl":"https://avatars0.githubusercontent.com/u/5444067?v=4"},{"login":"benaryorg","avatarUrl":"https://avatars3.githubusercontent.com/u/6145260?u=72965188a7fc0ac8b48b7f40553330113bcedc5a\u0026v=4"},{"login":"jonathonracz","avatarUrl":"https://avatars2.githubusercontent.com/u/6502300?u=c85cd17bad45bc21e85698184d661102f1bf860a\u0026v=4"},{"login":"hanickadot","avatarUrl":"https://avatars2.githubusercontent.com/u/6557263?u=d85f643ba14b75c8bb46820db101ff44b48f999e\u0026v=4"},{"login":"halx99","avatarUrl":"https://avatars2.githubusercontent.com/u/6977319?u=0f3ff44da167cc4e3bbbf61ce62920e198e1e5df\u0026v=4"},{"login":"zosrothko","avatarUrl":"https://avatars1.githubusercontent.com/u/7262593?v=4"},{"login":"AGSaidi","avatarUrl":"https://avatars2.githubusercontent.com/u/10063075?v=4"},{"login":"CrushedPixel","avatarUrl":"https://avatars1.githubusercontent.com/u/10288753?u=4c6f4085fdeae929f07766fbb909d3b47044507a\u0026v=4"},{"login":"sommern","avatarUrl":"https://avatars3.githubusercontent.com/u/10468072?u=d5dc2b554fe4e5ec8b858a04783805847769df60\u0026v=4"},{"login":"nkari82","avatarUrl":"https://avatars1.githubusercontent.com/u/15668659?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":1975,"forks":439,"topics":[]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"cameron314-readerwriterqueue"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>