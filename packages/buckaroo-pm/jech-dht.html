<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/jech-dht/logo.png"/></div><div><h1>buckaroo-pm/jech-dht</h1><div style="max-width:600px">BitTorrent DHT library</div><br/><div><b>584</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><p>The files dht.c and dht.h implement the variant of the Kademlia Distributed
Hash Table (DHT) used in the Bittorrent network (``mainline&#x27;&#x27; variant).</p><p>The file dht-example.c is a stand-alone program that participates in the
DHT.  Another example is a patch against Transmission, which you might or
might not be able to find somewhere.</p><p>The code is designed to work well in both event-driven and threaded code.
The caller, which is either an event-loop or a dedicated thread, must
periodically call the function dht_periodic.  In addition, it must call
dht_periodic whenever any data has arrived from the network.</p><p>All functions return -1 in case of failure, in which case errno is set, or
a positive value in case of success.</p><p>Initialisation</p><hr/><ul><li>dht_init</li></ul><p>This must be called before using the library.  You pass it an integer
identifying a bound IPv4 datagram socket in non-blocking mode, an integer
identifying a bound IPv6 datagram socket in non-blocking mode, and your
node id, a 20-octet array that should be globally unique.</p><p>The integers that identify the two sockets should usually be file
descriptors; however, as the library does not directly perform any socket-
or file-related operations on them, they can be arbitrary integers, for
example indices in a table of structures that represent sockets in your
code.</p><p>If you&#x27;re on a multi-homed host, you should bind your sockets to one of
your addresses.  This is especially relevant for IPv6.</p><p>Node ids must be well distributed, so you cannot just use your Bittorrent
id; you should either generate a truly random value (using plenty of
entropy), or at least take the SHA-1 of something.  However, it is a good
idea to keep the id stable, so you may want to store it in stable storage
at client shutdown.</p><ul><li>dht_uninit</li></ul><p>This may be called at the end of the session.</p><p>Bootstrapping</p><hr/><p>The DHT needs to be taught a small number of contacts to begin functioning.
You can hard-wire a small number of stable nodes in your application, but
this obviously fails to scale.  You may save the list of known good nodes
at shutdown, and restore it at restart.  You may also grab nodes from
torrent files (the nodes field), and you may exchange contacts with other
Bittorrent peers using the PORT extension.</p><ul><li>dht_ping_node</li></ul><p>This is the main bootstrapping primitive.  You pass it an address at which
you believe that a DHT node may be living, and a query will be sent.  If
a node replies, and if there is space in the routing table, it will be
inserted.</p><ul><li>dht_insert_node</li></ul><p>This is a softer bootstrapping method, which doesn&#x27;t actually send
a query -- it only stores the node in the routing table for later use.</p><p>Note that dht_insert_node requires that you supply a node id.  If the id
turns out to be wrong, the DHT will eventually recover; still, inserting
massive amounts of incorrect information into your routing table is not
a good idea.</p><p>An additionaly difficulty with dht_insert_node is that a Kademlia routing
table cannot absorb nodes faster than a certain rate.  A freshly initialised
routing table is able to absorb 128 nodes of each address family without
dropping any.  The tolerable rate after that is difficult to estimate: it is
probably on the order of one node every few seconds per node already in
the table divided by 8, for some suitable value of 8.</p><p>Doing some work</p><hr/><ul><li>dht_periodic</li></ul><p>This function should be called by your main loop periodically, and also
whenever data is available on the socket.  The time after which
dht_periodic should be called if no data is available is returned in the
parameter tosleep.  (You do not need to be particularly accurate; actually,
it is a good idea to be late by a random value.)</p><p>The parameters buf, buflen, from and fromlen optionally carry a received
message.  If buflen is 0, then no message was received.</p><p>Dht_periodic also takes a callback, which will be called whenever something
interesting happens (see below).</p><ul><li>dht_search</li></ul><p>This schedules a search for information about the info-hash specified in
id; it returns 1 if this is a new search, and 0 if it merely reset the
timeouts for a search in progress.  If port is not 0, it specifies the TCP
port on which the current peer is listening; in that case, when the search
is complete it will be announced to the network.  The port is in host
order, beware if you got it from a struct sockaddr_in.</p><p>In either case, data is passed to the callback function as soon as it is
available, possibly in multiple pieces.  The callback function will also
be called when the search is complete.</p><p>Up to DHT_MAX_SEARCHES (1024) searches can be in progress at a given time;
any more, and dht_search will return -1.  If you specify a new search for
the same info hash as a search still in progress, the previous search is
combined with the new one -- you will only receive a completion indication
once.</p><p>Information queries</p><hr/><ul><li>dht_nodes</li></ul><p>This returns the number of known good, dubious and cached nodes in our
routing table.  This can be used to decide whether it&#x27;s reasonable to start
a search; a search is likely to be successful as long as we have a few good
nodes; however, in order to avoid overloading your bootstrap nodes, you may
want to wait until good is at least 4 and good + doubtful is at least 30 or
so.</p><p>It also includes the number of nodes that recently sent us an unsolicited
request; this can be used to determine if the UDP port used for the DHT is
firewalled.</p><p>If you want to display a single figure to the user, you should display
good + doubtful, which is the total number of nodes in your routing table.
Some clients try to estimate the total number of nodes, but this doesn&#x27;t
make much sense -- since the result is exponential in the number of nodes
in the routing table, small variations in the latter cause huge jumps in
the former.</p><ul><li>dht_get_nodes</li></ul><p>This retrieves the list of known good nodes, starting with the nodes in our
own bucket.  It is a good idea to save the list of known good nodes at
shutdown, and ping them at startup.</p><ul><li>dht_dump_tables</li><li>dht_debug</li></ul><p>These are debugging aids.</p><p>Functions provided by you</p><hr/><ul><li>The callback function</li></ul><p>The callback function is called with 5 arguments.  Closure is simply the
value that you passed to dht_periodic.  Event is one of DHT_EVENT_VALUES or
DHT_EVENT_VALUES6, which indicates that we have new values, or
DHT_EVENT_SEARCH_DONE or DHT_EVENT_SEARCH_DONE6, which indicates that
a search has completed.  In either case, info_hash is set to the info-hash
of the search.</p><p>In the case of DHT_EVENT_VALUES, data is a list of nodes in ``compact&#x27;&#x27;
format -- 6 or 18 bytes per node.  Its length in bytes is in data_len.</p><ul><li>dht_sendto</li></ul><p>This will be called whenever the library needs to send a datagram.  If the
integers passed to dht_init are file descriptors, this can simply be an
alias for the sendto system call.</p><ul><li>dht_blacklisted</li></ul><p>This is a function that takes an IP address and returns true if this
address should be silently ignored.  Do not use this feature unless you
really must -- Kademlia supposes transitive reachability.</p><ul><li>dht_hash</li></ul><p>This should compute a reasonably strong cryptographic hash of the passed
values.  SHA-1 should be good enough.</p><ul><li>dht_random_bytes</li></ul><p>This should fill the supplied buffer with cryptographically strong random
bytes.  It&#x27;s called every 30 minutes on average, so it doesn&#x27;t need to be
fast.</p><p>Final notes</p><hr/><ul><li>NAT</li></ul><p>Nothing works well across NATs, but Kademlia is somewhat less impacted than
many other protocols.  The implementation takes care to distinguish between
unidirectional and bidirectional reachability, and NATed nodes will
eventually fall out from other nodes&#x27; routing tables.</p><p>While there is no periodic pinging in this implementation, maintaining
a full routing table requires slightly more than one packet exchange per
minute, even in a completely idle network; this should be sufficient to
make most full cone NATs happy.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>                                    Juliusz Chroboczek
</span>                                    &lt;jch@pps.jussieu.fr&gt;
</code></pre></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/jech-dht","name":"jech/dht","licence":"MIT","description":"BitTorrent DHT library","readme":"The files dht.c and dht.h implement the variant of the Kademlia Distributed\nHash Table (DHT) used in the Bittorrent network (``mainline'' variant).\n\nThe file dht-example.c is a stand-alone program that participates in the\nDHT.  Another example is a patch against Transmission, which you might or\nmight not be able to find somewhere.\n\nThe code is designed to work well in both event-driven and threaded code.\nThe caller, which is either an event-loop or a dedicated thread, must\nperiodically call the function dht_periodic.  In addition, it must call\ndht_periodic whenever any data has arrived from the network.\n\nAll functions return -1 in case of failure, in which case errno is set, or\na positive value in case of success.\n\nInitialisation\n**************\n\n* dht_init\n\nThis must be called before using the library.  You pass it an integer\nidentifying a bound IPv4 datagram socket in non-blocking mode, an integer\nidentifying a bound IPv6 datagram socket in non-blocking mode, and your\nnode id, a 20-octet array that should be globally unique.\n\nThe integers that identify the two sockets should usually be file\ndescriptors; however, as the library does not directly perform any socket-\nor file-related operations on them, they can be arbitrary integers, for\nexample indices in a table of structures that represent sockets in your\ncode.\n\nIf you're on a multi-homed host, you should bind your sockets to one of\nyour addresses.  This is especially relevant for IPv6.\n\nNode ids must be well distributed, so you cannot just use your Bittorrent\nid; you should either generate a truly random value (using plenty of\nentropy), or at least take the SHA-1 of something.  However, it is a good\nidea to keep the id stable, so you may want to store it in stable storage\nat client shutdown.\n\n \n* dht_uninit\n\nThis may be called at the end of the session.\n\nBootstrapping\n*************\n\nThe DHT needs to be taught a small number of contacts to begin functioning.\nYou can hard-wire a small number of stable nodes in your application, but\nthis obviously fails to scale.  You may save the list of known good nodes\nat shutdown, and restore it at restart.  You may also grab nodes from\ntorrent files (the nodes field), and you may exchange contacts with other\nBittorrent peers using the PORT extension.\n\n* dht_ping_node\n\nThis is the main bootstrapping primitive.  You pass it an address at which\nyou believe that a DHT node may be living, and a query will be sent.  If\na node replies, and if there is space in the routing table, it will be\ninserted.\n\n* dht_insert_node\n\nThis is a softer bootstrapping method, which doesn't actually send\na query -- it only stores the node in the routing table for later use.\n\nNote that dht_insert_node requires that you supply a node id.  If the id\nturns out to be wrong, the DHT will eventually recover; still, inserting\nmassive amounts of incorrect information into your routing table is not\na good idea.\n\nAn additionaly difficulty with dht_insert_node is that a Kademlia routing\ntable cannot absorb nodes faster than a certain rate.  A freshly initialised\nrouting table is able to absorb 128 nodes of each address family without\ndropping any.  The tolerable rate after that is difficult to estimate: it is\nprobably on the order of one node every few seconds per node already in\nthe table divided by 8, for some suitable value of 8.\n\nDoing some work\n***************\n\n* dht_periodic\n\nThis function should be called by your main loop periodically, and also\nwhenever data is available on the socket.  The time after which\ndht_periodic should be called if no data is available is returned in the\nparameter tosleep.  (You do not need to be particularly accurate; actually,\nit is a good idea to be late by a random value.)\n\nThe parameters buf, buflen, from and fromlen optionally carry a received\nmessage.  If buflen is 0, then no message was received.\n\nDht_periodic also takes a callback, which will be called whenever something\ninteresting happens (see below).\n\n* dht_search\n\nThis schedules a search for information about the info-hash specified in\nid; it returns 1 if this is a new search, and 0 if it merely reset the\ntimeouts for a search in progress.  If port is not 0, it specifies the TCP\nport on which the current peer is listening; in that case, when the search\nis complete it will be announced to the network.  The port is in host\norder, beware if you got it from a struct sockaddr_in.\n\nIn either case, data is passed to the callback function as soon as it is\navailable, possibly in multiple pieces.  The callback function will also\nbe called when the search is complete.\n\nUp to DHT_MAX_SEARCHES (1024) searches can be in progress at a given time;\nany more, and dht_search will return -1.  If you specify a new search for\nthe same info hash as a search still in progress, the previous search is\ncombined with the new one -- you will only receive a completion indication\nonce.\n\nInformation queries\n*******************\n\n* dht_nodes\n\nThis returns the number of known good, dubious and cached nodes in our\nrouting table.  This can be used to decide whether it's reasonable to start\na search; a search is likely to be successful as long as we have a few good\nnodes; however, in order to avoid overloading your bootstrap nodes, you may\nwant to wait until good is at least 4 and good + doubtful is at least 30 or\nso.\n\nIt also includes the number of nodes that recently sent us an unsolicited\nrequest; this can be used to determine if the UDP port used for the DHT is\nfirewalled.\n\nIf you want to display a single figure to the user, you should display\ngood + doubtful, which is the total number of nodes in your routing table.\nSome clients try to estimate the total number of nodes, but this doesn't\nmake much sense -- since the result is exponential in the number of nodes\nin the routing table, small variations in the latter cause huge jumps in\nthe former.\n\n* dht_get_nodes\n\nThis retrieves the list of known good nodes, starting with the nodes in our\nown bucket.  It is a good idea to save the list of known good nodes at\nshutdown, and ping them at startup.\n\n* dht_dump_tables\n* dht_debug\n\nThese are debugging aids.\n\nFunctions provided by you\n*************************\n\n* The callback function\n\nThe callback function is called with 5 arguments.  Closure is simply the\nvalue that you passed to dht_periodic.  Event is one of DHT_EVENT_VALUES or\nDHT_EVENT_VALUES6, which indicates that we have new values, or\nDHT_EVENT_SEARCH_DONE or DHT_EVENT_SEARCH_DONE6, which indicates that\na search has completed.  In either case, info_hash is set to the info-hash\nof the search.\n\nIn the case of DHT_EVENT_VALUES, data is a list of nodes in ``compact''\nformat -- 6 or 18 bytes per node.  Its length in bytes is in data_len.\n\n* dht_sendto\n\nThis will be called whenever the library needs to send a datagram.  If the\nintegers passed to dht_init are file descriptors, this can simply be an\nalias for the sendto system call.\n\n* dht_blacklisted\n\nThis is a function that takes an IP address and returns true if this\naddress should be silently ignored.  Do not use this feature unless you\nreally must -- Kademlia supposes transitive reachability.\n\n* dht_hash\n\nThis should compute a reasonably strong cryptographic hash of the passed\nvalues.  SHA-1 should be good enough.\n\n* dht_random_bytes\n\nThis should fill the supplied buffer with cryptographically strong random\nbytes.  It's called every 30 minutes on average, so it doesn't need to be\nfast.\n\nFinal notes\n***********\n\n* NAT\n\nNothing works well across NATs, but Kademlia is somewhat less impacted than\nmany other protocols.  The implementation takes care to distinguish between\nunidirectional and bidirectional reachability, and NATed nodes will\neventually fall out from other nodes' routing tables.\n\nWhile there is no periodic pinging in this implementation, maintaining\na full routing table requires slightly more than one packet exchange per\nminute, even in a completely idle network; this should be sufficient to\nmake most full cone NATs happy.\n\n\n                                        Juliusz Chroboczek\n                                        \u003cjch@pps.jussieu.fr\u003e\n","versions":[{"ref":"master","manifest":"targets = [ \"//:dht\" ]","lockFile":"manifest = \"516eccb33e8b89fa3f830418c6dc9c94ac1ec10b995cf8a2c21b57c062eb679e\"\n\n","buck":"load('//:buckaroo_macros.bzl', 'buckaroo_deps')\n\nprebuilt_cxx_library(\n  name = 'crypt',\n  header_only = True,\n  exported_linker_flags = [\n    '-lcrypt',\n  ],\n)\n\ncxx_library(\n  name = 'dht',\n  header_namespace = '',\n  exported_headers = [\n    'dht.h',\n  ],\n  srcs = [\n    'dht.c',\n  ],\n  licenses = [\n    'LICENCE',\n  ],\n  deps = [\n    ':crypt',\n  ] + buckaroo_deps(),\n  visibility = [\n    'PUBLIC',\n  ],\n)\n\ncxx_binary(\n  name = 'example',\n  srcs = [\n    'dht-example.c',\n  ],\n  deps = [\n    '//:dht',\n  ],\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-31T16:20:36Z","updatedUpstream":"2021-01-05T08:04:35Z","contributors":[{"login":"ghazel","avatarUrl":"https://avatars2.githubusercontent.com/u/31402?u=1ebef8a622b2b5da1356a509e6864f27ed6f0915\u0026v=4"},{"login":"raspopov","avatarUrl":"https://avatars1.githubusercontent.com/u/228064?u=dec79ae7d10c5248fbcc882ea25ac82bd0e90d29\u0026v=4"},{"login":"jech","avatarUrl":"https://avatars2.githubusercontent.com/u/290341?v=4"},{"login":"mikedld","avatarUrl":"https://avatars1.githubusercontent.com/u/298203?v=4"},{"login":"Erkan-Yilmaz","avatarUrl":"https://avatars1.githubusercontent.com/u/642286?v=4"},{"login":"FalseCAM","avatarUrl":"https://avatars0.githubusercontent.com/u/818276?v=4"},{"login":"GamePad64","avatarUrl":"https://avatars3.githubusercontent.com/u/837953?v=4"},{"login":"fonic","avatarUrl":"https://avatars3.githubusercontent.com/u/14027079?u=09634a743d6bc4698e252f4c692982df45481846\u0026v=4"},{"login":"joel-su","avatarUrl":"https://avatars2.githubusercontent.com/u/45835356?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":584,"forks":159,"topics":[]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"jech-dht"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>