<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/google-leveldb/logo.png"/></div><div><h1>buckaroo-pm/google-leveldb</h1><div style="max-width:600px">LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.</div><br/></div></div><div style="display:inline-flex;flex-flow:row wrap"></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><p><strong>LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.</strong></p><p><a href="https://travis-ci.org/google/leveldb"><img src="https://travis-ci.org/google/leveldb.svg?branch=master" alt="Build Status"/></a></p><p>Authors: Sanjay Ghemawat (<a href="mailto:sanjay@google.com">sanjay@google.com</a>) and Jeff Dean (<a href="mailto:jeff@google.com">jeff@google.com</a>)</p><h1>Features</h1><ul><li>Keys and values are arbitrary byte arrays.</li><li>Data is stored sorted by key.</li><li>Callers can provide a custom comparison function to override the sort order.</li><li>The basic operations are <code>Put(key,value)</code>, <code>Get(key)</code>, <code>Delete(key)</code>.</li><li>Multiple changes can be made in one atomic batch.</li><li>Users can create a transient snapshot to get a consistent view of data.</li><li>Forward and backward iteration is supported over the data.</li><li>Data is automatically compressed using the <a href="http://google.github.io/snappy/">Snappy compression library</a>.</li><li>External activity (file system operations etc.) is relayed through a virtual interface so users can customize the operating system interactions.</li></ul><h1>Documentation</h1><p><a href="https://rawgit.com/google/leveldb/master/doc/index.html">LevelDB library documentation</a> is online and bundled with the source code.</p><h1>Limitations</h1><ul><li>This is not a SQL database.  It does not have a relational data model, it does not support SQL queries, and it has no support for indexes.</li><li>Only a single process (possibly multi-threaded) can access a particular database at a time.</li><li>There is no client-server support builtin to the library.  An application that needs such support will have to wrap their own server around the library.</li></ul><h1>Contributing to the leveldb Project</h1><p>The leveldb project welcomes contributions. leveldb&#x27;s primary goal is to be
a reliable and fast key/value store. Changes that are in line with the
features/limitations outlined above, and meet the requirements below,
will be considered.</p><p>Contribution requirements:</p><ol><li><p><strong>POSIX only</strong>. We <em>generally</em> will only accept changes that are both
compiled, and tested on a POSIX platform - usually Linux. Very small
changes will sometimes be accepted, but consider that more of an
exception than the rule.</p></li><li><p><strong>Stable API</strong>. We strive very hard to maintain a stable API. Changes that
require changes for projects using leveldb <em>might</em> be rejected without
sufficient benefit to the project.</p></li><li><p><strong>Tests</strong>: All changes must be accompanied by a new (or changed) test, or
a sufficient explanation as to why a new (or changed) test is not required.</p></li></ol><h2>Submitting a Pull Request</h2><p>Before any pull request will be accepted the author must first sign a
Contributor License Agreement (CLA) at <a href="https://cla.developers.google.com/">https://cla.developers.google.com/</a>.</p><p>In order to keep the commit timeline linear
<a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History#Squashing-Commits">squash</a>
your changes down to a single commit and <a href="https://git-scm.com/docs/git-rebase">rebase</a>
on google/leveldb/master. This keeps the commit timeline linear and more easily sync&#x27;ed
with the internal repository at Google. More information at GitHub&#x27;s
<a href="https://help.github.com/articles/about-git-rebase/">About Git rebase</a> page.</p><h1>Performance</h1><p>Here is a performance report (with explanations) from the run of the
included db_bench program.  The results are somewhat noisy, but should
be enough to get a ballpark performance estimate.</p><h2>Setup</h2><p>We use a database with a million entries.  Each entry has a 16 byte
key, and a 100 byte value.  Values used by the benchmark compress to
about half their original size.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>LevelDB:    version 1.1
</span>Date:       Sun May  1 12:11:26 2011
<!-- -->CPU:        4 x Intel(R) Core(TM)2 Quad CPU    Q6600  @ 2.40GHz
<!-- -->CPUCache:   4096 KB
<!-- -->Keys:       16 bytes each
<!-- -->Values:     100 bytes each (50 bytes after compression)
<!-- -->Entries:    1000000
<!-- -->Raw Size:   110.6 MB (estimated)
<!-- -->File Size:  62.9 MB (estimated)
</code></pre><h2>Write performance</h2><p>The &quot;fill&quot; benchmarks create a brand new database, in either
sequential, or random order.  The &quot;fillsync&quot; benchmark flushes data
from the operating system to the disk after every operation; the other
write operations leave the data sitting in the operating system buffer
cache for a while.  The &quot;overwrite&quot; benchmark does random writes that
update existing keys in the database.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>fillseq      :       1.765 micros/op;   62.7 MB/s
</span>fillsync     :     268.409 micros/op;    0.4 MB/s (10000 ops)
<!-- -->fillrandom   :       2.460 micros/op;   45.0 MB/s
<!-- -->overwrite    :       2.380 micros/op;   46.5 MB/s
</code></pre><p>Each &quot;op&quot; above corresponds to a write of a single key/value pair.
I.e., a random write benchmark goes at approximately 400,000 writes per second.</p><p>Each &quot;fillsync&quot; operation costs much less (0.3 millisecond)
than a disk seek (typically 10 milliseconds).  We suspect that this is
because the hard disk itself is buffering the update in its memory and
responding before the data has been written to the platter.  This may
or may not be safe based on whether or not the hard disk has enough
power to save its memory in the event of a power failure.</p><h2>Read performance</h2><p>We list the performance of reading sequentially in both the forward
and reverse direction, and also the performance of a random lookup.
Note that the database created by the benchmark is quite small.
Therefore the report characterizes the performance of leveldb when the
working set fits in memory.  The cost of reading a piece of data that
is not present in the operating system buffer cache will be dominated
by the one or two disk seeks needed to fetch the data from disk.
Write performance will be mostly unaffected by whether or not the
working set fits in memory.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>readrandom   :      16.677 micros/op;  (approximately 60,000 reads per second)
</span>readseq      :       0.476 micros/op;  232.3 MB/s
<!-- -->readreverse  :       0.724 micros/op;  152.9 MB/s
</code></pre><p>LevelDB compacts its underlying storage data in the background to
improve read performance.  The results listed above were done
immediately after a lot of random writes.  The results after
compactions (which are usually triggered automatically) are better.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>readrandom   :      11.602 micros/op;  (approximately 85,000 reads per second)
</span>readseq      :       0.423 micros/op;  261.8 MB/s
<!-- -->readreverse  :       0.663 micros/op;  166.9 MB/s
</code></pre><p>Some of the high cost of reads comes from repeated decompression of blocks
read from disk.  If we supply enough cache to the leveldb so it can hold the
uncompressed blocks in memory, the read performance improves again:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>readrandom   :       9.775 micros/op;  (approximately 100,000 reads per second before compaction)
</span>readrandom   :       5.215 micros/op;  (approximately 190,000 reads per second after compaction)
</code></pre><h2>Repository contents</h2><p>See doc/index.html for more explanation. See doc/impl.html for a brief overview of the implementation.</p><p>The public interface is in include/*.h.  Callers should not include or
rely on the details of any other header files in this package.  Those
internal APIs may be changed without warning.</p><p>Guide to header files:</p><ul><li><p><strong>include/db.h</strong>: Main interface to the DB: Start here</p></li><li><p><strong>include/options.h</strong>: Control over the behavior of an entire database,</p></li></ul><p>and also control over the behavior of individual reads and writes.</p><ul><li><strong>include/comparator.h</strong>: Abstraction for user-specified comparison function.</li></ul><p>If you want just bytewise comparison of keys, you can use the default
comparator, but clients can write their own comparator implementations if they
want custom ordering (e.g. to handle different character encodings, etc.)</p><ul><li><strong>include/iterator.h</strong>: Interface for iterating over data. You can get</li></ul><p>an iterator from a DB object.</p><ul><li><strong>include/write_batch.h</strong>: Interface for atomically applying multiple</li></ul><p>updates to a database.</p><ul><li><strong>include/slice.h</strong>: A simple module for maintaining a pointer and a</li></ul><p>length into some other byte array.</p><ul><li><strong>include/status.h</strong>: Status is returned from many of the public interfaces</li></ul><p>and is used to report success and various kinds of errors.</p><ul><li><strong>include/env.h</strong>:</li></ul><p>Abstraction of the OS environment.  A posix implementation of this interface is
in util/env_posix.cc</p><ul><li><strong>include/table.h, include/table_builder.h</strong>: Lower-level modules that most</li></ul><p>clients probably won&#x27;t use directly</p></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/google-leveldb","name":"njlr/leveldb","licence":"BSD-3-Clause","description":"LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.","readme":"**LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.**\n\n[![Build Status](https://travis-ci.org/google/leveldb.svg?branch=master)](https://travis-ci.org/google/leveldb)\n\nAuthors: Sanjay Ghemawat (sanjay@google.com) and Jeff Dean (jeff@google.com)\n\n# Features\n  * Keys and values are arbitrary byte arrays.\n  * Data is stored sorted by key.\n  * Callers can provide a custom comparison function to override the sort order.\n  * The basic operations are `Put(key,value)`, `Get(key)`, `Delete(key)`.\n  * Multiple changes can be made in one atomic batch.\n  * Users can create a transient snapshot to get a consistent view of data.\n  * Forward and backward iteration is supported over the data.\n  * Data is automatically compressed using the [Snappy compression library](http://google.github.io/snappy/).\n  * External activity (file system operations etc.) is relayed through a virtual interface so users can customize the operating system interactions.\n\n# Documentation\n  [LevelDB library documentation](https://rawgit.com/google/leveldb/master/doc/index.html) is online and bundled with the source code.\n\n\n# Limitations\n  * This is not a SQL database.  It does not have a relational data model, it does not support SQL queries, and it has no support for indexes.\n  * Only a single process (possibly multi-threaded) can access a particular database at a time.\n  * There is no client-server support builtin to the library.  An application that needs such support will have to wrap their own server around the library.\n\n# Contributing to the leveldb Project\nThe leveldb project welcomes contributions. leveldb's primary goal is to be\na reliable and fast key/value store. Changes that are in line with the\nfeatures/limitations outlined above, and meet the requirements below,\nwill be considered.\n\nContribution requirements:\n\n1. **POSIX only**. We _generally_ will only accept changes that are both\n   compiled, and tested on a POSIX platform - usually Linux. Very small\n   changes will sometimes be accepted, but consider that more of an\n   exception than the rule.\n\n2. **Stable API**. We strive very hard to maintain a stable API. Changes that\n   require changes for projects using leveldb _might_ be rejected without\n   sufficient benefit to the project.\n\n3. **Tests**: All changes must be accompanied by a new (or changed) test, or\n   a sufficient explanation as to why a new (or changed) test is not required.\n\n## Submitting a Pull Request\nBefore any pull request will be accepted the author must first sign a\nContributor License Agreement (CLA) at https://cla.developers.google.com/.\n\nIn order to keep the commit timeline linear\n[squash](https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History#Squashing-Commits)\nyour changes down to a single commit and [rebase](https://git-scm.com/docs/git-rebase)\non google/leveldb/master. This keeps the commit timeline linear and more easily sync'ed\nwith the internal repository at Google. More information at GitHub's\n[About Git rebase](https://help.github.com/articles/about-git-rebase/) page.\n\n# Performance\n\nHere is a performance report (with explanations) from the run of the\nincluded db_bench program.  The results are somewhat noisy, but should\nbe enough to get a ballpark performance estimate.\n\n## Setup\n\nWe use a database with a million entries.  Each entry has a 16 byte\nkey, and a 100 byte value.  Values used by the benchmark compress to\nabout half their original size.\n\n    LevelDB:    version 1.1\n    Date:       Sun May  1 12:11:26 2011\n    CPU:        4 x Intel(R) Core(TM)2 Quad CPU    Q6600  @ 2.40GHz\n    CPUCache:   4096 KB\n    Keys:       16 bytes each\n    Values:     100 bytes each (50 bytes after compression)\n    Entries:    1000000\n    Raw Size:   110.6 MB (estimated)\n    File Size:  62.9 MB (estimated)\n\n## Write performance\n\nThe \"fill\" benchmarks create a brand new database, in either\nsequential, or random order.  The \"fillsync\" benchmark flushes data\nfrom the operating system to the disk after every operation; the other\nwrite operations leave the data sitting in the operating system buffer\ncache for a while.  The \"overwrite\" benchmark does random writes that\nupdate existing keys in the database.\n\n    fillseq      :       1.765 micros/op;   62.7 MB/s\n    fillsync     :     268.409 micros/op;    0.4 MB/s (10000 ops)\n    fillrandom   :       2.460 micros/op;   45.0 MB/s\n    overwrite    :       2.380 micros/op;   46.5 MB/s\n\nEach \"op\" above corresponds to a write of a single key/value pair.\nI.e., a random write benchmark goes at approximately 400,000 writes per second.\n\nEach \"fillsync\" operation costs much less (0.3 millisecond)\nthan a disk seek (typically 10 milliseconds).  We suspect that this is\nbecause the hard disk itself is buffering the update in its memory and\nresponding before the data has been written to the platter.  This may\nor may not be safe based on whether or not the hard disk has enough\npower to save its memory in the event of a power failure.\n\n## Read performance\n\nWe list the performance of reading sequentially in both the forward\nand reverse direction, and also the performance of a random lookup.\nNote that the database created by the benchmark is quite small.\nTherefore the report characterizes the performance of leveldb when the\nworking set fits in memory.  The cost of reading a piece of data that\nis not present in the operating system buffer cache will be dominated\nby the one or two disk seeks needed to fetch the data from disk.\nWrite performance will be mostly unaffected by whether or not the\nworking set fits in memory.\n\n    readrandom   :      16.677 micros/op;  (approximately 60,000 reads per second)\n    readseq      :       0.476 micros/op;  232.3 MB/s\n    readreverse  :       0.724 micros/op;  152.9 MB/s\n\nLevelDB compacts its underlying storage data in the background to\nimprove read performance.  The results listed above were done\nimmediately after a lot of random writes.  The results after\ncompactions (which are usually triggered automatically) are better.\n\n    readrandom   :      11.602 micros/op;  (approximately 85,000 reads per second)\n    readseq      :       0.423 micros/op;  261.8 MB/s\n    readreverse  :       0.663 micros/op;  166.9 MB/s\n\nSome of the high cost of reads comes from repeated decompression of blocks\nread from disk.  If we supply enough cache to the leveldb so it can hold the\nuncompressed blocks in memory, the read performance improves again:\n\n    readrandom   :       9.775 micros/op;  (approximately 100,000 reads per second before compaction)\n    readrandom   :       5.215 micros/op;  (approximately 190,000 reads per second after compaction)\n\n## Repository contents\n\nSee doc/index.html for more explanation. See doc/impl.html for a brief overview of the implementation.\n\nThe public interface is in include/*.h.  Callers should not include or\nrely on the details of any other header files in this package.  Those\ninternal APIs may be changed without warning.\n\nGuide to header files:\n\n* **include/db.h**: Main interface to the DB: Start here\n\n* **include/options.h**: Control over the behavior of an entire database,\nand also control over the behavior of individual reads and writes.\n\n* **include/comparator.h**: Abstraction for user-specified comparison function. \nIf you want just bytewise comparison of keys, you can use the default\ncomparator, but clients can write their own comparator implementations if they\nwant custom ordering (e.g. to handle different character encodings, etc.)\n\n* **include/iterator.h**: Interface for iterating over data. You can get\nan iterator from a DB object.\n\n* **include/write_batch.h**: Interface for atomically applying multiple\nupdates to a database.\n\n* **include/slice.h**: A simple module for maintaining a pointer and a\nlength into some other byte array.\n\n* **include/status.h**: Status is returned from many of the public interfaces\nand is used to report success and various kinds of errors.\n\n* **include/env.h**: \nAbstraction of the OS environment.  A posix implementation of this interface is\nin util/env_posix.cc\n\n* **include/table.h, include/table_builder.h**: Lower-level modules that most\nclients probably won't use directly\n","versions":[],"updated":"2018-10-28T13:56:32Z","updatedUpstream":"2017-01-23T22:29:37Z","contributors":[{"login":"njlr","avatarUrl":"https://avatars2.githubusercontent.com/u/1577531?u=b805a63f8054b62169749f2c9d2e89eb53af57d7\u0026v=4"}],"fundingLinks":[],"contactLinks":[],"stars":0,"forks":2,"topics":[]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"google-leveldb"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>