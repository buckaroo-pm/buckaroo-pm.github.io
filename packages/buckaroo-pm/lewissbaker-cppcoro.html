<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/lewissbaker-cppcoro/logo.png"/></div><div><h1>buckaroo-pm/lewissbaker-cppcoro</h1><div style="max-width:600px">A library of C++ coroutine abstractions for the coroutines TS</div><br/><div><b>1533</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">coroutines</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">cplusplus</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">asynchronous-programming</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">async-await</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">coroutines-ts</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">windows</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">msvc</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">clang</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">cpp</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">async</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">asyncio</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">linux</span></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><h1>CppCoro - A coroutine library for C++</h1><p>The &#x27;cppcoro&#x27; library provides a set of general-purpose primitives for making use of the coroutines TS proposal described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf">N4680</a>.</p><p>These include:</p><ul><li>Coroutine Types<ul><li><code>task&lt;T&gt;</code></li><li><code>shared_task&lt;T&gt;</code></li><li><code>generator&lt;T&gt;</code></li><li><code>recursive_generator&lt;T&gt;</code></li><li><code>async_generator&lt;T&gt;</code></li></ul></li><li>Awaitable Types<ul><li><code>single_consumer_event</code></li><li><code>single_consumer_auto_reset_event</code></li><li><code>async_mutex</code></li><li><code>async_manual_reset_event</code></li><li><code>async_auto_reset_event</code></li><li><code>async_latch</code></li></ul></li><li>Functions<ul><li><code>sync_wait()</code></li><li><code>when_all()</code></li><li><code>when_all_ready()</code></li><li><code>fmap()</code></li><li><code>schedule_on()</code></li><li><code>resume_on()</code></li></ul></li><li>Cancellation<ul><li><code>cancellation_token</code></li><li><code>cancellation_source</code></li><li><code>cancellation_registration</code></li></ul></li><li>Schedulers and I/O<ul><li><code>static_thread_pool</code></li><li><code>io_service</code></li><li><code>io_work_scope</code></li><li><code>file</code>, <code>readable_file</code>, <code>writable_file</code></li><li><code>read_only_file</code>, <code>write_only_file</code>, <code>read_write_file</code></li></ul></li></ul><p>Networking</p><ul><li><code>socket</code></li><li><code>ip_address</code>, <code>ipv4_address</code>, <code>ipv6_address</code></li><li><code>ip_endpoint</code>, <code>ipv4_endpoint</code>, <code>ipv6_endpoint</code></li><li>Metafunctions<ul><li><code>is_awaitable&lt;T&gt;</code></li><li><code>awaitable_traits&lt;T&gt;</code></li></ul></li><li>Concepts<ul><li><code>Awaitable&lt;T&gt;</code></li><li><code>Awaiter&lt;T&gt;</code></li><li><code>Scheduler</code></li><li><code>DelayedScheduler</code></li></ul></li></ul><p>This library is an experimental library that is exploring the space of high-performance,
scalable asynchronous programming abstractions that can be built on top of the C++ coroutines
proposal.</p><p>It has been open-sourced in the hope that others will find it useful and that the C++ community
can provide feedback on it and ways to improve it.</p><p>It requires a compiler that supports the coroutines TS:</p><ul><li>Windows + Visual Studio 2017 <a href="https://ci.appveyor.com/project/lewissbaker/cppcoro/branch/master"><img src="https://ci.appveyor.com/api/projects/status/github/lewissbaker/cppcoro?branch=master&amp;svg=true&amp;passingText=master%20-%20OK&amp;failingText=master%20-%20Failing&amp;pendingText=master%20-%20Pending" alt="Windows Build Status"/></a></li><li>Linux + Clang 5.0/6.0 + libc++ <a href="https://travis-ci.org/lewissbaker/cppcoro"><img src="https://travis-ci.org/lewissbaker/cppcoro.svg?branch=master" alt="Build Status"/></a></li></ul><p>The Linux version is functional except for the <code>io_context</code> and file I/O related classes which have not yet been implemented for Linux (see issue <a href="https://github.com/lewissbaker/cppcoro/issues/15">#15</a> for more info).</p><h1>Class Details</h1><h2><code>task&lt;T&gt;</code></h2><p>A task represents an asynchronous computation that is executed lazily in
that the execution of the coroutine does not start until the task is awaited.</p><p>Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#include &lt;cppcoro/read_only_file.hpp&gt;
</span>#include &lt;cppcoro/task.hpp&gt;
<!-- -->
<!-- -->cppcoro::task&lt;int&gt; count_lines(std::string path)
<!-- -->{
<!-- -->  auto file = co_await cppcoro::read_only_file::open(path);
<!-- -->
<!-- -->  int lineCount = 0;
<!-- -->
<!-- -->  char buffer[1024];
<!-- -->  size_t bytesRead;
<!-- -->  std::uint64_t offset = 0;
<!-- -->  do
<!-- -->  {
<!-- -->    bytesRead = co_await file.read(offset, buffer, sizeof(buffer));
<!-- -->    lineCount += std::count(buffer, buffer + bytesRead, &#x27;\n&#x27;);
<!-- -->    offset += bytesRead;
<!-- -->  } while (bytesRead &gt; 0);
<!-- -->  
<!-- -->  co_return lineCount;
<!-- -->}
<!-- -->
<!-- -->cppcoro::task&lt;&gt; usage_example()
<!-- -->{
<!-- -->  // Calling function creates a new task but doesn&#x27;t start
<!-- -->  // executing the coroutine yet.
<!-- -->  cppcoro::task&lt;int&gt; countTask = count_lines(&quot;foo.txt&quot;);
<!-- -->  
<!-- -->  // ...
<!-- -->  
<!-- -->  // Coroutine is only started when we later co_await the task.
<!-- -->  int lineCount = co_await countTask;
<!-- -->
<!-- -->  std::cout &lt;&lt; &quot;line count = &quot; &lt;&lt; lineCount &lt;&lt; std::endl;
<!-- -->}
</code></pre><p>API Overview:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/task.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  template&lt;typename T&gt;
<!-- -->  class task
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    using promise_type = &lt;unspecified&gt;;
<!-- -->    using value_type = T;
<!-- -->
<!-- -->    task() noexcept;
<!-- -->
<!-- -->    task(task&amp;&amp; other) noexcept;
<!-- -->    task&amp; operator=(task&amp;&amp; other);
<!-- -->
<!-- -->    // task is a move-only type.
<!-- -->    task(const task&amp; other) = delete;
<!-- -->    task&amp; operator=(const task&amp; other) = delete;
<!-- -->
<!-- -->    // Query if the task result is ready.
<!-- -->    bool is_ready() const noexcept;
<!-- -->
<!-- -->    // Wait for the task to complete and return the result or rethrow the
<!-- -->    // exception if the operation completed with an unhandled exception.
<!-- -->    //
<!-- -->    // If the task is not yet ready then the awaiting coroutine will be
<!-- -->    // suspended until the task completes. If the the task is_ready() then
<!-- -->    // this operation will return the result synchronously without suspending.
<!-- -->    Awaiter&lt;T&amp;&gt; operator co_await() const &amp; noexcept;
<!-- -->    Awaiter&lt;T&amp;&amp;&gt; operator co_await() const &amp;&amp; noexcept;
<!-- -->
<!-- -->    // Returns an awaitable that can be co_await&#x27;ed to suspend the current
<!-- -->    // coroutine until the task completes.
<!-- -->    //
<!-- -->    // The &#x27;co_await t.when_ready()&#x27; expression differs from &#x27;co_await t&#x27; in
<!-- -->    // that when_ready() only performs synchronisation, it does not return
<!-- -->    // the result or rethrow the exception.
<!-- -->    //
<!-- -->    // This can be useful if you want to synchronise with the task without
<!-- -->    // the possibility of it throwing an exception.
<!-- -->    Awaitable&lt;void&gt; when_ready() const noexcept;
<!-- -->  };
<!-- -->
<!-- -->  template&lt;typename T&gt;
<!-- -->  void swap(task&lt;T&gt;&amp; a, task&lt;T&gt;&amp; b);
<!-- -->
<!-- -->  // Creates a task that yields the result of co_await&#x27;ing the specified awaitable.
<!-- -->  //
<!-- -->  // This can be used as a form of type-erasure of the concrete awaitable, allowing
<!-- -->  // different awaitables that return the same await-result type to be stored in
<!-- -->  // the same task&lt;RESULT&gt; type.
<!-- -->  template&lt;
<!-- -->    typename AWAITABLE,
<!-- -->    typename RESULT = typename awaitable_traits&lt;AWAITABLE&gt;::await_result_t&gt;
<!-- -->  task&lt;RESULT&gt; make_task(AWAITABLE awaitable);
<!-- -->}
</code></pre><p>You create a <code>task&lt;T&gt;</code> object by calling a coroutine function that returns
a <code>task&lt;T&gt;</code>.</p><p>The coroutine must contain a usage of either <code>co_await</code> or <code>co_return</code>.
Note that a <code>task&lt;T&gt;</code> coroutine may not use the <code>co_yield</code> keyword.</p><p>When a coroutine that returns a <code>task&lt;T&gt;</code> is called, a coroutine frame
is allocated if necessary and the parameters are captured in the coroutine
frame. The coroutine is suspended at the start of the coroutine body and
execution is returned to the caller and a <code>task&lt;T&gt;</code> value that represents
the asynchronous computation is returned from the function call.</p><p>The coroutine body will start executing when the <code>task&lt;T&gt;</code> value is
<code>co_await</code>ed. This will suspend the awaiting coroutine and start execution
of the coroutine associated with the awaited <code>task&lt;T&gt;</code> value.</p><p>The awaiting coroutine will later be resumed on the thread that completes
execution of the awaited <code>task&lt;T&gt;</code>&#x27;s coroutine. ie. the thread that
executes the <code>co_return</code> or that throws an unhandled exception that terminates
execution of the coroutine.</p><p>If the task has already run to completion then awaiting it again will obtain
the already-computed result without suspending the awaiting coroutine.</p><p>If the <code>task</code> object is destroyed before it is awaited then the coroutine
never executes and the destructor simply destructs the captured parameters
and frees any memory used by the coroutine frame.</p><h2><code>shared_task&lt;T&gt;</code></h2><p>The <code>shared_task&lt;T&gt;</code> class is a coroutine type that yields a single value
asynchronously.</p><p>It is &#x27;lazy&#x27; in that execution of the task does not start until it is awaited by some
coroutine.</p><p>It is &#x27;shared&#x27; in that the task value can be copied, allowing multiple references to
the result of the task to be created. It also allows multiple coroutines to
concurrently await the result.</p><p>The task will start executing on the thread that first <code>co_await</code>s the task.
Subsequent awaiters will either be suspended and be queued for resumption
when the task completes or will continue synchronously if the task has
already run to completion.</p><p>If an awaiter is suspended while waiting for the task to complete then
it will be resumed on the thread that completes execution of the task.
ie. the thread that executes the <code>co_return</code> or that throws the unhandled
exception that terminates execution of the coroutine.</p><p>API Summary</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro
</span>{
<!-- -->  template&lt;typename T = void&gt;
<!-- -->  class shared_task
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    using promise_type = &lt;unspecified&gt;;
<!-- -->    using value_type = T;
<!-- -->
<!-- -->    shared_task() noexcept;
<!-- -->    shared_task(const shared_task&amp; other) noexcept;
<!-- -->    shared_task(shared_task&amp;&amp; other) noexcept;
<!-- -->    shared_task&amp; operator=(const shared_task&amp; other) noexcept;
<!-- -->    shared_task&amp; operator=(shared_task&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    void swap(shared_task&amp; other) noexcept;
<!-- -->
<!-- -->    // Query if the task has completed and the result is ready.
<!-- -->    bool is_ready() const noexcept;
<!-- -->
<!-- -->    // Returns an operation that when awaited will suspend the
<!-- -->    // current coroutine until the task completes and the result
<!-- -->    // is available.
<!-- -->    //
<!-- -->    // The type of the result of the &#x27;co_await someTask&#x27; expression
<!-- -->    // is an l-value reference to the task&#x27;s result value (unless T
<!-- -->    // is void in which case the expression has type &#x27;void&#x27;).
<!-- -->    // If the task completed with an unhandled exception then the
<!-- -->    // exception will be rethrown by the co_await expression.
<!-- -->    Awaiter&lt;T&amp;&gt; operator co_await() const noexcept;
<!-- -->
<!-- -->    // Returns an operation that when awaited will suspend the
<!-- -->    // calling coroutine until the task completes and the result
<!-- -->    // is available.
<!-- -->    //
<!-- -->    // The result is not returned from the co_await expression.
<!-- -->    // This can be used to synchronise with the task without the
<!-- -->    // possibility of the co_await expression throwing an exception.
<!-- -->    Awaiter&lt;void&gt; when_ready() const noexcept;
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  template&lt;typename T&gt;
<!-- -->  bool operator==(const shared_task&lt;T&gt;&amp; a, const shared_task&lt;T&gt;&amp; b) noexcept;
<!-- -->  template&lt;typename T&gt;
<!-- -->  bool operator!=(const shared_task&lt;T&gt;&amp; a, const shared_task&lt;T&gt;&amp; b) noexcept;
<!-- -->
<!-- -->  template&lt;typename T&gt;
<!-- -->  void swap(shared_task&lt;T&gt;&amp; a, shared_task&lt;T&gt;&amp; b) noexcept;
<!-- -->
<!-- -->  // Wrap an awaitable value in a shared_task to allow multiple coroutines
<!-- -->  // to concurrently await the result.
<!-- -->  template&lt;
<!-- -->    typename AWAITABLE,
<!-- -->    typename RESULT = typename awaitable_traits&lt;AWAITABLE&gt;::await_result_t&gt;
<!-- -->  shared_task&lt;RESULT&gt; make_shared_task(AWAITABLE awaitable);
<!-- -->}
</code></pre><p>All const-methods on <code>shared_task&lt;T&gt;</code> are safe to call concurrently with other
const-methods on the same instance from multiple threads. It is not safe to call
non-const methods of <code>shared_task&lt;T&gt;</code> concurrently with any other method on the
same instance of a <code>shared_task&lt;T&gt;</code>.</p><h3>Comparison to <code>task&lt;T&gt;</code></h3><p>The <code>shared_task&lt;T&gt;</code> class is similar to <code>task&lt;T&gt;</code> in that the task does
not start execution immediately upon the coroutine function being called.
The task only starts executing when it is first awaited.</p><p>It differs from <code>task&lt;T&gt;</code> in that the resulting task object can be copied,
allowing multiple task objects to reference the same asynchronous result.
It also supports multiple coroutines concurrently awaiting the result of the task.</p><p>The trade-off is that the result is always an l-value reference to the
result, never an r-value reference (since the result may be shared) which
may limit ability to move-construct the result into a local variable.
It also has a slightly higher run-time cost due to the need to maintain
a reference count and support multiple awaiters.</p><h2><code>generator&lt;T&gt;</code></h2><p>A <code>generator</code> represents a coroutine type that produces a sequence of values of type, <code>T</code>,
where values are produced lazily and synchronously.</p><p>The coroutine body is able to yield values of type <code>T</code> using the <code>co_yield</code> keyword.
Note, however, that the coroutine body is not able to use the <code>co_await</code> keyword;
values must be produced synchronously.</p><p>For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cppcoro::generator&lt;const std::uint64_t&gt; fibonacci()
</span>{
<!-- -->  std::uint64_t a = 0, b = 1;
<!-- -->  while (true)
<!-- -->  {
<!-- -->    co_yield b;
<!-- -->    auto tmp = a;
<!-- -->    a = b;
<!-- -->    b += tmp;
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->void usage()
<!-- -->{
<!-- -->  for (auto i : fibonacci())
<!-- -->  {
<!-- -->    if (i &gt; 1&#x27;000&#x27;000) break;
<!-- -->    std::cout &lt;&lt; i &lt;&lt; std::endl;
<!-- -->  }
<!-- -->}
</code></pre><p>When a coroutine function returning a <code>generator&lt;T&gt;</code> is called the coroutine is created initially suspended.
Execution of the coroutine enters the coroutine body when the <code>generator&lt;T&gt;::begin()</code> method is called and continues until
either the first <code>co_yield</code> statement is reached or the coroutine runs to completion.</p><p>If the returned iterator is not equal to the <code>end()</code> iterator then dereferencing the iterator will
return a reference to the value passed to the <code>co_yield</code> statement.</p><p>Calling <code>operator++()</code> on the iterator will resume execution of the coroutine and continue until
either the next <code>co_yield</code> point is reached or the coroutine runs to completion().</p><p>Any unhandled exceptions thrown by the coroutine will propagate out of the <code>begin()</code> or
<code>operator++()</code> calls to the caller.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro
</span>{
<!-- -->    template&lt;typename T&gt;
<!-- -->    class generator
<!-- -->    {
<!-- -->    public:
<!-- -->
<!-- -->        using promise_type = &lt;unspecified&gt;;
<!-- -->
<!-- -->        class iterator
<!-- -->        {
<!-- -->        public:
<!-- -->            using iterator_category = std::input_iterator_tag;
<!-- -->            using value_type = std::remove_reference_t&lt;T&gt;;
<!-- -->            using reference = value_type&amp;;
<!-- -->            using pointer = value_type*;
<!-- -->            using difference_type = std::size_t;
<!-- -->
<!-- -->            iterator(const iterator&amp; other) noexcept;
<!-- -->            iterator&amp; operator=(const iterator&amp; other) noexcept;
<!-- -->
<!-- -->            // If the generator coroutine throws an unhandled exception before producing
<!-- -->            // the next element then the exception will propagate out of this call.
<!-- -->            iterator&amp; operator++();
<!-- -->
<!-- -->            reference operator*() const noexcept;
<!-- -->            pointer operator-&gt;() const noexcept;
<!-- -->
<!-- -->            bool operator==(const iterator&amp; other) const noexcept;
<!-- -->            bool operator!=(const iterator&amp; other) const noexcept;
<!-- -->        };
<!-- -->
<!-- -->        // Constructs to the empty sequence.
<!-- -->        generator() noexcept;
<!-- -->
<!-- -->        generator(generator&amp;&amp; other) noexcept;
<!-- -->        generator&amp; operator=(generator&amp;&amp; other) noexcept;
<!-- -->        
<!-- -->        generator(const generator&amp; other) = delete;
<!-- -->        generator&amp; operator=(const generator&amp;) = delete;
<!-- -->
<!-- -->        ~generator();
<!-- -->
<!-- -->        // Starts executing the generator coroutine which runs until either a value is yielded
<!-- -->        // or the coroutine runs to completion or an unhandled exception propagates out of the
<!-- -->        // the coroutine.
<!-- -->        iterator begin();
<!-- -->
<!-- -->        iterator end() noexcept;
<!-- -->
<!-- -->        // Swap the contents of two generators.
<!-- -->        void swap(generator&amp; other) noexcept;
<!-- -->
<!-- -->    };
<!-- -->
<!-- -->    template&lt;typename T&gt;
<!-- -->    void swap(generator&lt;T&gt;&amp; a, generator&lt;T&gt;&amp; b) noexcept;
<!-- -->
<!-- -->    // Apply function, func, lazily to each element of the source generator
<!-- -->    // and yield a sequence of the results of calls to func().
<!-- -->    template&lt;typename FUNC, typename T&gt;
<!-- -->    generator&lt;std::invoke_result_t&lt;FUNC, T&amp;&gt;&gt; fmap(FUNC func, generator&lt;T&gt; source);
<!-- -->}
</code></pre><h2><code>recursive_generator&lt;T&gt;</code></h2><p>A <code>recursive_generator</code> is similar to a <code>generator</code> except that it is designed to more efficiently
support yielding the elements of a nested sequence as elements of an outer sequence.</p><p>In addition to being able to <code>co_yield</code> a value of type <code>T</code> you can also <code>co_yield</code> a value of type <code>recursive_generator&lt;T&gt;</code>.</p><p>When you <code>co_yield</code> a <code>recursive_generator&lt;T&gt;</code> value the all elements of the yielded generator are yielded as elements of the current generator.
The current coroutine is suspended until the consumer has finished consuming all elements of the nested generator, after which point execution
of the current coroutine will resume execution to produce the next element.</p><p>The benefit of <code>recursive_generator&lt;T&gt;</code> over <code>generator&lt;T&gt;</code> for iterating over recursive data-structures is that the <code>iterator::operator++()</code>
is able to directly resume the leaf-most coroutine to produce the next element, rather than having to resume/suspend O(depth) coroutines for each element.
The down-side is that there is additional overhead</p><p>For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// Lists the immediate contents of a directory.
</span>cppcoro::generator&lt;dir_entry&gt; list_directory(std::filesystem::path path);
<!-- -->
<!-- -->cppcoro::recursive_generator&lt;dir_entry&gt; list_directory_recursive(std::filesystem::path path)
<!-- -->{
<!-- -->  for (auto&amp; entry : list_directory(path))
<!-- -->  {
<!-- -->    co_yield entry;
<!-- -->    if (entry.is_directory())
<!-- -->    {
<!-- -->      co_yield list_directory_recursive(entry.path());
<!-- -->    }
<!-- -->  }
<!-- -->}
</code></pre><p>Note that applying the <code>fmap()</code> operator to a <code>recursive_generator&lt;T&gt;</code> will yield a <code>generator&lt;U&gt;</code>
type rather than a <code>recursive_generator&lt;U&gt;</code>. This is because uses of <code>fmap</code> are generally not used
in recursive contexts and we try to avoid the extra overhead incurred by <code>recursive_generator</code>.</p><h2><code>async_generator&lt;T&gt;</code></h2><p>An <code>async_generator</code> represents a coroutine type that produces a sequence of values of type, <code>T</code>, where values are produced lazily and values may be produced asynchronously.</p><p>The coroutine body is able to use both <code>co_await</code> and <code>co_yield</code> expressions.</p><p>Consumers of the generator can use a <code>for co_await</code> range-based for-loop to consume the values.</p><p>Example</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cppcoro::async_generator&lt;int&gt; ticker(int count, threadpool&amp; tp)
</span>{
<!-- -->  for (int i = 0; i &lt; count; ++i)
<!-- -->  {
<!-- -->    co_await tp.delay(std::chrono::seconds(1));
<!-- -->    co_yield i;
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->cppcoro::task&lt;&gt; consumer(threadpool&amp; tp)
<!-- -->{
<!-- -->  auto sequence = ticker(10, tp);
<!-- -->  for co_await(std::uint32_t i : sequence)
<!-- -->  {
<!-- -->    std::cout &lt;&lt; &quot;Tick &quot; &lt;&lt; i &lt;&lt; std::endl;
<!-- -->  }
<!-- -->}
</code></pre><p>API Summary</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/async_generator.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  template&lt;typename T&gt;
<!-- -->  class async_generator
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    class iterator
<!-- -->    {
<!-- -->    public:
<!-- -->      using iterator_tag = std::forward_iterator_tag;
<!-- -->      using difference_type = std::size_t;
<!-- -->      using value_type = std::remove_reference_t&lt;T&gt;;
<!-- -->      using reference = value_type&amp;;
<!-- -->      using pointer = value_type*;
<!-- -->      
<!-- -->      iterator(const iterator&amp; other) noexcept;
<!-- -->      iterator&amp; operator=(const iterator&amp; other) noexcept;
<!-- -->
<!-- -->      // Resumes the generator coroutine if suspended
<!-- -->      // Returns an operation object that must be awaited to wait
<!-- -->      // for the increment operation to complete.
<!-- -->      // If the coroutine runs to completion then the iterator
<!-- -->      // will subsequently become equal to the end() iterator.
<!-- -->      // If the coroutine completes with an unhandled exception then
<!-- -->      // that exception will be rethrown from the co_await expression.
<!-- -->      Awaitable&lt;iterator&amp;&gt; operator++() noexcept;
<!-- -->
<!-- -->      // Dereference the iterator.
<!-- -->      pointer operator-&gt;() const noexcept;
<!-- -->      reference operator*() const noexcept;
<!-- -->
<!-- -->      bool operator==(const iterator&amp; other) const noexcept;
<!-- -->      bool operator!=(const iterator&amp; other) const noexcept;
<!-- -->    };
<!-- -->
<!-- -->    // Construct to the empty sequence.
<!-- -->    async_generator() noexcept;
<!-- -->    async_generator(const async_generator&amp;) = delete;
<!-- -->    async_generator(async_generator&amp;&amp; other) noexcept;
<!-- -->    ~async_generator();
<!-- -->
<!-- -->    async_generator&amp; operator=(const async_generator&amp;) = delete;
<!-- -->    async_generator&amp; operator=(async_generator&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    void swap(async_generator&amp; other) noexcept;
<!-- -->
<!-- -->    // Starts execution of the coroutine and returns an operation object
<!-- -->    // that must be awaited to wait for the first value to become available.
<!-- -->    // The result of co_await&#x27;ing the returned object is an iterator that
<!-- -->    // can be used to advance to subsequent elements of the sequence.
<!-- -->    //
<!-- -->    // This method is not valid to be called once the coroutine has
<!-- -->    // run to completion.
<!-- -->    Awaitable&lt;iterator&gt; begin() noexcept;
<!-- -->    iterator end() noexcept;
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  template&lt;typename T&gt;
<!-- -->  void swap(async_generator&lt;T&gt;&amp; a, async_generator&lt;T&gt;&amp; b);
<!-- -->
<!-- -->  // Apply &#x27;func&#x27; to each element of the source generator, yielding a sequence of
<!-- -->  // the results of calling &#x27;func&#x27; on the source elements.
<!-- -->  template&lt;typename FUNC, typename T&gt;
<!-- -->  async_generator&lt;std::invoke_result_t&lt;FUNC, T&amp;&gt;&gt; fmap(FUNC func, async_generator&lt;T&gt; source);
<!-- -->}
</code></pre><h3>Early termination of an async_generator</h3><p>When the <code>async_generator</code> object is destructed it requests cancellation of the underlying coroutine.
If the coroutine has already run to completion or is currently suspended in a <code>co_yield</code> expression
then the coroutine is destroyed immediately. Otherwise, the coroutine will continue execution until
it either runs to completion or reaches the next <code>co_yield</code> expression.</p><p>When the coroutine frame is destroyed the destructors of all variables in scope at that point will be
executed to ensure the resources of the generator are cleaned up.</p><p>Note that the caller must ensure that the <code>async_generator</code> object must not be destroyed while a
consumer coroutine is executing a <code>co_await</code> expression waiting for the next item to be produced.</p><h2><code>single_consumer_event</code></h2><p>This is a simple manual-reset event type that supports only a single
coroutine awaiting it at a time.
This can be used to</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/single_consumer_event.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  class single_consumer_event
<!-- -->  {
<!-- -->  public:
<!-- -->    single_consumer_event(bool initiallySet = false) noexcept;
<!-- -->    bool is_set() const noexcept;
<!-- -->    void set();
<!-- -->    void reset() noexcept;
<!-- -->    Awaiter&lt;void&gt; operator co_await() const noexcept;
<!-- -->  };
<!-- -->}
</code></pre><p>Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#include &lt;cppcoro/single_consumer_event.hpp&gt;
</span>
<!-- -->cppcoro::single_consumer_event event;
<!-- -->std::string value;
<!-- -->
<!-- -->cppcoro::task&lt;&gt; consumer()
<!-- -->{
<!-- -->  // Coroutine will suspend here until some thread calls event.set()
<!-- -->  // eg. inside the producer() function below.
<!-- -->  co_await event;
<!-- -->
<!-- -->  std::cout &lt;&lt; value &lt;&lt; std::endl;
<!-- -->}
<!-- -->
<!-- -->void producer()
<!-- -->{
<!-- -->  value = &quot;foo&quot;;
<!-- -->
<!-- -->  // This will resume the consumer() coroutine inside the call to set()
<!-- -->  // if it is currently suspended.
<!-- -->  event.set();
<!-- -->}
</code></pre><h2><code>single_consumer_async_auto_reset_event</code></h2><p>This class provides an async synchronisation primitive that allows a single coroutine to
wait until the event is signalled by a call to the <code>set()</code> method.</p><p>Once the coroutine that is awaiting the event is released by either a prior or subsequent call to <code>set()</code>
the event is automatically reset back to the &#x27;not set&#x27; state.</p><p>This class is a more efficient version of <code>async_auto_reset_event</code> that can be used in cases where
only a single coroutine will be awaiting the event at a time. If you need to support multiple concurrent
awaiting coroutines on the event then use the <code>async_auto_reset_event</code> class instead.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/single_consumer_async_auto_reset_event.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  class single_consumer_async_auto_reset_event
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    single_consumer_async_auto_reset_event(
<!-- -->      bool initiallySet = false) noexcept;
<!-- -->
<!-- -->    // Change the event to the &#x27;set&#x27; state. If a coroutine is awaiting the
<!-- -->    // event then the event is immediately transitioned back to the &#x27;not set&#x27;
<!-- -->    // state and the coroutine is resumed.
<!-- -->    void set() noexcept;
<!-- -->
<!-- -->    // Returns an Awaitable type that can be awaited to wait until
<!-- -->    // the event becomes &#x27;set&#x27; via a call to the .set() method. If
<!-- -->    // the event is already in the &#x27;set&#x27; state then the coroutine
<!-- -->    // continues without suspending.
<!-- -->    // The event is automatically reset back to the &#x27;not set&#x27; state
<!-- -->    // before resuming the coroutine.
<!-- -->    Awaiter&lt;void&gt; operator co_await() const noexcept;
<!-- -->
<!-- -->  };
<!-- -->}
</code></pre><p>Example Usage:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>std::atomic&lt;int&gt; value;
</span>cppcoro::single_consumer_async_auto_reset_event valueDecreasedEvent;
<!-- -->
<!-- -->cppcoro::task&lt;&gt; wait_until_value_is_below(int limit)
<!-- -->{
<!-- -->  while (value.load(std::memory_order_relaxed) &gt;= limit)
<!-- -->  {
<!-- -->    // Wait until there has been some change that we&#x27;re interested in.
<!-- -->    co_await valueDecreasedEvent;
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->void change_value(int delta)
<!-- -->{
<!-- -->  value.fetch_add(delta, std::memory_order_relaxed);
<!-- -->  // Notify the waiter if there has been some change.
<!-- -->  if (delta &lt; 0) valueDecreasedEvent.set();
<!-- -->}
</code></pre><h2><code>async_mutex</code></h2><p>Provides a simple mutual exclusion abstraction that allows the caller to &#x27;co_await&#x27; the mutex
from within a coroutine to suspend the coroutine until the mutex lock is acquired.</p><p>The implementation is lock-free in that a coroutine that awaits the mutex will not
block the thread but will instead suspend the coroutine and later resume it inside
the call to <code>unlock()</code> by the previous lock-holder.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/async_mutex.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  class async_mutex_lock;
<!-- -->  class async_mutex_lock_operation;
<!-- -->  class async_mutex_scoped_lock_operation;
<!-- -->
<!-- -->  class async_mutex
<!-- -->  {
<!-- -->  public:
<!-- -->    async_mutex() noexcept;
<!-- -->    ~async_mutex();
<!-- -->
<!-- -->    async_mutex(const async_mutex&amp;) = delete;
<!-- -->    async_mutex&amp; operator(const async_mutex&amp;) = delete;
<!-- -->
<!-- -->    bool try_lock() noexcept;
<!-- -->    async_mutex_lock_operation lock_async() noexcept;
<!-- -->    async_mutex_scoped_lock_operation scoped_lock_async() noexcept;
<!-- -->    void unlock();
<!-- -->  };
<!-- -->
<!-- -->  class async_mutex_lock_operation
<!-- -->  {
<!-- -->  public:
<!-- -->    bool await_ready() const noexcept;
<!-- -->    bool await_suspend(std::experimental::coroutine_handle&lt;&gt; awaiter) noexcept;
<!-- -->    void await_resume() const noexcept;
<!-- -->  };
<!-- -->
<!-- -->  class async_mutex_scoped_lock_operation
<!-- -->  {
<!-- -->  public:
<!-- -->    bool await_ready() const noexcept;
<!-- -->    bool await_suspend(std::experimental::coroutine_handle&lt;&gt; awaiter) noexcept;
<!-- -->    [[nodiscard]] async_mutex_lock await_resume() const noexcept;
<!-- -->  };
<!-- -->
<!-- -->  class async_mutex_lock
<!-- -->  {
<!-- -->  public:
<!-- -->    // Takes ownership of the lock.
<!-- -->    async_mutex_lock(async_mutex&amp; mutex, std::adopt_lock_t) noexcept;
<!-- -->
<!-- -->    // Transfer ownership of the lock.
<!-- -->    async_mutex_lock(async_mutex_lock&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    async_mutex_lock(const async_mutex_lock&amp;) = delete;
<!-- -->    async_mutex_lock&amp; operator=(const async_mutex_lock&amp;) = delete;
<!-- -->
<!-- -->    // Releases the lock by calling unlock() on the mutex.
<!-- -->    ~async_mutex_lock();
<!-- -->  };
<!-- -->}
</code></pre><p>Example usage:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#include &lt;cppcoro/async_mutex.hpp&gt;
</span>#include &lt;cppcoro/task.hpp&gt;
<!-- -->#include &lt;set&gt;
<!-- -->#include &lt;string&gt;
<!-- -->
<!-- -->cppcoro::async_mutex mutex;
<!-- -->std::set&lt;std::string&gt; values;
<!-- -->
<!-- -->cppcoro::task&lt;&gt; add_item(std::string value)
<!-- -->{
<!-- -->  cppcoro::async_mutex_lock lock = co_await mutex.scoped_lock_async();
<!-- -->  values.insert(std::move(value));
<!-- -->}
</code></pre><h2><code>async_manual_reset_event</code></h2><p>A manual-reset event is a coroutine/thread-synchronisation primitive that allows one or more threads
to wait until the event is signalled by a thread that calls <code>set()</code>.</p><p>The event is in one of two states; <em>&#x27;set&#x27;</em> and <em>&#x27;not set&#x27;</em>.</p><p>If the event is in the <em>&#x27;set&#x27;</em> state when a coroutine awaits the event then the coroutine
continues without suspending. However if the coroutine is in the <em>&#x27;not set&#x27;</em> state then the
coroutine is suspended until some thread subsequently calls the <code>set()</code> method.</p><p>Any threads that were suspended while waiting for the event to become <em>&#x27;set&#x27;</em> will be resumed
inside the next call to <code>set()</code> by some thread.</p><p>Note that you must ensure that no coroutines are awaiting a <em>&#x27;not set&#x27;</em> event when the
event is destructed as they will not be resumed.</p><p>Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cppcoro::async_manual_reset_event event;
</span>std::string value;
<!-- -->
<!-- -->void producer()
<!-- -->{
<!-- -->  value = get_some_string_value();
<!-- -->
<!-- -->  // Publish a value by setting the event.
<!-- -->  event.set();
<!-- -->}
<!-- -->
<!-- -->// Can be called many times to create many tasks.
<!-- -->// All consumer tasks will wait until value has been published.
<!-- -->cppcoro::task&lt;&gt; consumer()
<!-- -->{
<!-- -->  // Wait until value has been published by awaiting event.
<!-- -->  co_await event;
<!-- -->
<!-- -->  consume_value(value);
<!-- -->}
</code></pre><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro
</span>{
<!-- -->  class async_manual_reset_event_operation;
<!-- -->
<!-- -->  class async_manual_reset_event
<!-- -->  {
<!-- -->  public:
<!-- -->    async_manual_reset_event(bool initiallySet = false) noexcept;
<!-- -->    ~async_manual_reset_event();
<!-- -->
<!-- -->    async_manual_reset_event(const async_manual_reset_event&amp;) = delete;
<!-- -->    async_manual_reset_event(async_manual_reset_event&amp;&amp;) = delete;
<!-- -->    async_manual_reset_event&amp; operator=(const async_manual_reset_event&amp;) = delete;
<!-- -->    async_manual_reset_event&amp; operator=(async_manual_reset_event&amp;&amp;) = delete;
<!-- -->
<!-- -->    // Wait until the event becomes set.
<!-- -->    async_manual_reset_event_operation operator co_await() const noexcept;
<!-- -->
<!-- -->    bool is_set() const noexcept;
<!-- -->
<!-- -->    void set() noexcept;
<!-- -->
<!-- -->    void reset() noexcept;
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class async_manual_reset_event_operation
<!-- -->  {
<!-- -->  public:
<!-- -->    async_manual_reset_event_operation(async_manual_reset_event&amp; event) noexcept;
<!-- -->
<!-- -->    bool await_ready() const noexcept;
<!-- -->    bool await_suspend(std::experimental::coroutine_handle&lt;&gt; awaiter) noexcept;
<!-- -->    void await_resume() const noexcept;
<!-- -->  };
<!-- -->}
</code></pre><h2><code>async_auto_reset_event</code></h2><p>An auto-reset event is a coroutine/thread-synchronisation primitive that allows one or more threads
to wait until the event is signalled by a thread by calling <code>set()</code>.</p><p>Once a coroutine that is awaiting the event is released by either a prior or subsequent call to <code>set()</code>
the event is automatically reset back to the &#x27;not set&#x27; state.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/async_auto_reset_event.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  class async_auto_reset_event_operation;
<!-- -->
<!-- -->  class async_auto_reset_event
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    async_auto_reset_event(bool initiallySet = false) noexcept;
<!-- -->
<!-- -->    ~async_auto_reset_event();
<!-- -->
<!-- -->    async_auto_reset_event(const async_auto_reset_event&amp;) = delete;
<!-- -->    async_auto_reset_event(async_auto_reset_event&amp;&amp;) = delete;
<!-- -->    async_auto_reset_event&amp; operator=(const async_auto_reset_event&amp;) = delete;
<!-- -->    async_auto_reset_event&amp; operator=(async_auto_reset_event&amp;&amp;) = delete;
<!-- -->
<!-- -->    // Wait for the event to enter the &#x27;set&#x27; state.
<!-- -->    //
<!-- -->    // If the event is already &#x27;set&#x27; then the event is set to the &#x27;not set&#x27;
<!-- -->    // state and the awaiting coroutine continues without suspending.
<!-- -->    // Otherwise, the coroutine is suspended and later resumed when some
<!-- -->    // thread calls &#x27;set()&#x27;.
<!-- -->    //
<!-- -->    // Note that the coroutine may be resumed inside a call to &#x27;set()&#x27;
<!-- -->    // or inside another thread&#x27;s call to &#x27;operator co_await()&#x27;.
<!-- -->    async_auto_reset_event_operation operator co_await() const noexcept;
<!-- -->
<!-- -->    // Set the state of the event to &#x27;set&#x27;.
<!-- -->    //
<!-- -->    // If there are pending coroutines awaiting the event then one
<!-- -->    // pending coroutine is resumed and the state is immediately
<!-- -->    // set back to the &#x27;not set&#x27; state.
<!-- -->    //
<!-- -->    // This operation is a no-op if the event was already &#x27;set&#x27;.
<!-- -->    void set() noexcept;
<!-- -->
<!-- -->    // Set the state of the event to &#x27;not-set&#x27;.
<!-- -->    //
<!-- -->    // This is a no-op if the state was already &#x27;not set&#x27;.
<!-- -->    void reset() noexcept;
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class async_auto_reset_event_operation
<!-- -->  {
<!-- -->  public:
<!-- -->    explicit async_auto_reset_event_operation(async_auto_reset_event&amp; event) noexcept;
<!-- -->    async_auto_reset_event_operation(const async_auto_reset_event_operation&amp; other) noexcept;
<!-- -->
<!-- -->    bool await_ready() const noexcept;
<!-- -->    bool await_suspend(std::experimental::coroutine_handle&lt;&gt; awaiter) noexcept;
<!-- -->    void await_resume() const noexcept;
<!-- -->
<!-- -->  };
<!-- -->}
</code></pre><h2><code>async_latch</code></h2><p>An async latch is a synchronisation primitive that allows coroutines to asynchronously
wait until a counter has been decremented to zero.</p><p>The latch is a single-use object. Once the counter reaches zero the latch becomes &#x27;ready&#x27;
and will remain ready until the latch is destroyed.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/async_latch.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  class async_latch
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    // Initialise the latch with the specified count.
<!-- -->    async_latch(std::ptrdiff_t initialCount) noexcept;
<!-- -->
<!-- -->    // Query if the count has reached zero yet.
<!-- -->    bool is_ready() const noexcept;
<!-- -->
<!-- -->    // Decrement the count by n.
<!-- -->    // This will resume any waiting coroutines if the count reaches zero
<!-- -->    // as a result of this call.
<!-- -->    // It is undefined behaviour to decrement the count below zero.
<!-- -->    void count_down(std::ptrdiff_t n = 1) noexcept;
<!-- -->
<!-- -->    // Wait until the latch becomes ready.
<!-- -->    // If the latch count is not yet zero then the awaiting coroutine will
<!-- -->    // be suspended and later resumed by a call to count_down() that decrements
<!-- -->    // the count to zero. If the latch count was already zero then the coroutine
<!-- -->    // continues without suspending.
<!-- -->    Awaiter&lt;void&gt; operator co_await() const noexcept;
<!-- -->
<!-- -->  };
<!-- -->}
</code></pre><h2><code>cancellation_token</code></h2><p>A <code>cancellation_token</code> is a value that can be passed to a function that allows the caller to subsequently communicate a request to cancel the operation to that function.</p><p>To obtain a <code>cancellation_token</code> that is able to be cancelled you must first create a <code>cancellation_source</code> object.
The <code>cancellation_source::token()</code> method can be used to manufacture new <code>cancellation_token</code> values that are linked to that <code>cancellation_source</code> object.</p><p>When you want to later request cancellation of an operation you have passed a <code>cancellation_token</code> to
you can call <code>cancellation_source::request_cancellation()</code> on an associated <code>cancellation_source</code> object.</p><p>Functions can respond to a request for cancellation in one of two ways:</p><ol><li>Poll for cancellation at regular intervals by calling either <code>cancellation_token::is_cancellation_requested()</code> or <code>cancellation_token::throw_if_cancellation_requested()</code>.</li><li>Register a callback to be executed when cancellation is requested using the <code>cancellation_registration</code> class.</li></ol><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro
</span>{
<!-- -->  class cancellation_source
<!-- -->  {
<!-- -->  public:
<!-- -->    // Construct a new, independently cancellable cancellation source.
<!-- -->    cancellation_source();
<!-- -->
<!-- -->    // Construct a new reference to the same cancellation state.
<!-- -->    cancellation_source(const cancellation_source&amp; other) noexcept;
<!-- -->    cancellation_source(cancellation_source&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    ~cancellation_source();
<!-- -->
<!-- -->    cancellation_source&amp; operator=(const cancellation_source&amp; other) noexcept;
<!-- -->    cancellation_source&amp; operator=(cancellation_source&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    bool is_cancellation_requested() const noexcept;
<!-- -->    bool can_be_cancelled() const noexcept;
<!-- -->    void request_cancellation();
<!-- -->
<!-- -->    cancellation_token token() const noexcept;
<!-- -->  };
<!-- -->
<!-- -->  class cancellation_token
<!-- -->  {
<!-- -->  public:
<!-- -->    // Construct a token that can&#x27;t be cancelled.
<!-- -->    cancellation_token() noexcept;
<!-- -->
<!-- -->    cancellation_token(const cancellation_token&amp; other) noexcept;
<!-- -->    cancellation_token(cancellation_token&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    ~cancellation_token();
<!-- -->
<!-- -->    cancellation_token&amp; operator=(const cancellation_token&amp; other) noexcept;
<!-- -->    cancellation_token&amp; operator=(cancellation_token&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    bool is_cancellation_requested() const noexcept;
<!-- -->    void throw_if_cancellation_requested() const;
<!-- -->
<!-- -->    // Query if this token can ever have cancellation requested.
<!-- -->    // Code can use this to take a more efficient code-path in cases
<!-- -->    // that the operation does not need to handle cancellation.
<!-- -->    bool can_be_cancelled() const noexcept;
<!-- -->  };
<!-- -->
<!-- -->  // RAII class for registering a callback to be executed if cancellation
<!-- -->  // is requested on a particular cancellation token.
<!-- -->  class cancellation_registration
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    // Register a callback to be executed if cancellation is requested.
<!-- -->    // Callback will be called with no arguments on the thread that calls
<!-- -->    // request_cancellation() if cancellation is not yet requested, or
<!-- -->    // called immediately if cancellation has already been requested.
<!-- -->    // Callback must not throw an unhandled exception when called.
<!-- -->    template&lt;typename CALLBACK&gt;
<!-- -->    cancellation_registration(cancellation_token token, CALLBACK&amp;&amp; callback);
<!-- -->
<!-- -->    cancellation_registration(const cancellation_registration&amp; other) = delete;
<!-- -->
<!-- -->    ~cancellation_registration();
<!-- -->  };
<!-- -->
<!-- -->  class operation_cancelled : public std::exception
<!-- -->  {
<!-- -->  public:
<!-- -->    operation_cancelled();
<!-- -->    const char* what() const override;
<!-- -->  };
<!-- -->}
</code></pre><p>Example: Polling Approach</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cppcoro::task&lt;&gt; do_something_async(cppcoro::cancellation_token token)
</span>{
<!-- -->  // Explicitly define cancellation points within the function
<!-- -->  // by calling throw_if_cancellation_requested().
<!-- -->  token.throw_if_cancellation_requested();
<!-- -->
<!-- -->  co_await do_step_1();
<!-- -->
<!-- -->  token.throw_if_cancellation_requested();
<!-- -->
<!-- -->  do_step_2();
<!-- -->
<!-- -->  // Alternatively, you can query if cancellation has been
<!-- -->  // requested to allow yourself to do some cleanup before
<!-- -->  // returning.
<!-- -->  if (token.is_cancellation_requested())
<!-- -->  {
<!-- -->    display_message_to_user(&quot;Cancelling operation...&quot;);
<!-- -->    do_cleanup();
<!-- -->    throw cppcoro::operation_cancelled{};
<!-- -->  }
<!-- -->
<!-- -->  do_final_step();
<!-- -->}
</code></pre><p>Example: Callback Approach</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// Say we already have a timer abstraction that supports being
</span>// cancelled but it doesn&#x27;t support cancellation_tokens natively.
<!-- -->// You can use a cancellation_registration to register a callback
<!-- -->// that calls the existing cancellation API. e.g.
<!-- -->cppcoro::task&lt;&gt; cancellable_timer_wait(cppcoro::cancellation_token token)
<!-- -->{
<!-- -->  auto timer = create_timer(10s);
<!-- -->
<!-- -->  cppcoro::cancellation_registration registration(token, [&amp;]
<!-- -->  {
<!-- -->    // Call existing timer cancellation API.
<!-- -->    timer.cancel();
<!-- -->  });
<!-- -->
<!-- -->  co_await timer;
<!-- -->}
</code></pre><h2><code>static_thread_pool</code></h2><p>The <code>static_thread_pool</code> class provides an abstraction that lets you schedule work
on a fixed-size pool of threads.</p><p>This class implements the <strong>Scheduler</strong> concept (see below).</p><p>You can enqueue work to the thread-pool by executing <code>co_await threadPool.schedule()</code>.
This operation will suspend the current coroutine, enqueue it for execution on the
thread-pool and the thread pool will then resume the coroutine when a thread in the
thread-pool is next free to run the coroutine. <strong>This operation is guaranteed not
to throw and, in the common case, will not allocate any memory</strong>.</p><p>This class makes use of a work-stealing algorithm to load-balance work across multiple
threads. Work enqueued to the thread-pool from a thread-pool thread will be scheduled
for execution on the same thread in a LIFO queue. Work enqueued to the thread-pool from
a remote thread will be enqueued to a global FIFO queue. When a worker thread runs out
of work from its local queue it first tries to dequeue work from the global queue. If
that queue is empty then it next tries to steal work from the back of the queues of
the other worker threads.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro
</span>{
<!-- -->  class static_thread_pool
<!-- -->  {
<!-- -->  public:
<!-- -->    // Initialise the thread-pool with a number of threads equal to
<!-- -->    // std::thread::hardware_concurrency().
<!-- -->    static_thread_pool();
<!-- -->
<!-- -->    // Initialise the thread pool with the specified number of threads.
<!-- -->    explicit static_thread_pool(std::uint32_t threadCount);
<!-- -->
<!-- -->    std::uint32_t thread_count() const noexcept;
<!-- -->
<!-- -->    class schedule_operation
<!-- -->    {
<!-- -->    public:
<!-- -->      schedule_operation(static_thread_pool* tp) noexcept;
<!-- -->
<!-- -->      bool await_ready() noexcept;
<!-- -->      bool await_suspend(std::experimental::coroutine_handle&lt;&gt; h) noexcept;
<!-- -->      bool await_resume() noexcept;
<!-- -->
<!-- -->    private:
<!-- -->      // unspecified
<!-- -->    };
<!-- -->
<!-- -->    // Return an operation that can be awaited by a coroutine.
<!-- -->    //
<!-- -->    // 
<!-- -->    [[nodiscard]]
<!-- -->    schedule_operation schedule() noexcept;
<!-- -->
<!-- -->  private:
<!-- -->
<!-- -->    // Unspecified
<!-- -->
<!-- -->  };
<!-- -->}
</code></pre><p>Example usage: Simple</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cppcoro::task&lt;std::string&gt; do_something_on_threadpool(cppcoro::static_thread_pool&amp; tp)
</span>{
<!-- -->  // First schedule the coroutine onto the threadpool.
<!-- -->  co_await tp.schedule();
<!-- -->
<!-- -->  // When it resumes, this coroutine is now running on the threadpool.
<!-- -->  do_something();
<!-- -->}
</code></pre><p>Example usage: Doing things in parallel - using <code>schedule_on()</code> operator with <code>static_thread_pool</code>.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cppcoro::task&lt;double&gt; dot_product(static_thread_pool&amp; tp, double a[], double b[], size_t count)
</span>{
<!-- -->  if (count &gt; 1000)
<!-- -->  {
<!-- -->    // Subdivide the work recursively into two equal tasks
<!-- -->    // The first half is scheduled to the thread pool so it can run concurrently
<!-- -->    // with the second half which continues on this thread.
<!-- -->    size_t halfCount = count / 2;
<!-- -->    auto [first, second] = co_await when_all(
<!-- -->      schedule_on(tp, dot_product(tp, a, b, halfCount),
<!-- -->      dot_product(tp, a + halfCount, b + halfCount, count - halfCount));
<!-- -->    co_return first + second;
<!-- -->  }
<!-- -->  else
<!-- -->  {
<!-- -->    double sum = 0.0;
<!-- -->    for (size_t i = 0; i &lt; count; ++i)
<!-- -->    {
<!-- -->      sum += a[i] * b[i];
<!-- -->    }
<!-- -->    co_return sum;
<!-- -->  }
<!-- -->}
</code></pre><h2><code>io_service</code></h2><p>The <code>io_service</code> class provides an abstraction for processing I/O completion events
from asynchronous I/O operations.</p><p>When an asynchronous I/O operation completes, the coroutine that was awaiting
that operation will be resumed on an I/O thread inside a call to one of the
event-processing methods: <code>process_events()</code>, <code>process_pending_events()</code>,
<code>process_one_event()</code> or <code>process_one_pending_event()</code>.</p><p>The <code>io_service</code> class does not manage any I/O threads.
You must ensure that some thread calls one of the event-processing methods for coroutines awaiting I/O
completion events to be dispatched. This can either be a dedicated thread that calls <code>process_events()</code>
or mixed in with some other event loop (e.g. a UI event loop) by periodically polling for new events
via a call to <code>process_pending_events()</code> or <code>process_one_pending_event()</code>.</p><p>This allows integration of the <code>io_service</code> event-loop with other event loops, such as a user-interface event loop.</p><p>You can multiplex processing of events across multiple threads by having multiple threads call
<code>process_events()</code>. You can specify a hint as to the maximum number of threads to have actively
processing events via an optional <code>io_service</code> constructor parameter.</p><p>On Windows, the implementation makes use of the Windows I/O Completion Port facility to dispatch
events to I/O threads in a scalable manner.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro
</span>{
<!-- -->  class io_service
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    class schedule_operation;
<!-- -->    class timed_schedule_operation;
<!-- -->
<!-- -->    io_service();
<!-- -->    io_service(std::uint32_t concurrencyHint);
<!-- -->
<!-- -->    io_service(io_service&amp;&amp;) = delete;
<!-- -->    io_service(const io_service&amp;) = delete;
<!-- -->    io_service&amp; operator=(io_service&amp;&amp;) = delete;
<!-- -->    io_service&amp; operator=(const io_service&amp;) = delete;
<!-- -->
<!-- -->    ~io_service();
<!-- -->
<!-- -->    // Scheduler methods
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    schedule_operation schedule() noexcept;
<!-- -->
<!-- -->    template&lt;typename REP, typename RATIO&gt;
<!-- -->    [[nodiscard]]
<!-- -->    timed_schedule_operation schedule_after(
<!-- -->      std::chrono::duration&lt;REP, RATIO&gt; delay,
<!-- -->      cppcoro::cancellation_token cancellationToken = {}) noexcept;
<!-- -->
<!-- -->    // Event-loop methods
<!-- -->    //
<!-- -->    // I/O threads must call these to process I/O events and execute
<!-- -->    // scheduled coroutines.
<!-- -->
<!-- -->    std::uint64_t process_events();
<!-- -->    std::uint64_t process_pending_events();
<!-- -->    std::uint64_t process_one_event();
<!-- -->    std::uint64_t process_one_pending_event();
<!-- -->
<!-- -->    // Request that all threads processing events exit their event loops.
<!-- -->    void stop() noexcept;
<!-- -->
<!-- -->    // Query if some thread has called stop()
<!-- -->    bool is_stop_requested() const noexcept;
<!-- -->
<!-- -->    // Reset the event-loop after a call to stop() so that threads can
<!-- -->    // start processing events again.
<!-- -->    void reset();
<!-- -->
<!-- -->    // Reference-counting methods for tracking outstanding references
<!-- -->    // to the io_service.
<!-- -->    //
<!-- -->    // The io_service::stop() method will be called when the last work
<!-- -->    // reference is decremented.
<!-- -->    //
<!-- -->    // Use the io_work_scope RAII class to manage calling these methods on
<!-- -->    // entry-to and exit-from a scope.
<!-- -->    void notify_work_started() noexcept;
<!-- -->    void notify_work_finished() noexcept;
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class io_service::schedule_operation
<!-- -->  {
<!-- -->  public:
<!-- -->    schedule_operation(const schedule_operation&amp;) noexcept;
<!-- -->    schedule_operation&amp; operator=(const schedule_operation&amp;) noexcept;
<!-- -->
<!-- -->    bool await_ready() const noexcept;
<!-- -->    void await_suspend(std::experimental::coroutine_handle&lt;&gt; awaiter) noexcept;
<!-- -->    void await_resume() noexcept;
<!-- -->  };
<!-- -->
<!-- -->  class io_service::timed_schedule_operation
<!-- -->  {
<!-- -->  public:
<!-- -->    timed_schedule_operation(timed_schedule_operation&amp;&amp;) noexcept;
<!-- -->
<!-- -->    timed_schedule_operation(const timed_schedule_operation&amp;) = delete;
<!-- -->    timed_schedule_operation&amp; operator=(const timed_schedule_operation&amp;) = delete;
<!-- -->    timed_schedule_operation&amp; operator=(timed_schedule_operation&amp;&amp;) = delete;
<!-- -->
<!-- -->    bool await_ready() const noexcept;
<!-- -->    void await_suspend(std::experimental::coroutine_handle&lt;&gt; awaiter);
<!-- -->    void await_resume();
<!-- -->  };
<!-- -->
<!-- -->  class io_work_scope
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    io_work_scope(io_service&amp; ioService) noexcept;
<!-- -->
<!-- -->    io_work_scope(const io_work_scope&amp; other) noexcept;
<!-- -->    io_work_scope(io_work_scope&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    ~io_work_scope();
<!-- -->
<!-- -->    io_work_scope&amp; operator=(const io_work_scope&amp; other) noexcept;
<!-- -->    io_work_scope&amp; operator=(io_work_scope&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    io_service&amp; service() const noexcept;
<!-- -->  };
<!-- -->
<!-- -->}
</code></pre><p>Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#include &lt;cppcoro/task.hpp&gt;
</span>#include &lt;cppcoro/task.hpp&gt;
<!-- -->#include &lt;cppcoro/io_service.hpp&gt;
<!-- -->#include &lt;cppcoro/read_only_file.hpp&gt;
<!-- -->
<!-- -->#include &lt;experimental/filesystem&gt;
<!-- -->#include &lt;memory&gt;
<!-- -->#include &lt;algorithm&gt;
<!-- -->#include &lt;iostream&gt;
<!-- -->
<!-- -->namespace fs = std::experimental::filesystem;
<!-- -->
<!-- -->cppcoro::task&lt;std::uint64_t&gt; count_lines(cppcoro::io_service&amp; ioService, fs::path path)
<!-- -->{
<!-- -->  auto file = cppcoro::read_only_file::open(ioService, path);
<!-- -->
<!-- -->  constexpr size_t bufferSize = 4096;
<!-- -->  auto buffer = std::make_unique&lt;std::uint8_t[]&gt;(bufferSize);
<!-- -->
<!-- -->  std::uint64_t newlineCount = 0;
<!-- -->
<!-- -->  for (std::uint64_t offset = 0, fileSize = file.size(); offset &lt; fileSize;)
<!-- -->  {
<!-- -->    const auto bytesToRead = static_cast&lt;size_t&gt;(
<!-- -->      std::min&lt;std::uint64_t&gt;(bufferSize, fileSize - offset));
<!-- -->
<!-- -->    const auto bytesRead = co_await file.read(offset, buffer.get(), bytesToRead);
<!-- -->
<!-- -->    newlineCount += std::count(buffer.get(), buffer.get() + bytesRead, &#x27;\n&#x27;);
<!-- -->
<!-- -->    offset += bytesRead;
<!-- -->  }
<!-- -->
<!-- -->  co_return newlineCount;
<!-- -->}
<!-- -->
<!-- -->cppcoro::task&lt;&gt; run(cppcoro::io_service&amp; ioService)
<!-- -->{
<!-- -->  cppcoro::io_work_scope ioScope(ioService);
<!-- -->
<!-- -->  auto lineCount = co_await count_lines(ioService, fs::path{&quot;foo.txt&quot;});
<!-- -->
<!-- -->  std::cout &lt;&lt; &quot;foo.txt has &quot; &lt;&lt; lineCount &lt;&lt; &quot; lines.&quot; &lt;&lt; std::endl;;
<!-- -->}
<!-- -->
<!-- -->cppcoro::task&lt;&gt; process_events(cppcoro::io_service&amp; ioService)
<!-- -->{
<!-- -->  // Process events until the io_service is stopped.
<!-- -->  // ie. when the last io_work_scope goes out of scope.
<!-- -->  ioService.process_events();
<!-- -->  co_return;
<!-- -->}
<!-- -->
<!-- -->int main()
<!-- -->{
<!-- -->  cppcoro::io_service ioService;
<!-- -->
<!-- -->  cppcoro::sync_wait(cppcoro::when_all_ready(
<!-- -->    run(ioService),
<!-- -->    process_events(ioService)));
<!-- -->
<!-- -->  return 0;
<!-- -->}
</code></pre><h3><code>io_service</code> as a scheduler</h3><p>An <code>io_sevice</code> class implements the interfaces for the <code>Scheduler</code> and <code>DelayedScheduler</code> concepts.</p><p>This allows a coroutine to suspend execution on the current thread and schedule itself for resumption
on an I/O thread associated with a particular <code>io_service</code> object.</p><p>Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cppcoro::task&lt;&gt; do_something(cppcoro::io_service&amp; ioService)
</span>{
<!-- -->  // Coroutine starts execution on the thread of the task awaiter.
<!-- -->
<!-- -->  // A coroutine can transfer execution to an I/O thread by awaiting the
<!-- -->  // result of io_service::schedule().
<!-- -->  co_await ioService.schedule();
<!-- -->
<!-- -->  // At this point, the coroutine is now executing on an I/O thread
<!-- -->  // inside a call to one of the io_service event processing methods.
<!-- -->
<!-- -->  // A coroutine can also perform a delayed-schedule that will suspend
<!-- -->  // the coroutine for a specified duration of time before scheduling
<!-- -->  // it for resumption on an I/O thread.
<!-- -->  co_await ioService.schedule_after(100ms);
<!-- -->
<!-- -->  // At this point, the coroutine is executing on a potentially different I/O thread.
<!-- -->}
</code></pre><h2><code>file</code>, <code>readable_file</code>, <code>writable_file</code></h2><p>These types are abstract base-classes for performing concrete file I/O.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro
</span>{
<!-- -->  class file_read_operation;
<!-- -->  class file_write_operation;
<!-- -->
<!-- -->  class file
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    virtual ~file();
<!-- -->
<!-- -->    std::uint64_t size() const;
<!-- -->
<!-- -->  protected:
<!-- -->
<!-- -->    file(file&amp;&amp; other) noexcept;
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class readable_file : public virtual file
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    file_read_operation read(
<!-- -->      std::uint64_t offset,
<!-- -->      void* buffer,
<!-- -->      std::size_t byteCount,
<!-- -->      cancellation_token ct = {}) const noexcept;
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class writable_file : public virtual file
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    void set_size(std::uint64_t fileSize);
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    file_write_operation write(
<!-- -->      std::uint64_t offset,
<!-- -->      const void* buffer,
<!-- -->      std::size_t byteCount,
<!-- -->      cancellation_token ct = {}) noexcept;
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class file_read_operation
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    file_read_operation(file_read_operation&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    bool await_ready() const noexcept;
<!-- -->    bool await_suspend(std::experimental::coroutine_handle&lt;&gt; awaiter);
<!-- -->    std::size_t await_resume();
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class file_write_operation
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    file_write_operation(file_write_operation&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    bool await_ready() const noexcept;
<!-- -->    bool await_suspend(std::experimental::coroutine_handle&lt;&gt; awaiter);
<!-- -->    std::size_t await_resume();
<!-- -->
<!-- -->  };
<!-- -->}
</code></pre><h2><code>read_only_file</code>, <code>write_only_file</code>, <code>read_write_file</code></h2><p>These types represent concrete file I/O classes.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro
</span>{
<!-- -->  class read_only_file : public readable_file
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    static read_only_file open(
<!-- -->      io_service&amp; ioService,
<!-- -->      const std::experimental::filesystem::path&amp; path,
<!-- -->      file_share_mode shareMode = file_share_mode::read,
<!-- -->      file_buffering_mode bufferingMode = file_buffering_mode::default_);
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class write_only_file : public writable_file
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    static write_only_file open(
<!-- -->      io_service&amp; ioService,
<!-- -->      const std::experimental::filesystem::path&amp; path,
<!-- -->      file_open_mode openMode = file_open_mode::create_or_open,
<!-- -->      file_share_mode shareMode = file_share_mode::none,
<!-- -->      file_buffering_mode bufferingMode = file_buffering_mode::default_);
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class read_write_file : public readable_file, public writable_file
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    static read_write_file open(
<!-- -->      io_service&amp; ioService,
<!-- -->      const std::experimental::filesystem::path&amp; path,
<!-- -->      file_open_mode openMode = file_open_mode::create_or_open,
<!-- -->      file_share_mode shareMode = file_share_mode::none,
<!-- -->      file_buffering_mode bufferingMode = file_buffering_mode::default_);
<!-- -->
<!-- -->  };
<!-- -->}
</code></pre><p>All <code>open()</code> functions throw <code>std::system_error</code> on failure.</p><h1>Networking</h1><p>NOTE: Networking abstractions are currently only supported on the Windows platform.
Linux support will be coming soon.</p><h2><code>socket</code></h2><p>The socket class can be used to send/receive data over the network asynchronously.</p><p>Currently only supports TCP/IP, UDP/IP over IPv4 and IPv6.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/net/socket.hpp&gt;
</span>namespace cppcoro::net
<!-- -->{
<!-- -->  class socket
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    static socket create_tcpv4(ip_service&amp; ioSvc);
<!-- -->    static socket create_tcpv6(ip_service&amp; ioSvc);
<!-- -->    static socket create_updv4(ip_service&amp; ioSvc);
<!-- -->    static socket create_udpv6(ip_service&amp; ioSvc);
<!-- -->
<!-- -->    socket(socket&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    ~socket();
<!-- -->
<!-- -->    socket&amp; operator=(socket&amp;&amp; other) noexcept;
<!-- -->
<!-- -->    // Return the native socket handle for the socket
<!-- -->    &lt;platform-specific&gt; native_handle() noexcept;
<!-- -->
<!-- -->    const ip_endpoint&amp; local_endpoint() const noexcept;
<!-- -->    const ip_endpoint&amp; remote_endpoint() const noexcept;
<!-- -->
<!-- -->    void bind(const ip_endpoint&amp; localEndPoint);
<!-- -->
<!-- -->    void listen();
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;void&gt; connect(const ip_endpoint&amp; remoteEndPoint) noexcept;
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;void&gt; connect(const ip_endpoint&amp; remoteEndPoint,
<!-- -->                            cancellation_token ct) noexcept;
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;void&gt; accept(socket&amp; acceptingSocket) noexcept;
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;void&gt; accept(socket&amp; acceptingSocket,
<!-- -->                           cancellation_token ct) noexcept;
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;void&gt; disconnect() noexcept;
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;void&gt; disconnect(cancellation_token ct) noexcept;
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;std::size_t&gt; send(const void* buffer, std::size_t size) noexcept;
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;std::size_t&gt; send(const void* buffer,
<!-- -->                                std::size_t size,
<!-- -->                                cancellation_token ct) noexcept;
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;std::size_t&gt; recv(void* buffer, std::size_t size) noexcept;
<!-- -->    [[nodiscard]]
<!-- -->    Awaitable&lt;std::size_t&gt; recv(void* buffer,
<!-- -->                                std::size_t size,
<!-- -->                                cancellation_token ct) noexcept;
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    socket_recv_from_operation recv_from(
<!-- -->        void* buffer,
<!-- -->        std::size_t size) noexcept;
<!-- -->    [[nodiscard]]
<!-- -->    socket_recv_from_operation_cancellable recv_from(
<!-- -->        void* buffer,
<!-- -->        std::size_t size,
<!-- -->        cancellation_token ct) noexcept;
<!-- -->
<!-- -->    [[nodiscard]]
<!-- -->    socket_send_to_operation send_to(
<!-- -->        const ip_endpoint&amp; destination,
<!-- -->        const void* buffer,
<!-- -->        std::size_t size) noexcept;
<!-- -->    [[nodiscard]]
<!-- -->    socket_send_to_operation_cancellable send_to(
<!-- -->        const ip_endpoint&amp; destination,
<!-- -->        const void* buffer,
<!-- -->        std::size_t size,
<!-- -->        cancellation_token ct) noexcept;
<!-- -->
<!-- -->    void close_send();
<!-- -->    void close_recv();
<!-- -->
<!-- -->  };
<!-- -->}
</code></pre><p>Example: Echo Server</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#include &lt;cppcoro/net/socket.hpp&gt;
</span>#include &lt;cppcoro/io_service.hpp&gt;
<!-- -->#include &lt;cppcoro/cancellation_source.hpp&gt;
<!-- -->#include &lt;cppcoro/async_scope.hpp&gt;
<!-- -->#include &lt;cppcoro/on_scope_exit.hpp&gt;
<!-- -->
<!-- -->#include &lt;memory&gt;
<!-- -->#include &lt;iostream&gt;
<!-- -->
<!-- -->cppcoro::task&lt;void&gt; handle_connection(socket s)
<!-- -->{
<!-- -->  try
<!-- -->  {
<!-- -->    const size_t bufferSize = 16384;
<!-- -->    auto buffer = std::make_unique&lt;unsigned char[]&gt;(bufferSize);
<!-- -->    size_t bytesRead;
<!-- -->    do {
<!-- -->      // Read some bytes
<!-- -->      bytesRead = co_await s.recv(buffer.get(), bufferSize);
<!-- -->
<!-- -->      // Write some bytes
<!-- -->      size_t bytesWritten = 0;
<!-- -->      while (bytesWritten &lt; bytesRead) {
<!-- -->        bytesWritten += co_await s.send(
<!-- -->          buffer.get() + bytesWritten,
<!-- -->          bytesRead - bytesWritten);
<!-- -->      }
<!-- -->    } while (bytesRead != 0);
<!-- -->
<!-- -->    s.close_send();
<!-- -->
<!-- -->    co_await s.disconnect();
<!-- -->  }
<!-- -->  catch (...)
<!-- -->  {
<!-- -->    std::cout &lt;&lt; &quot;connection failed&quot; &lt;&lt; std::
<!-- -->  }
<!-- -->}
<!-- -->
<!-- -->cppcoro::task&lt;void&gt; echo_server(
<!-- -->  cppcoro::net::ipv4_endpoint endpoint,
<!-- -->  cppcoro::io_service&amp; ioSvc,
<!-- -->  cancellation_token ct)
<!-- -->{
<!-- -->  cppcoro::async_scope scope;
<!-- -->
<!-- -->  std::exception_ptr ex;
<!-- -->  try
<!-- -->  {
<!-- -->    auto listeningSocket = cppcoro::net::socket::create_tcpv4(ioSvc);
<!-- -->    listeningSocket.bind(endpoint);
<!-- -->    listeningSocket.listen();
<!-- -->
<!-- -->    while (true) {
<!-- -->      auto connection = cppcoro::net::socket::create_tcpv4(ioSvc);
<!-- -->      co_await listeningSocket.accept(connection, ct);
<!-- -->      scope.spawn(handle_connection(std::move(connection)));
<!-- -->    }
<!-- -->  }
<!-- -->  catch (cppcoro::operation_cancelled)
<!-- -->  {
<!-- -->  }
<!-- -->  catch (...)
<!-- -->  {
<!-- -->    ex = std::current_exception();
<!-- -->  }
<!-- -->
<!-- -->  // Wait until all handle_connection tasks have finished.
<!-- -->  co_await scope.join();
<!-- -->
<!-- -->  if (ex) std::rethrow_exception(ex);
<!-- -->}
<!-- -->
<!-- -->int main(int argc, const char* argv[])
<!-- -->{
<!-- -->    cppcoro::io_service ioSvc;
<!-- -->
<!-- -->    if (argc != 2) return -1;
<!-- -->
<!-- -->    auto endpoint = cppcoro::ipv4_endpoint::from_string(argv[1]);
<!-- -->    if (!endpoint) return -1;
<!-- -->
<!-- -->    (void)cppcoro::sync_wait(cppcoro::when_all(
<!-- -->        [&amp;]() -&gt; task&lt;&gt;
<!-- -->        {
<!-- -->            // Shutdown the event loop once finished.
<!-- -->            auto stopOnExit = cppcoro::on_scope_exit([&amp;] { ioSvc.stop(); });
<!-- -->
<!-- -->            cppcoro::cancellation_source canceller;
<!-- -->            co_await cppcoro::when_all(
<!-- -->                [&amp;]() -&gt; task&lt;&gt;
<!-- -->                {
<!-- -->                    // Run for 30s then stop accepting new connections.
<!-- -->                    co_await ioSvc.schedule_after(std::chrono::seconds(30));
<!-- -->                    canceller.request_cancellation();
<!-- -->                }(),
<!-- -->                echo_server(*endpoint, ioSvc, canceller.token()));
<!-- -->        }(),
<!-- -->        [&amp;]() -&gt; task&lt;&gt;
<!-- -->        {
<!-- -->            ioSvc.process_events();
<!-- -->        }()));
<!-- -->
<!-- -->    return 0;
<!-- -->}
</code></pre><h2><code>ip_address</code>, <code>ipv4_address</code>, <code>ipv6_address</code></h2><p>Helper classes for representing an IP address.</p><p>API Synopsis:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro::net
</span>{
<!-- -->  class ipv4_address
<!-- -->  {
<!-- -->    using bytes_t = std::uint8_t[4];
<!-- -->  public:
<!-- -->    constexpr ipv4_address();
<!-- -->    explicit constexpr ipv4_address(std::uint32_t integer);
<!-- -->    explicit constexpr ipv4_address(const std::uint8_t(&amp;bytes)[4]);
<!-- -->    explicit constexpr ipv4_address(std::uint8_t b0,
<!-- -->                                    std::uint8_t b1,
<!-- -->                                    std::uint8_t b2,
<!-- -->                                    std::uint8_t b3);
<!-- -->
<!-- -->    constexpr const bytes_t&amp; bytes() const;
<!-- -->
<!-- -->    cosntexpr std::uint32_t to_integer() const;
<!-- -->
<!-- -->    static constexpr ipv4_address loopback();
<!-- -->
<!-- -->    constexpr bool is_loopback() const;
<!-- -->    constexpr bool is_private_network() const;
<!-- -->
<!-- -->    constexpr bool operator==(ipv4_address other) const;
<!-- -->    constexpr bool operator!=(ipv4_address other) const;
<!-- -->    constexpr bool operator&lt;(ipv4_address other) const;
<!-- -->    constexpr bool operator&gt;(ipv4_address other) const;
<!-- -->    constexpr bool operator&lt;=(ipv4_address other) const;
<!-- -->    constexpr bool operator&gt;=(ipv4_address other) const;
<!-- -->
<!-- -->    std::string to_string();
<!-- -->
<!-- -->    static std::optional&lt;ipv4_address&gt; from_string(std::string_view string) noexcept;
<!-- -->  };
<!-- -->
<!-- -->  class ipv6_address
<!-- -->  {
<!-- -->    using bytes_t = std::uint8_t[16];
<!-- -->  public:
<!-- -->    constexpr ipv6_address();
<!-- -->
<!-- -->    explicit constexpr ipv6_address(
<!-- -->      std::uint64_t subnetPrefix,
<!-- -->      std::uint64_t interfaceIdentifier);
<!-- -->
<!-- -->    constexpr ipv6_address(
<!-- -->      std::uint16_t part0,
<!-- -->      std::uint16_t part1,
<!-- -->      std::uint16_t part2,
<!-- -->      std::uint16_t part3,
<!-- -->      std::uint16_t part4,
<!-- -->      std::uint16_t part5,
<!-- -->      std::uint16_t part6,
<!-- -->      std::uint16_t part7);
<!-- -->
<!-- -->    explicit constexpr ipv6_address(
<!-- -->        const std::uint16_t(&amp;parts)[8]);
<!-- -->
<!-- -->    explicit constexpr ipv6_address(
<!-- -->        const std::uint8_t(bytes)[16]);
<!-- -->
<!-- -->    constexpr const bytes_t&amp; bytes() const;
<!-- -->
<!-- -->    constexpr std::uint64_t subnet_prefix() const;
<!-- -->    constexpr std::uint64_t interface_identifier() const;
<!-- -->
<!-- -->    static constexpr ipv6_address unspecified();
<!-- -->    static constexpr ipv6_address loopback();
<!-- -->
<!-- -->    static std::optional&lt;ipv6_address&gt; from_string(std::string_view string) noexcept;
<!-- -->
<!-- -->    std::string to_string() const;
<!-- -->
<!-- -->    constexpr bool operator==(const ipv6_address&amp; other) const;
<!-- -->    constexpr bool operator!=(const ipv6_address&amp; other) const;
<!-- -->    constexpr bool operator&lt;(const ipv6_address&amp; other) const;
<!-- -->    constexpr bool operator&gt;(const ipv6_address&amp; other) const;
<!-- -->    constexpr bool operator&lt;=(const ipv6_address&amp; other) const;
<!-- -->    constexpr bool operator&gt;=(const ipv6_address&amp; other) const;
<!-- -->
<!-- -->  };
<!-- -->
<!-- -->  class ip_address
<!-- -->  {
<!-- -->  public:
<!-- -->
<!-- -->    // Constructs to IPv4 address 0.0.0.0
<!-- -->    ip_address() noexcept;
<!-- -->
<!-- -->    ip_address(ipv4_address address) noexcept;
<!-- -->    ip_address(ipv6_address address) noexcept;
<!-- -->
<!-- -->    bool is_ipv4() const noexcept;
<!-- -->    bool is_ipv6() const noexcept;
<!-- -->
<!-- -->    const ipv4_address&amp; to_ipv4() const;
<!-- -->    const ipv6_address&amp; to_ipv6() const;
<!-- -->
<!-- -->    const std::uint8_t* bytes() const noexcept;
<!-- -->
<!-- -->    std::string to_string() const;
<!-- -->
<!-- -->    static std::optional&lt;ip_address&gt; from_string(std::string_view string) noexcept;
<!-- -->
<!-- -->    bool operator==(const ip_address&amp; rhs) const noexcept;
<!-- -->    bool operator!=(const ip_address&amp; rhs) const noexcept;
<!-- -->
<!-- -->    //  ipv4_address sorts less than ipv6_address
<!-- -->    bool operator&lt;(const ip_address&amp; rhs) const noexcept;
<!-- -->    bool operator&gt;(const ip_address&amp; rhs) const noexcept;
<!-- -->    bool operator&lt;=(const ip_address&amp; rhs) const noexcept;
<!-- -->    bool operator&gt;=(const ip_address&amp; rhs) const noexcept;
<!-- -->
<!-- -->  };
<!-- -->}
</code></pre><h2><code>ip_endpoint</code>, <code>ipv4_endpoint</code> <code>ipv6_endpoint</code></h2><p>Helper classes for representing an IP address and port-number.</p><p>API Synopsis:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>namespace cppcoro::net
</span>{
<!-- -->  class ipv4_endpoint
<!-- -->  {
<!-- -->  public:
<!-- -->    ipv4_endpoint() noexcept;
<!-- -->    explicit ipv4_endpoint(ipv4_address address, std::uint16_t port = 0) noexcept;
<!-- -->
<!-- -->    const ipv4_address&amp; address() const noexcept;
<!-- -->    std::uint16_t port() const noexcept;
<!-- -->
<!-- -->    std::string to_string() const;
<!-- -->    static std::optional&lt;ipv4_endpoint&gt; from_string(std::string_view string) noexcept;
<!-- -->  };
<!-- -->
<!-- -->  bool operator==(const ipv4_endpoint&amp; a, const ipv4_endpoint&amp; b);
<!-- -->  bool operator!=(const ipv4_endpoint&amp; a, const ipv4_endpoint&amp; b);
<!-- -->  bool operator&lt;(const ipv4_endpoint&amp; a, const ipv4_endpoint&amp; b);
<!-- -->  bool operator&gt;(const ipv4_endpoint&amp; a, const ipv4_endpoint&amp; b);
<!-- -->  bool operator&lt;=(const ipv4_endpoint&amp; a, const ipv4_endpoint&amp; b);
<!-- -->  bool operator&gt;=(const ipv4_endpoint&amp; a, const ipv4_endpoint&amp; b);
<!-- -->
<!-- -->  class ipv6_endpoint
<!-- -->  {
<!-- -->  public:
<!-- -->    ipv6_endpoint() noexcept;
<!-- -->    explicit ipv6_endpoint(ipv6_address address, std::uint16_t port = 0) noexcept;
<!-- -->
<!-- -->    const ipv6_address&amp; address() const noexcept;
<!-- -->    std::uint16_t port() const noexcept;
<!-- -->
<!-- -->    std::string to_string() const;
<!-- -->    static std::optional&lt;ipv6_endpoint&gt; from_string(std::string_view string) noexcept;
<!-- -->  };
<!-- -->
<!-- -->  bool operator==(const ipv6_endpoint&amp; a, const ipv6_endpoint&amp; b);
<!-- -->  bool operator!=(const ipv6_endpoint&amp; a, const ipv6_endpoint&amp; b);
<!-- -->  bool operator&lt;(const ipv6_endpoint&amp; a, const ipv6_endpoint&amp; b);
<!-- -->  bool operator&gt;(const ipv6_endpoint&amp; a, const ipv6_endpoint&amp; b);
<!-- -->  bool operator&lt;=(const ipv6_endpoint&amp; a, const ipv6_endpoint&amp; b);
<!-- -->  bool operator&gt;=(const ipv6_endpoint&amp; a, const ipv6_endpoint&amp; b);
<!-- -->
<!-- -->  class ip_endpoint
<!-- -->  {
<!-- -->  public:
<!-- -->     // Constructs to IPv4 end-point 0.0.0.0:0
<!-- -->     ip_endpoint() noexcept;
<!-- -->
<!-- -->     ip_endpoint(ipv4_endpoint endpoint) noexcept;
<!-- -->     ip_endpoint(ipv6_endpoint endpoint) noexcept;
<!-- -->
<!-- -->     bool is_ipv4() const noexcept;
<!-- -->     bool is_ipv6() const noexcept;
<!-- -->
<!-- -->     const ipv4_endpoint&amp; to_ipv4() const;
<!-- -->     const ipv6_endpoint&amp; to_ipv6() const;
<!-- -->
<!-- -->     ip_address address() const noexcept;
<!-- -->     std::uint16_t port() const noexcept;
<!-- -->
<!-- -->     std::string to_string() const;
<!-- -->
<!-- -->     static std::optional&lt;ip_endpoint&gt; from_string(std::string_view string) noexcept;
<!-- -->
<!-- -->     bool operator==(const ip_endpoint&amp; rhs) const noexcept;
<!-- -->     bool operator!=(const ip_endpoint&amp; rhs) const noexcept;
<!-- -->
<!-- -->     //  ipv4_endpoint sorts less than ipv6_endpoint
<!-- -->     bool operator&lt;(const ip_endpoint&amp; rhs) const noexcept;
<!-- -->     bool operator&gt;(const ip_endpoint&amp; rhs) const noexcept;
<!-- -->     bool operator&lt;=(const ip_endpoint&amp; rhs) const noexcept;
<!-- -->     bool operator&gt;=(const ip_endpoint&amp; rhs) const noexcept;
<!-- -->  };
<!-- -->}
</code></pre><h1>Functions</h1><h2><code>sync_wait()</code></h2><p>The <code>sync_wait()</code>function can be used to synchronously wait until the specified <code>awaitable</code>
completes.</p><p>The specified awaitable will be <code>co_await</code>ed on current thread inside a newly created coroutine.</p><p>The <code>sync_wait()</code> call will block until the operation completes and will return the result of
the <code>co_await</code> expression or rethrow the exception if the <code>co_await</code> expression completed with
an unhandled exception.</p><p>The <code>sync_wait()</code> function is mostly useful for starting a top-level task from within <code>main()</code>
and waiting until the task finishes, in practise it is the only way to start the first/top-level
<code>task</code>.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/sync_wait.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  template&lt;typename AWAITABLE&gt;
<!-- -->  auto sync_wait(AWAITABLE&amp;&amp; awaitable)
<!-- -->    -&gt; typename awaitable_traits&lt;AWAITABLE&amp;&amp;&gt;::await_result_t;
<!-- -->}
</code></pre><p>Examples:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>void example_task()
</span>{
<!-- -->  auto makeTask = []() -&gt; task&lt;std::string&gt;
<!-- -->  {
<!-- -->    co_return &quot;foo&quot;;
<!-- -->  };
<!-- -->
<!-- -->  auto task = makeTask();
<!-- -->
<!-- -->  // start the lazy task and wait until it completes
<!-- -->  sync_wait(task); // -&gt; &quot;foo&quot;
<!-- -->  sync_wait(makeTask()); // -&gt; &quot;foo&quot;
<!-- -->}
<!-- -->
<!-- -->void example_shared_task()
<!-- -->{
<!-- -->  auto makeTask = []() -&gt; shared_task&lt;std::string&gt;
<!-- -->  {
<!-- -->    co_return &quot;foo&quot;;
<!-- -->  };
<!-- -->
<!-- -->  auto task = makeTask();
<!-- -->  // start the shared task and wait until it completes
<!-- -->  sync_wait(task) == &quot;foo&quot;;
<!-- -->  sync_wait(makeTask()) == &quot;foo&quot;;
<!-- -->}
</code></pre><h2><code>when_all_ready()</code></h2><p>The <code>when_all_ready()</code> function can be used to create a new awaitable that completes when
all of the input awaitables complete.</p><p>Input tasks can be any type of awaitable.</p><p>When the returned awaitable is <code>co_await</code>ed it will <code>co_await</code> each of the input awaitables
in turn on the awaiting thread in the order they are passed to the <code>when_all_ready()</code>
function. If these tasks to not complete synchronously then they will execute concurrently.</p><p>Once all of the <code>co_await</code> expressions on input awaitables have run to completion the
returned awaitable will complete and resume the awaiting coroutine. The awaiting coroutine
will be resumed on the thread of the input awaitable that is last to complete.</p><p>The returned awaitable is guaranteed not to throw an exception when <code>co_await</code>ed,
even if some of the input awaitables fail with an unhandled exception.</p><p>Note, however, that the <code>when_all_ready()</code> call itself may throw <code>std::bad_alloc</code> if it
was unable to allocate memory for the coroutine frames required to await each of the
input awaitables. It may also throw an exception if any of the input awaitable objects
throw from their copy/move constructors.</p><p>The result of <code>co_await</code>ing the returned awaitable is a <code>std::tuple</code> or <code>std::vector</code>
of <code>when_all_task&lt;RESULT&gt;</code> objects. These objects allow you to obtain the result (or exception)
of each input awaitable separately by calling the <code>when_all_task&lt;RESULT&gt;::result()</code>
method of the corresponding output task.
This allows the caller to concurrently await multiple awaitables and synchronise on
their completion while still retaining the ability to subsequently inspect the results of
each of the <code>co_await</code> operations for success/failure.</p><p>This differs from <code>when_all()</code> where the failure of any individual <code>co_await</code> operation
causes the overall operation to fail with an exception. This means you cannot determine
which of the component <code>co_await</code> operations failed and also prevents you from obtaining
the results of the other <code>co_await</code> operations.</p><p>API summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/when_all_ready.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  // Concurrently await multiple awaitables.
<!-- -->  //
<!-- -->  // Returns an awaitable object that, when co_await&#x27;ed, will co_await each of the input
<!-- -->  // awaitable objects and will resume the awaiting coroutine only when all of the
<!-- -->  // component co_await operations complete.
<!-- -->  //
<!-- -->  // Result of co_await&#x27;ing the returned awaitable is a std::tuple of detail::when_all_task&lt;T&gt;,
<!-- -->  // one for each input awaitable and where T is the result-type of the co_await expression
<!-- -->  // on the corresponding awaitable.
<!-- -->  //
<!-- -->  // AWAITABLES must be awaitable types and must be movable (if passed as rvalue) or copyable
<!-- -->  // (if passed as lvalue). The co_await expression will be executed on an rvalue of the
<!-- -->  // copied awaitable.
<!-- -->  template&lt;typename... AWAITABLES&gt;
<!-- -->  auto when_all_ready(AWAITABLES&amp;&amp;... awaitables)
<!-- -->    -&gt; Awaitable&lt;std::tuple&lt;detail::when_all_task&lt;typename awaitable_traits&lt;AWAITABLES&gt;::await_result_t&gt;...&gt;&gt;;
<!-- -->
<!-- -->  // Concurrently await each awaitable in a vector of input awaitables.
<!-- -->  template&lt;
<!-- -->    typename AWAITABLE,
<!-- -->    typename RESULT = typename awaitable_traits&lt;AWAITABLE&gt;::await_result_t&gt;
<!-- -->  auto when_all_ready(std::vector&lt;AWAITABLE&gt; awaitables)
<!-- -->    -&gt; Awaitable&lt;std::vector&lt;detail::when_all_task&lt;RESULT&gt;&gt;&gt;;
<!-- -->}
</code></pre><p>Example usage:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>task&lt;std::string&gt; get_record(int id);
</span>
<!-- -->task&lt;&gt; example1()
<!-- -->{
<!-- -->  // Run 3 get_record() operations concurrently and wait until they&#x27;re all ready.
<!-- -->  // Returns a std::tuple of tasks that can be unpacked using structured bindings.
<!-- -->  auto [task1, task2, task3] = co_await when_all_ready(
<!-- -->    get_record(123),
<!-- -->    get_record(456),
<!-- -->    get_record(789));
<!-- -->
<!-- -->  // Unpack the result of each task
<!-- -->  std::string&amp; record1 = task1.result();
<!-- -->  std::string&amp; record2 = task2.result();
<!-- -->  std::string&amp; record3 = task3.result();
<!-- -->
<!-- -->  // Use records....
<!-- -->}
<!-- -->
<!-- -->task&lt;&gt; example2()
<!-- -->{
<!-- -->  // Create the input tasks. They don&#x27;t start executing yet.
<!-- -->  std::vector&lt;task&lt;std::string&gt;&gt; tasks;
<!-- -->  for (int i = 0; i &lt; 1000; ++i)
<!-- -->  {
<!-- -->    tasks.emplace_back(get_record(i));
<!-- -->  }
<!-- -->
<!-- -->  // Execute all tasks concurrently.
<!-- -->  std::vector&lt;detail::when_all_task&lt;std::string&gt;&gt; resultTasks =
<!-- -->    co_await when_all_ready(std::move(tasks));
<!-- -->
<!-- -->  // Unpack and handle each result individually once they&#x27;re all complete.
<!-- -->  for (int i = 0; i &lt; 1000; ++i)
<!-- -->  {
<!-- -->    try
<!-- -->    {
<!-- -->      std::string&amp; record = tasks[i].result();
<!-- -->      std::cout &lt;&lt; i &lt;&lt; &quot; = &quot; &lt;&lt; record &lt;&lt; std::endl;
<!-- -->    }
<!-- -->    catch (const std::exception&amp; ex)
<!-- -->    {
<!-- -->      std::cout &lt;&lt; i &lt;&lt; &quot; : &quot; &lt;&lt; ex.what() &lt;&lt; std::endl;
<!-- -->    }
<!-- -->  }
<!-- -->}
</code></pre><h2><code>when_all()</code></h2><p>The <code>when_all()</code> function can be used to create a new Awaitable that when <code>co_await</code>ed
will <code>co_await</code> each of the input awaitables concurrently and return an aggregate of
their individual results.</p><p>When the returned awaitable is awaited, it will <code>co_await</code> each of the input awaitables
on the current thread. Once the first awaitable suspends, the second task will be started,
and so on. The operations execute concurrently until they have all run to completion.</p><p>Once all component <code>co_await</code> operations have run to completion, an aggregate of the
results is constructed from each individual result. If an exception is thrown by any
of the input tasks or if the construction of the aggregate result throws an exception
then the exception will propagate out of the <code>co_await</code> of the returned awaitable.</p><p>If multiple <code>co_await</code> operations fail with an exception then one of the exceptions
will propagate out of the <code>co_await when_all()</code> expression the other exceptions will be silently
ignored. It is not specified which operation&#x27;s exception will be chosen.</p><p>If it is important to know which component <code>co_await</code> operation failed or to retain
the ability to obtain results of other operations even if some of them fail then you
you should use <code>when_all_ready()</code> instead.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/when_all.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  // Variadic version.
<!-- -->  //
<!-- -->  // Note that if the result of `co_await awaitable` yields a void-type
<!-- -->  // for some awaitables then the corresponding component for that awaitable
<!-- -->  // in the tuple will be an empty struct of type detail::void_value.
<!-- -->  template&lt;typename... AWAITABLES&gt;
<!-- -->  auto when_all(AWAITABLES&amp;&amp;... awaitables)
<!-- -->    -&gt; Awaitable&lt;std::tuple&lt;typename awaitable_traits&lt;AWAITABLES&gt;::await_result_t...&gt;&gt;;
<!-- -->
<!-- -->  // Overload for vector&lt;Awaitable&lt;void&gt;&gt;.
<!-- -->  template&lt;
<!-- -->    typename AWAITABLE,
<!-- -->    typename RESULT = typename awaitable_traits&lt;AWAITABLE&gt;::await_result_t,
<!-- -->    std::enable_if_t&lt;std::is_void_v&lt;RESULT&gt;, int&gt; = 0&gt;
<!-- -->  auto when_all(std::vector&lt;AWAITABLE&gt; awaitables)
<!-- -->    -&gt; Awaitable&lt;void&gt;;
<!-- -->
<!-- -->  // Overload for vector&lt;Awaitable&lt;NonVoid&gt;&gt; that yield a value when awaited.
<!-- -->  template&lt;
<!-- -->    typename AWAITABLE,
<!-- -->    typename RESULT = typename awaitable_traits&lt;AWAITABLE&gt;::await_result_t,
<!-- -->    std::enable_if_t&lt;!std::is_void_v&lt;RESULT&gt;, int&gt; = 0&gt;
<!-- -->  auto when_all(std::vector&lt;AWAITABLE&gt; awaitables)
<!-- -->    -&gt; Awaitable&lt;std::vector&lt;std::conditional_t&lt;
<!-- -->         std::is_lvalue_reference_v&lt;RESULT&gt;,
<!-- -->         std::reference_wrapper&lt;std::remove_reference_t&lt;RESULT&gt;&gt;,
<!-- -->         std::remove_reference_t&lt;RESULT&gt;&gt;&gt;&gt;;
<!-- -->}
</code></pre><p>Examples:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>task&lt;A&gt; get_a();
</span>task&lt;B&gt; get_b();
<!-- -->
<!-- -->task&lt;&gt; example1()
<!-- -->{
<!-- -->  // Run get_a() and get_b() concurrently.
<!-- -->  // Task yields a std::tuple&lt;A, B&gt; which can be unpacked using structured bindings.
<!-- -->  auto [a, b] = co_await when_all(get_a(), get_b());
<!-- -->
<!-- -->  // use a, b
<!-- -->}
<!-- -->
<!-- -->task&lt;std::string&gt; get_record(int id);
<!-- -->
<!-- -->task&lt;&gt; example2()
<!-- -->{
<!-- -->  std::vector&lt;task&lt;std::string&gt;&gt; tasks;
<!-- -->  for (int i = 0; i &lt; 1000; ++i)
<!-- -->  {
<!-- -->    tasks.emplace_back(get_record(i));
<!-- -->  }
<!-- -->
<!-- -->  // Concurrently execute all get_record() tasks.
<!-- -->  // If any of them fail with an exception then the exception will propagate
<!-- -->  // out of the co_await expression once they have all completed.
<!-- -->  std::vector&lt;std::string&gt; records = co_await when_all(std::move(tasks));
<!-- -->
<!-- -->  // Process results
<!-- -->  for (int i = 0; i &lt; 1000; ++i)
<!-- -->  {
<!-- -->    std::cout &lt;&lt; i &lt;&lt; &quot; = &quot; &lt;&lt; records[i] &lt;&lt; std::endl;
<!-- -->  }
<!-- -->}
</code></pre><h2><code>fmap()</code></h2><p>The <code>fmap()</code> function can be used to apply a callable function to the value(s) contained within
a container-type, returning a new container-type of the results of applying the function the
contained value(s).</p><p>The <code>fmap()</code> function can apply a function to values of type <code>generator&lt;T&gt;</code>, <code>recursive_generator&lt;T&gt;</code>
and <code>async_generator&lt;T&gt;</code> as well as any value that supports the <code>Awaitable</code> concept (eg. <code>task&lt;T&gt;</code>).</p><p>Each of these types provides an overload for <code>fmap()</code> that takes two arguments; a function to apply
and the container value.
See documentation for each type for the supported <code>fmap()</code> overloads.</p><p>For example, the <code>fmap()</code> function can be used to apply a function to the eventual result of
a <code>task&lt;T&gt;</code>, producing a new <code>task&lt;U&gt;</code> that will complete with the return-value of the function.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// Given a function you want to apply that converts
</span>// a value of type A to value of type B.
<!-- -->B a_to_b(A value);
<!-- -->
<!-- -->// And a task that yields a value of type A
<!-- -->cppcoro::task&lt;A&gt; get_an_a();
<!-- -->
<!-- -->// We can apply the function to the result of the task using fmap()
<!-- -->// and obtain a new task yielding the result.
<!-- -->cppcoro::task&lt;B&gt; bTask = fmap(a_to_b, get_an_a());
<!-- -->
<!-- -->// An alternative syntax is to use the pipe notation.
<!-- -->cppcoro::task&lt;B&gt; bTask = get_an_a() | cppcoro::fmap(a_to_b);
</code></pre><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/fmap.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  template&lt;typename FUNC&gt;
<!-- -->  struct fmap_transform
<!-- -->  {
<!-- -->    fmap_transform(FUNC&amp;&amp; func) noexcept(std::is_nothrow_move_constructible_v&lt;FUNC&gt;);
<!-- -->    FUNC func;
<!-- -->  };
<!-- -->
<!-- -->  // Type-deducing constructor for fmap_transform object that can be used
<!-- -->  // in conjunction with operator|.
<!-- -->  template&lt;typename FUNC&gt;
<!-- -->  fmap_transform&lt;FUNC&gt; fmap(FUNC&amp;&amp; func);
<!-- -->
<!-- -->  // operator| overloads for providing pipe-based syntactic sugar for fmap()
<!-- -->  // such that the expression:
<!-- -->  //   &lt;value-expr&gt; | cppcoro::fmap(&lt;func-expr&gt;)
<!-- -->  // is equivalent to:
<!-- -->  //   fmap(&lt;func-expr&gt;, &lt;value-expr&gt;)
<!-- -->
<!-- -->  template&lt;typename T, typename FUNC&gt;
<!-- -->  decltype(auto) operator|(T&amp;&amp; value, fmap_transform&lt;FUNC&gt;&amp;&amp; transform);
<!-- -->
<!-- -->  template&lt;typename T, typename FUNC&gt;
<!-- -->  decltype(auto) operator|(T&amp;&amp; value, fmap_transform&lt;FUNC&gt;&amp; transform);
<!-- -->
<!-- -->  template&lt;typename T, typename FUNC&gt;
<!-- -->  decltype(auto) operator|(T&amp;&amp; value, const fmap_transform&lt;FUNC&gt;&amp; transform);
<!-- -->
<!-- -->  // Generic overload for all awaitable types.
<!-- -->  //
<!-- -->  // Returns an awaitable that when co_awaited, co_awaits the specified awaitable
<!-- -->  // and applies the specified func to the result of the &#x27;co_await awaitable&#x27;
<!-- -->  // expression as if by &#x27;std::invoke(func, co_await awaitable)&#x27;.
<!-- -->  //
<!-- -->  // If the type of &#x27;co_await awaitable&#x27; expression is &#x27;void&#x27; then co_awaiting the
<!-- -->  // returned awaitable is equivalent to &#x27;co_await awaitable, func()&#x27;.
<!-- -->  template&lt;
<!-- -->    typename FUNC,
<!-- -->    typename AWAITABLE,
<!-- -->    std::enable_if_t&lt;is_awaitable_v&lt;AWAITABLE&gt;, int&gt; = 0&gt;
<!-- -->  auto fmap(FUNC&amp;&amp; func, AWAITABLE&amp;&amp; awaitable)
<!-- -->    -&gt; Awaitable&lt;std::invoke_result_t&lt;FUNC, typename awaitable_traits&lt;AWAITABLE&gt;::await_result_t&gt;&gt;;
<!-- -->}
</code></pre><p>The <code>fmap()</code> function is designed to look up the correct overload by argument-dependent
lookup (ADL) so it should generally be called without the <code>cppcoro::</code> prefix.</p><h2><code>resume_on()</code></h2><p>The <code>resume_on()</code> function can be used to control the execution context that an awaitable
will resume the awaiting coroutine on when awaited. When applied to an <code>async_generator</code>
it controls which execution context the <code>co_await g.begin()</code> and <code>co_await ++it</code> operations
resume the awaiting coroutines on.</p><p>Normally, the awaiting coroutine of an awaitable (eg. a <code>task</code>) or <code>async_generator</code> will
resume execution on whatever thread the operation completed on. In some cases this may not
be the thread that you want to continue executing on. In these cases you can use the
<code>resume_on()</code> function to create a new awaitable or generator that will resume execution
on a thread associated with a specified scheduler.</p><p>The <code>resume_on()</code> function can be used either as a normal function returning a new awaitable/generator.
Or it can be used in a pipeline-syntax.</p><p>Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>task&lt;record&gt; load_record(int id);
</span>
<!-- -->ui_thread_scheduler uiThreadScheduler;
<!-- -->
<!-- -->task&lt;&gt; example()
<!-- -->{
<!-- -->  // This will start load_record() on the current thread.
<!-- -->  // Then when load_record() completes (probably on an I/O thread)
<!-- -->  // it will reschedule execution onto thread pool and call to_json
<!-- -->  // Once to_json completes it will transfer execution onto the
<!-- -->  // ui thread before resuming this coroutine and returning the json text.
<!-- -->  task&lt;std::string&gt; jsonTask =
<!-- -->    load_record(123)
<!-- -->    | cppcoro::resume_on(threadpool::default())
<!-- -->    | cppcoro::fmap(to_json)
<!-- -->    | cppcoro::resume_on(uiThreadScheduler);
<!-- -->
<!-- -->  // At this point, all we&#x27;ve done is create a pipeline of tasks.
<!-- -->  // The tasks haven&#x27;t started executing yet.
<!-- -->
<!-- -->  // Await the result. Starts the pipeline of tasks.
<!-- -->  std::string jsonText = co_await jsonTask;
<!-- -->
<!-- -->  // Guaranteed to be executing on ui thread here.
<!-- -->
<!-- -->  someUiControl.set_text(jsonText);
<!-- -->}
</code></pre><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/resume_on.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  template&lt;typename SCHEDULER, typename AWAITABLE&gt;
<!-- -->  auto resume_on(SCHEDULER&amp; scheduler, AWAITABLE awaitable)
<!-- -->    -&gt; Awaitable&lt;typename awaitable_traits&lt;AWAITABLE&gt;::await_traits_t&gt;;
<!-- -->
<!-- -->  template&lt;typename SCHEDULER, typename T&gt;
<!-- -->  async_generator&lt;T&gt; resume_on(SCHEDULER&amp; scheduler, async_generator&lt;T&gt; source);
<!-- -->
<!-- -->  template&lt;typename SCHEDULER&gt;
<!-- -->  struct resume_on_transform
<!-- -->  {
<!-- -->    explicit resume_on_transform(SCHEDULER&amp; scheduler) noexcept;
<!-- -->    SCHEDULER&amp; scheduler;
<!-- -->  };
<!-- -->
<!-- -->  // Construct a transform/operation that can be applied to a source object
<!-- -->  // using &quot;pipe&quot; notation (ie. operator|).
<!-- -->  template&lt;typename SCHEDULER&gt;
<!-- -->  resume_on_transform&lt;SCHEDULER&gt; resume_on(SCHEDULER&amp; scheduler) noexcept;
<!-- -->
<!-- -->  // Equivalent to &#x27;resume_on(transform.scheduler, std::forward&lt;T&gt;(value))&#x27;
<!-- -->  template&lt;typename T, typename SCHEDULER&gt;
<!-- -->  decltype(auto) operator|(T&amp;&amp; value, resume_on_transform&lt;SCHEDULER&gt; transform)
<!-- -->  {
<!-- -->    return resume_on(transform.scheduler, std::forward&lt;T&gt;(value));
<!-- -->  }
<!-- -->}
</code></pre><h2><code>schedule_on()</code></h2><p>The <code>schedule_on()</code> function can be used to change the execution context that a given
awaitable or <code>async_generator</code> starts executing on.</p><p>When applied to an <code>async_generator</code> it also affects which execution context it resumes
on after <code>co_yield</code> statement.</p><p>Note that the <code>schedule_on</code> transform does not specify the thread that the awaitable or
<code>async_generator</code> will complete or yield results on, that is up to the implementation of
the awaitable or generator.</p><p>See the <code>resume_on()</code> operator for a transform that controls the thread the operation completes on.</p><p>For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>task&lt;int&gt; get_value();
</span>io_service ioSvc;
<!-- -->
<!-- -->task&lt;&gt; example()
<!-- -->{
<!-- -->  // Starts executing get_value() on the current thread.
<!-- -->  int a = co_await get_value();
<!-- -->
<!-- -->  // Starts executing get_value() on a thread associated with ioSvc.
<!-- -->  int b = co_await schedule_on(ioSvc, get_value());
<!-- -->}
</code></pre><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/schedule_on.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  // Return a task that yields the same result as &#x27;t&#x27; but that
<!-- -->  // ensures that &#x27;t&#x27; is co_await&#x27;ed on a thread associated with
<!-- -->  // the specified scheduler. Resulting task will complete on
<!-- -->  // whatever thread &#x27;t&#x27; would normally complete on.
<!-- -->  template&lt;typename SCHEDULER, typename AWAITABLE&gt;
<!-- -->  auto schedule_on(SCHEDULER&amp; scheduler, AWAITABLE awaitable)
<!-- -->    -&gt; Awaitable&lt;typename awaitable_traits&lt;AWAITABLE&gt;::await_result_t&gt;;
<!-- -->
<!-- -->  // Return a generator that yields the same sequence of results as
<!-- -->  // &#x27;source&#x27; but that ensures that execution of the coroutine starts
<!-- -->  // execution on a thread associated with &#x27;scheduler&#x27; and resumes
<!-- -->  // after a &#x27;co_yield&#x27; on a thread associated with &#x27;scheduler&#x27;.
<!-- -->  template&lt;typename SCHEDULER, typename T&gt;
<!-- -->  async_generator&lt;T&gt; schedule_on(SCHEDULER&amp; scheduler, async_generator&lt;T&gt; source);
<!-- -->
<!-- -->  template&lt;typename SCHEDULER&gt;
<!-- -->  struct schedule_on_transform
<!-- -->  {
<!-- -->    explicit schedule_on_transform(SCHEDULER&amp; scheduler) noexcept;
<!-- -->    SCHEDULER&amp; scheduler;
<!-- -->  };
<!-- -->
<!-- -->  template&lt;typename SCHEDULER&gt;
<!-- -->  schedule_on_transform&lt;SCHEDULER&gt; schedule_on(SCHEDULER&amp; scheduler) noexcept;
<!-- -->
<!-- -->  template&lt;typename T, typename SCHEDULER&gt;
<!-- -->  decltype(auto) operator|(T&amp;&amp; value, schedule_on_transform&lt;SCHEDULER&gt; transform);
<!-- -->}
</code></pre><h1>Metafunctions</h1><h2><code>awaitable_traits&lt;T&gt;</code></h2><p>This template metafunction can be used to determine what the resulting type of a <code>co_await</code> expression
will be if applied to an expression of type <code>T</code>.</p><p>Note that this assumes the value of type <code>T</code> is being awaited in a context where it is unaffected by
any <code>await_transform</code> applied by the coroutine&#x27;s promise object. The results may differ if a value
of type <code>T</code> is awaited in such a context.</p><p>The <code>awaitable_traits&lt;T&gt;</code> template metafunction does not define the <code>awaiter_t</code> or <code>await_result_t</code>
nested typedefs if type, <code>T</code>, is not awaitable. This allows its use in SFINAE contexts that disables
overloads when <code>T</code> is not awaitable.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/awaitable_traits.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  template&lt;typename T&gt;
<!-- -->  struct awaitable_traits
<!-- -->  {
<!-- -->    // The type that results from applying `operator co_await()` to a value
<!-- -->    // of type T, if T supports an `operator co_await()`, otherwise is type `T&amp;&amp;`.
<!-- -->    typename awaiter_t = &lt;unspecified&gt;;
<!-- -->
<!-- -->    // The type of the result of co_await&#x27;ing a value of type T.
<!-- -->    typename await_result_t = &lt;unspecified&gt;;
<!-- -->  };
<!-- -->}
</code></pre><h2><code>is_awaitable&lt;T&gt;</code></h2><p>The <code>is_awaitable&lt;T&gt;</code> template metafunction allows you to query whether or not a given
type can be <code>co_await</code>ed or not from within a coroutine.</p><p>API Summary:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// &lt;cppcoro/is_awaitable.hpp&gt;
</span>namespace cppcoro
<!-- -->{
<!-- -->  template&lt;typename T&gt;
<!-- -->  struct is_awaitable : std::bool_constant&lt;...&gt;
<!-- -->  {};
<!-- -->
<!-- -->  template&lt;typename T&gt;
<!-- -->  constexpr bool is_awaitable_v = is_awaitable&lt;T&gt;::value;
<!-- -->}
</code></pre><h1>Concepts</h1><h2><code>Awaitable&lt;T&gt;</code> concept</h2><p>An <code>Awaitable&lt;T&gt;</code> is a concept that indicates that a type can be <code>co_await</code>ed in a coroutine context
that has no <code>await_transform</code> overloads and that the result of the <code>co_await</code> expression has type, <code>T</code>.</p><p>For example, the type <code>task&lt;T&gt;</code> implements the concept <code>Awaitable&lt;T&amp;&amp;&gt;</code> whereas the type <code>task&lt;T&gt;&amp;</code>
implements the concept <code>Awaitable&lt;T&amp;&gt;</code>.</p><h2><code>Awaiter&lt;T&gt;</code> concept</h2><p>An <code>Awaiter&lt;T&gt;</code> is a concept that indicates a type contains the <code>await_ready</code>, <code>await_suspend</code> and
<code>await_resume</code> methods required to implement the protocol for suspending/resuming an awaiting
coroutine.</p><p>A type that satisfies <code>Awaiter&lt;T&gt;</code> must have, for an instance of the type, <code>awaiter</code>:</p><ul><li><code>awaiter.await_ready()</code> -&gt; <code>bool</code></li><li><code>awaiter.await_suspend(std::experimental::coroutine_handle&lt;void&gt;{})</code> -&gt; <code>void</code> or <code>bool</code> or <code>std::experimental::coroutine_handle&lt;P&gt;</code> for some <code>P</code>.</li><li><code>awaiter.await_resume()</code> -&gt; <code>T</code></li></ul><p>Any type that implements the <code>Awaiter&lt;T&gt;</code> concept also implements the <code>Awaitable&lt;T&gt;</code> concept.</p><h2><code>Scheduler</code> concept</h2><p>A <code>Scheduler</code> is a concept that allows scheduling execution of coroutines within some execution context.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>concept Scheduler
</span>{
<!-- -->  Awaitable&lt;void&gt; schedule();
<!-- -->}
</code></pre><p>Given a type, <code>S</code>, that implements the <code>Scheduler</code> concept, and an instance, <code>s</code>, of type <code>S</code>:</p><ul><li>The <code>s.schedule()</code> method returns an awaitable-type such that <code>co_await s.schedule()</code>
will unconditionally suspend the current coroutine and schedule it for resumption on the
execution context associated with the scheduler, <code>s</code>.</li><li>The result of the <code>co_await s.schedule()</code> expression has type <code>void</code>.</li></ul><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cppcoro::task&lt;&gt; f(Scheduler&amp; scheduler)
</span>{
<!-- -->  // Execution of the coroutine is initially on the caller&#x27;s execution context.
<!-- -->
<!-- -->  // Suspends execution of the coroutine and schedules it for resumption on
<!-- -->  // the scheduler&#x27;s execution context.
<!-- -->  co_await scheduler.schedule();
<!-- -->
<!-- -->  // At this point the coroutine is now executing on the scheduler&#x27;s
<!-- -->  // execution context.
<!-- -->}
</code></pre><h2><code>DelayedScheduler</code> concept</h2><p>A <code>DelayedScheduler</code> is a concept that allows a coroutine to schedule itself for execution on
the scheduler&#x27;s execution context after a specified duration of time has elapsed.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>concept DelayedScheduler : Scheduler
</span>{
<!-- -->  template&lt;typename REP, typename RATIO&gt;
<!-- -->  Awaitable&lt;void&gt; schedule_after(std::chrono::duration&lt;REP, RATIO&gt; delay);
<!-- -->
<!-- -->  template&lt;typename REP, typename RATIO&gt;
<!-- -->  Awaitable&lt;void&gt; schedule_after(
<!-- -->    std::chrono::duration&lt;REP, RATIO&gt; delay,
<!-- -->    cppcoro::cancellation_token cancellationToken);
<!-- -->}
</code></pre><p>Given a type, <code>S</code>, that implements the <code>DelayedScheduler</code> and an instance, <code>s</code> of type <code>S</code>:</p><ul><li>The <code>s.schedule_after(delay)</code> method returns an object that can be awaited
such that <code>co_await s.schedule_after(delay)</code> suspends the current coroutine
for a duration of <code>delay</code> before scheduling the coroutine for resumption on
the execution context associated with the scheduler, <code>s</code>.</li><li>The <code>co_await s.schedule_after(delay)</code> expression has type <code>void</code>.</li></ul><h1>Building</h1><p>The cppcoro library supports building under Windows with Visual Studio 2017 and Linux with Clang 5.0+.</p><p>This library makes use of the <a href="https://github.com/lewissbaker/cake">Cake build system</a> (no, not the <a href="http://cakebuild.net/">C# one</a>).</p><p>The cake build system is checked out automatically as a git submodule so you don&#x27;t need to download or install it separately.</p><h2>Building on Windows</h2><p>This library currently requires Visual Studio 2017 or later and the Windows 10 SDK.</p><p>Support for Clang (<a href="https://github.com/lewissbaker/cppcoro/issues/3">#3</a>) and Linux (<a href="https://github.com/lewissbaker/cppcoro/issues/15">#15</a>) is planned.</p><h3>Prerequisites</h3><p>The Cake build-system is implemented in Python and requires Python 2.7 to be installed.</p><p>Ensure Python 2.7 interpreter is in your PATH and available as &#x27;python&#x27;.</p><p>Ensure Visual Studio 2017 Update 3 or later is installed.
Note that there are some known issues with coroutines in Update 2 or earlier that have been fixed in Update 3.</p><p>You can also use an experimental version of the Visual Studio compiler by downloading a NuGet package from <a href="https://vcppdogfooding.azurewebsites.net/">https://vcppdogfooding.azurewebsites.net/</a> and unzipping the .nuget file to a directory.
Just update the <code>config.cake</code> file to point at the unzipped location by modifying and uncommenting the following line:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-python" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>nugetPath </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#905">None</span><span> </span><span class="token" style="color:slategray"># r&#x27;C:\Path\To\VisualCppTools.14.0.25224-Pre&#x27;</span></code></pre><p>Ensure that you have the Windows 10 SDK installed.
It will use the latest Windows 10 SDK and Universal C Runtime version by default.</p><h3>Cloning the repository</h3><p>The cppcoro repository makes use of git submodules to pull in the source for the Cake build system.</p><p>This means you need to pass the <code>--recursive</code> flag to the <code>git clone</code> command. eg.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>c:\Code&gt; git clone --recursive https://github.com/lewissbaker/cppcoro.git</span></code></pre><p>If you have already cloned cppcoro, then you should update the submodules after pulling changes.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>c:\Code\cppcoro&gt; git submodule update --init --recursive</span></code></pre><h3>Building from the command-line</h3><p>To build from the command-line just run &#x27;cake.bat&#x27; in the workspace root.</p><p>eg.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>C:\cppcoro&gt; cake.bat
</span>Building with C:\cppcoro\config.cake - Variant(release=&#x27;debug&#x27;, platform=&#x27;windows&#x27;, architecture=&#x27;x86&#x27;, compilerFamily=&#x27;msvc&#x27;, compiler=&#x27;msvc14.10&#x27;)
<!-- -->Building with C:\cppcoro\config.cake - Variant(release=&#x27;optimised&#x27;, platform=&#x27;windows&#x27;, architecture=&#x27;x64&#x27;, compilerFamily=&#x27;msvc&#x27;, compiler=&#x27;msvc14.10&#x27;)
<!-- -->Building with C:\cppcoro\config.cake - Variant(release=&#x27;debug&#x27;, platform=&#x27;windows&#x27;, architecture=&#x27;x64&#x27;, compilerFamily=&#x27;msvc&#x27;, compiler=&#x27;msvc14.10&#x27;)
<!-- -->Building with C:\cppcoro\config.cake - Variant(release=&#x27;optimised&#x27;, platform=&#x27;windows&#x27;, architecture=&#x27;x86&#x27;, compilerFamily=&#x27;msvc&#x27;, compiler=&#x27;msvc14.10&#x27;)
<!-- -->Compiling test\main.cpp
<!-- -->Compiling test\main.cpp
<!-- -->Compiling test\main.cpp
<!-- -->Compiling test\main.cpp
<!-- -->...
<!-- -->Linking build\windows_x86_msvc14.10_debug\test\run.exe
<!-- -->Linking build\windows_x64_msvc14.10_optimised\test\run.exe
<!-- -->Linking build\windows_x86_msvc14.10_optimised\test\run.exe
<!-- -->Linking build\windows_x64_msvc14.10_debug\test\run.exe
<!-- -->Generating code
<!-- -->Finished generating code
<!-- -->Generating code
<!-- -->Finished generating code
<!-- -->Build succeeded.
<!-- -->Build took 0:00:02.419.
</code></pre><p>By default, running <code>cake</code> with no arguments will build all projects with all build variants and execute the unit-tests.
You can narrow what is built by passing additional command-line arguments.
eg.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>c:\cppcoro&gt; cake.bat release=debug architecture=x64 lib/build.cake
</span>Building with C:\Users\Lewis\Code\cppcoro\config.cake - Variant(release=&#x27;debug&#x27;, platform=&#x27;windows&#x27;, architecture=&#x27;x64&#x27;, compilerFamily=&#x27;msvc&#x27;, compiler=&#x27;msvc14.10&#x27;)
<!-- -->Archiving build\windows_x64_msvc14.10_debug\lib\cppcoro.lib
<!-- -->Build succeeded.
<!-- -->Build took 0:00:00.321.
</code></pre><p>You can run <code>cake --help</code> to list available command-line options.</p><h3>Building Visual Studio project files</h3><p>To develop from within Visual Studio you can build .vcproj/.sln files by running <code>cake.bat -p</code>.</p><p>eg.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>c:\cppcoro&gt; cake.bat -p
</span>Building with C:\cppcoro\config.cake - Variant(release=&#x27;debug&#x27;, platform=&#x27;windows&#x27;, architecture=&#x27;x86&#x27;, compilerFamily=&#x27;msvc&#x27;, compiler=&#x27;msvc14.10&#x27;)
<!-- -->Building with C:\cppcoro\config.cake - Variant(release=&#x27;optimised&#x27;, platform=&#x27;windows&#x27;, architecture=&#x27;x64&#x27;, compilerFamily=&#x27;msvc&#x27;, compiler=&#x27;msvc14.10&#x27;)
<!-- -->Building with C:\cppcoro\config.cake - Variant(release=&#x27;debug&#x27;, platform=&#x27;windows&#x27;, architecture=&#x27;x64&#x27;, compilerFamily=&#x27;msvc&#x27;, compiler=&#x27;msvc14.10&#x27;)
<!-- -->Building with C:\cppcoro\config.cake - Variant(release=&#x27;optimised&#x27;, platform=&#x27;windows&#x27;, architecture=&#x27;x86&#x27;, compilerFamily=&#x27;msvc&#x27;, compiler=&#x27;msvc14.10&#x27;)
<!-- -->Generating Solution build/project/cppcoro.sln
<!-- -->Generating Project build/project/cppcoro_tests.vcxproj
<!-- -->Generating Filters build/project/cppcoro_tests.vcxproj.filters
<!-- -->Generating Project build/project/cppcoro.vcxproj
<!-- -->Generating Filters build/project/cppcoro.vcxproj.filters
<!-- -->Build succeeded.
<!-- -->Build took 0:00:00.247.
</code></pre><p>When you build these projects from within Visual Studio it will call out to cake to perform the compilation.</p><h2>Building on Linux</h2><p>The cppcoro project can also be built under Linux using Clang + libc++ 5.0 or later.</p><p>Building cppcoro has been tested under Ubuntu 17.04.</p><h3>Prerequisities</h3><p>Ensure you have the following packages installed:</p><ul><li>Python 2.7</li><li>Clang &gt;= 5.0</li><li>LLD &gt;= 5.0</li><li>libc++ &gt;= 5.0</li></ul><h3>Building cppcoro</h3><p>This is assuming you have Clang and libc++ built and installed.</p><p>If you don&#x27;t have Clang configured yet, see the following sections
for details on setting up Clang for building with cppcoro.</p><p>Checkout cppcoro and its submodules:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>git clone --recursive https://github.com/lewissbaker/cppcoro.git cppcoro</span></code></pre><p>Run <code>init.sh</code> to setup the <code>cake</code> bash function:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>cd cppcoro
</span>source init.sh
</code></pre><p>Then you can run <code>cake</code> from the workspace root to build cppcoro and run tests:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>$ cake</span></code></pre><p>You can specify additional command-line arguments to customise the build:</p><ul><li><code>--help</code> will print out help for command-line arguments</li><li><code>--debug=run</code> will show the build command-lines being run</li><li><code>release=debug</code> or <code>release=optimised</code> will limit the build variant to
either debug or optimised (by default it will build both).</li><li><code>lib/build.cake</code> will just build the cppcoro library and not the tests.</li><li><code>test/build.cake@task_tests.cpp</code> will just compile a particular source file</li></ul><p>For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>$ cake --debug=run release=debug lib/build.cake</span></code></pre><h3>Customising location of Clang</h3><p>If your clang compiler is not located at <code>/usr/bin/clang</code> then you need to
modify the <code>config.cake</code> file to tell cake where to find clang.</p><p>Edit the following line in <code>config.cake</code>:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-python" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>  </span><span class="token" style="color:slategray"># If you have built your own version of Clang, you can modify</span><span>
</span><span>  </span><span class="token" style="color:slategray"># this variable to point to the CMAKE_INSTALL_PREFIX for</span><span>
</span><span>  </span><span class="token" style="color:slategray"># where you have installed your clang/libcxx build.</span><span>
</span><span>  clangInstallPrefix </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#690">&#x27;/usr&#x27;</span></code></pre><p>If you have <code>libc++</code> installed in a different location then you can
customise its location by modifying the following line in <code>config.cake</code>.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-python" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>  </span><span class="token" style="color:slategray"># Set this to the install-prefix of where libc++ is installed.</span><span>
</span><span>  </span><span class="token" style="color:slategray"># You only need to set this if it is not installed at the same</span><span>
</span><span>  </span><span class="token" style="color:slategray"># location as clangInstallPrefix.</span><span>
</span><span>  libCxxInstallPrefix </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#905">None</span><span> </span><span class="token" style="color:slategray"># &#x27;/path/to/install&#x27;</span></code></pre><p>If the install location has multiple versions of Clang installed and
the one you want to use is not <code>&lt;install-prefix&gt;/bin/clang</code> then you
can explicitly specify which one to use by modifying the <code>config.cake</code>
file to specify the name of the clang binaries:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-python" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>  compiler </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> ClangCompiler</span><span class="token" style="color:#999">(</span><span>
</span><span>    configuration</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span>configuration</span><span class="token" style="color:#999">,</span><span>
</span><span>    clangExe</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span>cake</span><span class="token" style="color:#999">.</span><span>path</span><span class="token" style="color:#999">.</span><span>join</span><span class="token" style="color:#999">(</span><span>clangBinPath</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#690">&#x27;clang-6.0&#x27;</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span>
</span><span>    llvmArExe</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span>cake</span><span class="token" style="color:#999">.</span><span>path</span><span class="token" style="color:#999">.</span><span>join</span><span class="token" style="color:#999">(</span><span>clangBinPath</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#690">&#x27;llvm-ar-6.0&#x27;</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span>
</span><span>    binPaths</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span class="token" style="color:#999">[</span><span>clangBinPath</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">)</span></code></pre><h3>Using a snapshot build of Clang</h3><p>If your Linux distribution does not have a version of Clang 5.0 or later
available, you can install a snapshot build from the LLVM project.</p><p>Follow instructions at <a href="http://apt.llvm.org/">http://apt.llvm.org/</a> to setup your package manager
to support pulling from the LLVM package manager.</p><p>For example, for Ubuntu 17.04 Zesty:</p><p>Edit <code>/etc/apt/sources.list</code> and add the following lines:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>deb http://apt.llvm.org/zesty/ llvm-toolchain-zesty main
</span>deb-src http://apt.llvm.org/zesty/ llvm-toolchain-zesty main
</code></pre><p>Install the PGP key for those packages:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>$ wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -</span></code></pre><p>Install Clang and LLD:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>$ sudo apt-get install clang-6.0 lld-6.0</span></code></pre><p>The LLVM snapshot builds do not include libc++ versions so you&#x27;ll need to build that yourself.
See below.</p><h3>Building your own Clang</h3><p>You can also use the bleeding-edge Clang version by building Clang from source yourself.</p><p>See instructions here:</p><p>To do this you will need to install the following pre-requisites:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>$ sudo apt-get install git cmake ninja-build clang lld</span></code></pre><p>Note that we are using your distribution&#x27;s version of clang to build
clang from source. GCC could also be used here instead.</p><p>Checkout LLVM + Clang + LLD + libc++ repositories:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>mkdir llvm
</span>cd llvm
<!-- -->git clone --depth=1 https://github.com/llvm-mirror/llvm.git llvm
<!-- -->git clone --depth=1 https://github.com/llvm-mirror/clang.git llvm/tools/clang
<!-- -->git clone --depth=1 https://github.com/llvm-mirror/lld.git llvm/tools/lld
<!-- -->git clone --depth=1 https://github.com/llvm-mirror/libcxx.git llvm/projects/libcxx
<!-- -->ln -s llvm/tools/clang clang
<!-- -->ln -s llvm/tools/lld lld
<!-- -->ln -s llvm/projects/libcxx libcxx
</code></pre><p>Configure and build Clang:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>mkdir clang-build
</span>cd clang-build
<!-- -->cmake -GNinja \
<!-- -->      -DCMAKE_CXX_COMPILER=/usr/bin/clang++ \
<!-- -->      -DCMAKE_C_COMPILER=/usr/bin/clang \
<!-- -->      -DCMAKE_BUILD_TYPE=MinSizeRel \
<!-- -->      -DCMAKE_INSTALL_PREFIX=&quot;/path/to/clang/install&quot;
<!-- -->      -DCMAKE_BUILD_WITH_INSTALL_RPATH=&quot;yes&quot; \
<!-- -->      -DLLVM_TARGETS_TO_BUILD=X86 \
<!-- -->      -DLLVM_ENABLE_PROJECTS=&quot;lld;clang&quot; \
<!-- -->      ../llvm
<!-- -->ninja install-clang \
<!-- -->      install-clang-headers \
<!-- -->      install-llvm-ar \
<!-- -->      install-lld
</code></pre><h3>Building libc++</h3><p>The cppcoro project requires libc++ as it contains the <code>&lt;experimental/coroutine&gt;</code>
header required to use C++ coroutines under Clang.</p><p>Checkout <code>libc++</code> + <code>llvm</code>:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>mkdir llvm
</span>cd llvm
<!-- -->git clone --depth=1 https://github.com/llvm-mirror/llvm.git llvm
<!-- -->git clone --depth=1 https://github.com/llvm-mirror/libcxx.git llvm/projects/libcxx
<!-- -->ln -s llvm/projects/libcxx libcxx
</code></pre><p>Build <code>libc++</code>:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>mkdir libcxx-build
</span>cd libcxx-build
<!-- -->cmake -GNinja \
<!-- -->      -DCMAKE_CXX_COMPILER=&quot;/path/to/clang/install/bin/clang++&quot; \
<!-- -->      -DCMAKE_C_COMPILER=&quot;/path/to/clang/install/bin/clang&quot; \
<!-- -->      -DCMAKE_BUILD_TYPE=Release \
<!-- -->      -DCMAKE_INSTALL_PREFIX=&quot;/path/to/clang/install&quot; \
<!-- -->      -DLLVM_PATH=&quot;../llvm&quot; \
<!-- -->      -DLIBCXX_CXX_ABI=libstdc++ \
<!-- -->      -DLIBCXX_CXX_ABI_INCLUDE_PATHS=&quot;/usr/include/c++/6.3.0/;/usr/include/x86_64-linux-gnu/c++/6.3.0/&quot; \
<!-- -->      ../libcxx
<!-- -->ninja cxx
<!-- -->ninja install
</code></pre><p>This will build and install libc++ into the same install directory where you have clang installed.</p><h1>Support</h1><p>GitHub issues are the primary mechanism for support, bug reports and feature requests.</p><p>Contributions are welcome and pull-requests will be happily reviewed.
I only ask that you agree to license any contributions that you make under the MIT license.</p><p>If you have general questions about C++ coroutines, you can generally find someone to help
in the <code>#coroutines</code> channel on <a href="https://cpplang.slack.com/">Cpplang Slack</a> group.</p></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/lewissbaker-cppcoro","name":"lewissbaker/cppcoro","licence":"MIT","description":"A library of C++ coroutine abstractions for the coroutines TS","readme":"# CppCoro - A coroutine library for C++\n\nThe 'cppcoro' library provides a set of general-purpose primitives for making use of the coroutines TS proposal described in [N4680](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf).\n\nThese include:\n* Coroutine Types\n  * `task\u003cT\u003e`\n  * `shared_task\u003cT\u003e`\n  * `generator\u003cT\u003e`\n  * `recursive_generator\u003cT\u003e`\n  * `async_generator\u003cT\u003e`\n* Awaitable Types\n  * `single_consumer_event`\n  * `single_consumer_auto_reset_event`\n  * `async_mutex`\n  * `async_manual_reset_event`\n  * `async_auto_reset_event`\n  * `async_latch`\n* Functions\n  * `sync_wait()`\n  * `when_all()`\n  * `when_all_ready()`\n  * `fmap()`\n  * `schedule_on()`\n  * `resume_on()`\n* Cancellation\n  * `cancellation_token`\n  * `cancellation_source`\n  * `cancellation_registration`\n* Schedulers and I/O\n  * `static_thread_pool`\n  * `io_service`\n  * `io_work_scope`\n  * `file`, `readable_file`, `writable_file`\n  * `read_only_file`, `write_only_file`, `read_write_file`\nNetworking\n  * `socket`\n  * `ip_address`, `ipv4_address`, `ipv6_address`\n  * `ip_endpoint`, `ipv4_endpoint`, `ipv6_endpoint`\n* Metafunctions\n  * `is_awaitable\u003cT\u003e`\n  * `awaitable_traits\u003cT\u003e`\n* Concepts\n  * `Awaitable\u003cT\u003e`\n  * `Awaiter\u003cT\u003e`\n  * `Scheduler`\n  * `DelayedScheduler`\n\nThis library is an experimental library that is exploring the space of high-performance,\nscalable asynchronous programming abstractions that can be built on top of the C++ coroutines\nproposal.\n\nIt has been open-sourced in the hope that others will find it useful and that the C++ community\ncan provide feedback on it and ways to improve it.\n\nIt requires a compiler that supports the coroutines TS:\n- Windows + Visual Studio 2017 [![Windows Build Status](https://ci.appveyor.com/api/projects/status/github/lewissbaker/cppcoro?branch=master\u0026svg=true\u0026passingText=master%20-%20OK\u0026failingText=master%20-%20Failing\u0026pendingText=master%20-%20Pending)](https://ci.appveyor.com/project/lewissbaker/cppcoro/branch/master)\n- Linux + Clang 5.0/6.0 + libc++ [![Build Status](https://travis-ci.org/lewissbaker/cppcoro.svg?branch=master)](https://travis-ci.org/lewissbaker/cppcoro)\n\nThe Linux version is functional except for the `io_context` and file I/O related classes which have not yet been implemented for Linux (see issue [#15](https://github.com/lewissbaker/cppcoro/issues/15) for more info).\n\n# Class Details\n\n## `task\u003cT\u003e`\n\nA task represents an asynchronous computation that is executed lazily in\nthat the execution of the coroutine does not start until the task is awaited.\n\nExample:\n```c++\n#include \u003ccppcoro/read_only_file.hpp\u003e\n#include \u003ccppcoro/task.hpp\u003e\n\ncppcoro::task\u003cint\u003e count_lines(std::string path)\n{\n  auto file = co_await cppcoro::read_only_file::open(path);\n\n  int lineCount = 0;\n\n  char buffer[1024];\n  size_t bytesRead;\n  std::uint64_t offset = 0;\n  do\n  {\n    bytesRead = co_await file.read(offset, buffer, sizeof(buffer));\n    lineCount += std::count(buffer, buffer + bytesRead, '\\n');\n    offset += bytesRead;\n  } while (bytesRead \u003e 0);\n  \n  co_return lineCount;\n}\n\ncppcoro::task\u003c\u003e usage_example()\n{\n  // Calling function creates a new task but doesn't start\n  // executing the coroutine yet.\n  cppcoro::task\u003cint\u003e countTask = count_lines(\"foo.txt\");\n  \n  // ...\n  \n  // Coroutine is only started when we later co_await the task.\n  int lineCount = co_await countTask;\n\n  std::cout \u003c\u003c \"line count = \" \u003c\u003c lineCount \u003c\u003c std::endl;\n}\n```\n\nAPI Overview:\n```c++\n// \u003ccppcoro/task.hpp\u003e\nnamespace cppcoro\n{\n  template\u003ctypename T\u003e\n  class task\n  {\n  public:\n\n    using promise_type = \u003cunspecified\u003e;\n    using value_type = T;\n\n    task() noexcept;\n\n    task(task\u0026\u0026 other) noexcept;\n    task\u0026 operator=(task\u0026\u0026 other);\n\n    // task is a move-only type.\n    task(const task\u0026 other) = delete;\n    task\u0026 operator=(const task\u0026 other) = delete;\n\n    // Query if the task result is ready.\n    bool is_ready() const noexcept;\n\n    // Wait for the task to complete and return the result or rethrow the\n    // exception if the operation completed with an unhandled exception.\n    //\n    // If the task is not yet ready then the awaiting coroutine will be\n    // suspended until the task completes. If the the task is_ready() then\n    // this operation will return the result synchronously without suspending.\n    Awaiter\u003cT\u0026\u003e operator co_await() const \u0026 noexcept;\n    Awaiter\u003cT\u0026\u0026\u003e operator co_await() const \u0026\u0026 noexcept;\n\n    // Returns an awaitable that can be co_await'ed to suspend the current\n    // coroutine until the task completes.\n    //\n    // The 'co_await t.when_ready()' expression differs from 'co_await t' in\n    // that when_ready() only performs synchronisation, it does not return\n    // the result or rethrow the exception.\n    //\n    // This can be useful if you want to synchronise with the task without\n    // the possibility of it throwing an exception.\n    Awaitable\u003cvoid\u003e when_ready() const noexcept;\n  };\n\n  template\u003ctypename T\u003e\n  void swap(task\u003cT\u003e\u0026 a, task\u003cT\u003e\u0026 b);\n\n  // Creates a task that yields the result of co_await'ing the specified awaitable.\n  //\n  // This can be used as a form of type-erasure of the concrete awaitable, allowing\n  // different awaitables that return the same await-result type to be stored in\n  // the same task\u003cRESULT\u003e type.\n  template\u003c\n    typename AWAITABLE,\n    typename RESULT = typename awaitable_traits\u003cAWAITABLE\u003e::await_result_t\u003e\n  task\u003cRESULT\u003e make_task(AWAITABLE awaitable);\n}\n```\n\nYou create a `task\u003cT\u003e` object by calling a coroutine function that returns\na `task\u003cT\u003e`.\n\nThe coroutine must contain a usage of either `co_await` or `co_return`.\nNote that a `task\u003cT\u003e` coroutine may not use the `co_yield` keyword.\n\nWhen a coroutine that returns a `task\u003cT\u003e` is called, a coroutine frame\nis allocated if necessary and the parameters are captured in the coroutine\nframe. The coroutine is suspended at the start of the coroutine body and\nexecution is returned to the caller and a `task\u003cT\u003e` value that represents\nthe asynchronous computation is returned from the function call.\n\nThe coroutine body will start executing when the `task\u003cT\u003e` value is\n`co_await`ed. This will suspend the awaiting coroutine and start execution\nof the coroutine associated with the awaited `task\u003cT\u003e` value.\n\nThe awaiting coroutine will later be resumed on the thread that completes\nexecution of the awaited `task\u003cT\u003e`'s coroutine. ie. the thread that\nexecutes the `co_return` or that throws an unhandled exception that terminates\nexecution of the coroutine.\n\nIf the task has already run to completion then awaiting it again will obtain\nthe already-computed result without suspending the awaiting coroutine.\n\nIf the `task` object is destroyed before it is awaited then the coroutine\nnever executes and the destructor simply destructs the captured parameters\nand frees any memory used by the coroutine frame.\n\n## `shared_task\u003cT\u003e`\n\nThe `shared_task\u003cT\u003e` class is a coroutine type that yields a single value\nasynchronously.\n\nIt is 'lazy' in that execution of the task does not start until it is awaited by some\ncoroutine.\n\nIt is 'shared' in that the task value can be copied, allowing multiple references to\nthe result of the task to be created. It also allows multiple coroutines to\nconcurrently await the result.\n\nThe task will start executing on the thread that first `co_await`s the task.\nSubsequent awaiters will either be suspended and be queued for resumption\nwhen the task completes or will continue synchronously if the task has\nalready run to completion.\n\nIf an awaiter is suspended while waiting for the task to complete then\nit will be resumed on the thread that completes execution of the task.\nie. the thread that executes the `co_return` or that throws the unhandled\nexception that terminates execution of the coroutine.\n\nAPI Summary\n```c++\nnamespace cppcoro\n{\n  template\u003ctypename T = void\u003e\n  class shared_task\n  {\n  public:\n\n    using promise_type = \u003cunspecified\u003e;\n    using value_type = T;\n\n    shared_task() noexcept;\n    shared_task(const shared_task\u0026 other) noexcept;\n    shared_task(shared_task\u0026\u0026 other) noexcept;\n    shared_task\u0026 operator=(const shared_task\u0026 other) noexcept;\n    shared_task\u0026 operator=(shared_task\u0026\u0026 other) noexcept;\n\n    void swap(shared_task\u0026 other) noexcept;\n\n    // Query if the task has completed and the result is ready.\n    bool is_ready() const noexcept;\n\n    // Returns an operation that when awaited will suspend the\n    // current coroutine until the task completes and the result\n    // is available.\n    //\n    // The type of the result of the 'co_await someTask' expression\n    // is an l-value reference to the task's result value (unless T\n    // is void in which case the expression has type 'void').\n    // If the task completed with an unhandled exception then the\n    // exception will be rethrown by the co_await expression.\n    Awaiter\u003cT\u0026\u003e operator co_await() const noexcept;\n\n    // Returns an operation that when awaited will suspend the\n    // calling coroutine until the task completes and the result\n    // is available.\n    //\n    // The result is not returned from the co_await expression.\n    // This can be used to synchronise with the task without the\n    // possibility of the co_await expression throwing an exception.\n    Awaiter\u003cvoid\u003e when_ready() const noexcept;\n\n  };\n\n  template\u003ctypename T\u003e\n  bool operator==(const shared_task\u003cT\u003e\u0026 a, const shared_task\u003cT\u003e\u0026 b) noexcept;\n  template\u003ctypename T\u003e\n  bool operator!=(const shared_task\u003cT\u003e\u0026 a, const shared_task\u003cT\u003e\u0026 b) noexcept;\n\n  template\u003ctypename T\u003e\n  void swap(shared_task\u003cT\u003e\u0026 a, shared_task\u003cT\u003e\u0026 b) noexcept;\n\n  // Wrap an awaitable value in a shared_task to allow multiple coroutines\n  // to concurrently await the result.\n  template\u003c\n    typename AWAITABLE,\n    typename RESULT = typename awaitable_traits\u003cAWAITABLE\u003e::await_result_t\u003e\n  shared_task\u003cRESULT\u003e make_shared_task(AWAITABLE awaitable);\n}\n```\n\nAll const-methods on `shared_task\u003cT\u003e` are safe to call concurrently with other \nconst-methods on the same instance from multiple threads. It is not safe to call\nnon-const methods of `shared_task\u003cT\u003e` concurrently with any other method on the\nsame instance of a `shared_task\u003cT\u003e`.\n\n### Comparison to `task\u003cT\u003e`\n\nThe `shared_task\u003cT\u003e` class is similar to `task\u003cT\u003e` in that the task does\nnot start execution immediately upon the coroutine function being called.\nThe task only starts executing when it is first awaited.\n\nIt differs from `task\u003cT\u003e` in that the resulting task object can be copied,\nallowing multiple task objects to reference the same asynchronous result.\nIt also supports multiple coroutines concurrently awaiting the result of the task.\n\nThe trade-off is that the result is always an l-value reference to the\nresult, never an r-value reference (since the result may be shared) which\nmay limit ability to move-construct the result into a local variable.\nIt also has a slightly higher run-time cost due to the need to maintain\na reference count and support multiple awaiters.\n\n## `generator\u003cT\u003e`\n\nA `generator` represents a coroutine type that produces a sequence of values of type, `T`,\nwhere values are produced lazily and synchronously.\n\nThe coroutine body is able to yield values of type `T` using the `co_yield` keyword.\nNote, however, that the coroutine body is not able to use the `co_await` keyword;\nvalues must be produced synchronously.\n\nFor example:\n```c++\ncppcoro::generator\u003cconst std::uint64_t\u003e fibonacci()\n{\n  std::uint64_t a = 0, b = 1;\n  while (true)\n  {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\n\nvoid usage()\n{\n  for (auto i : fibonacci())\n  {\n    if (i \u003e 1'000'000) break;\n    std::cout \u003c\u003c i \u003c\u003c std::endl;\n  }\n}\n```\n\nWhen a coroutine function returning a `generator\u003cT\u003e` is called the coroutine is created initially suspended.\nExecution of the coroutine enters the coroutine body when the `generator\u003cT\u003e::begin()` method is called and continues until\neither the first `co_yield` statement is reached or the coroutine runs to completion.\n\nIf the returned iterator is not equal to the `end()` iterator then dereferencing the iterator will\nreturn a reference to the value passed to the `co_yield` statement.\n\nCalling `operator++()` on the iterator will resume execution of the coroutine and continue until\neither the next `co_yield` point is reached or the coroutine runs to completion().\n\nAny unhandled exceptions thrown by the coroutine will propagate out of the `begin()` or\n`operator++()` calls to the caller.\n\nAPI Summary:\n```c++\nnamespace cppcoro\n{\n    template\u003ctypename T\u003e\n    class generator\n    {\n    public:\n\n        using promise_type = \u003cunspecified\u003e;\n\n        class iterator\n        {\n        public:\n            using iterator_category = std::input_iterator_tag;\n            using value_type = std::remove_reference_t\u003cT\u003e;\n            using reference = value_type\u0026;\n            using pointer = value_type*;\n            using difference_type = std::size_t;\n\n            iterator(const iterator\u0026 other) noexcept;\n            iterator\u0026 operator=(const iterator\u0026 other) noexcept;\n\n            // If the generator coroutine throws an unhandled exception before producing\n            // the next element then the exception will propagate out of this call.\n            iterator\u0026 operator++();\n\n            reference operator*() const noexcept;\n            pointer operator-\u003e() const noexcept;\n\n            bool operator==(const iterator\u0026 other) const noexcept;\n            bool operator!=(const iterator\u0026 other) const noexcept;\n        };\n\n        // Constructs to the empty sequence.\n        generator() noexcept;\n\n        generator(generator\u0026\u0026 other) noexcept;\n        generator\u0026 operator=(generator\u0026\u0026 other) noexcept;\n        \n        generator(const generator\u0026 other) = delete;\n        generator\u0026 operator=(const generator\u0026) = delete;\n\n        ~generator();\n\n        // Starts executing the generator coroutine which runs until either a value is yielded\n        // or the coroutine runs to completion or an unhandled exception propagates out of the\n        // the coroutine.\n        iterator begin();\n\n        iterator end() noexcept;\n\n        // Swap the contents of two generators.\n        void swap(generator\u0026 other) noexcept;\n\n    };\n\n    template\u003ctypename T\u003e\n    void swap(generator\u003cT\u003e\u0026 a, generator\u003cT\u003e\u0026 b) noexcept;\n\n    // Apply function, func, lazily to each element of the source generator\n    // and yield a sequence of the results of calls to func().\n    template\u003ctypename FUNC, typename T\u003e\n    generator\u003cstd::invoke_result_t\u003cFUNC, T\u0026\u003e\u003e fmap(FUNC func, generator\u003cT\u003e source);\n}\n```\n\n## `recursive_generator\u003cT\u003e`\n\nA `recursive_generator` is similar to a `generator` except that it is designed to more efficiently\nsupport yielding the elements of a nested sequence as elements of an outer sequence.\n\nIn addition to being able to `co_yield` a value of type `T` you can also `co_yield` a value of type `recursive_generator\u003cT\u003e`.\n\nWhen you `co_yield` a `recursive_generator\u003cT\u003e` value the all elements of the yielded generator are yielded as elements of the current generator.\nThe current coroutine is suspended until the consumer has finished consuming all elements of the nested generator, after which point execution\nof the current coroutine will resume execution to produce the next element.\n\nThe benefit of `recursive_generator\u003cT\u003e` over `generator\u003cT\u003e` for iterating over recursive data-structures is that the `iterator::operator++()`\nis able to directly resume the leaf-most coroutine to produce the next element, rather than having to resume/suspend O(depth) coroutines for each element.\nThe down-side is that there is additional overhead \n\nFor example:\n```c++\n// Lists the immediate contents of a directory.\ncppcoro::generator\u003cdir_entry\u003e list_directory(std::filesystem::path path);\n\ncppcoro::recursive_generator\u003cdir_entry\u003e list_directory_recursive(std::filesystem::path path)\n{\n  for (auto\u0026 entry : list_directory(path))\n  {\n    co_yield entry;\n    if (entry.is_directory())\n    {\n      co_yield list_directory_recursive(entry.path());\n    }\n  }\n}\n```\n\nNote that applying the `fmap()` operator to a `recursive_generator\u003cT\u003e` will yield a `generator\u003cU\u003e`\ntype rather than a `recursive_generator\u003cU\u003e`. This is because uses of `fmap` are generally not used\nin recursive contexts and we try to avoid the extra overhead incurred by `recursive_generator`.\n\n## `async_generator\u003cT\u003e`\n\nAn `async_generator` represents a coroutine type that produces a sequence of values of type, `T`, where values are produced lazily and values may be produced asynchronously.\n\nThe coroutine body is able to use both `co_await` and `co_yield` expressions.\n\nConsumers of the generator can use a `for co_await` range-based for-loop to consume the values.\n\nExample\n```c++\ncppcoro::async_generator\u003cint\u003e ticker(int count, threadpool\u0026 tp)\n{\n  for (int i = 0; i \u003c count; ++i)\n  {\n    co_await tp.delay(std::chrono::seconds(1));\n    co_yield i;\n  }\n}\n\ncppcoro::task\u003c\u003e consumer(threadpool\u0026 tp)\n{\n  auto sequence = ticker(10, tp);\n  for co_await(std::uint32_t i : sequence)\n  {\n    std::cout \u003c\u003c \"Tick \" \u003c\u003c i \u003c\u003c std::endl;\n  }\n}\n```\n\nAPI Summary\n```c++\n// \u003ccppcoro/async_generator.hpp\u003e\nnamespace cppcoro\n{\n  template\u003ctypename T\u003e\n  class async_generator\n  {\n  public:\n\n    class iterator\n    {\n    public:\n      using iterator_tag = std::forward_iterator_tag;\n      using difference_type = std::size_t;\n      using value_type = std::remove_reference_t\u003cT\u003e;\n      using reference = value_type\u0026;\n      using pointer = value_type*;\n      \n      iterator(const iterator\u0026 other) noexcept;\n      iterator\u0026 operator=(const iterator\u0026 other) noexcept;\n\n      // Resumes the generator coroutine if suspended\n      // Returns an operation object that must be awaited to wait\n      // for the increment operation to complete.\n      // If the coroutine runs to completion then the iterator\n      // will subsequently become equal to the end() iterator.\n      // If the coroutine completes with an unhandled exception then\n      // that exception will be rethrown from the co_await expression.\n      Awaitable\u003citerator\u0026\u003e operator++() noexcept;\n\n      // Dereference the iterator.\n      pointer operator-\u003e() const noexcept;\n      reference operator*() const noexcept;\n\n      bool operator==(const iterator\u0026 other) const noexcept;\n      bool operator!=(const iterator\u0026 other) const noexcept;\n    };\n\n    // Construct to the empty sequence.\n    async_generator() noexcept;\n    async_generator(const async_generator\u0026) = delete;\n    async_generator(async_generator\u0026\u0026 other) noexcept;\n    ~async_generator();\n\n    async_generator\u0026 operator=(const async_generator\u0026) = delete;\n    async_generator\u0026 operator=(async_generator\u0026\u0026 other) noexcept;\n\n    void swap(async_generator\u0026 other) noexcept;\n\n    // Starts execution of the coroutine and returns an operation object\n    // that must be awaited to wait for the first value to become available.\n    // The result of co_await'ing the returned object is an iterator that\n    // can be used to advance to subsequent elements of the sequence.\n    //\n    // This method is not valid to be called once the coroutine has\n    // run to completion.\n    Awaitable\u003citerator\u003e begin() noexcept;\n    iterator end() noexcept;\n\n  };\n\n  template\u003ctypename T\u003e\n  void swap(async_generator\u003cT\u003e\u0026 a, async_generator\u003cT\u003e\u0026 b);\n\n  // Apply 'func' to each element of the source generator, yielding a sequence of\n  // the results of calling 'func' on the source elements.\n  template\u003ctypename FUNC, typename T\u003e\n  async_generator\u003cstd::invoke_result_t\u003cFUNC, T\u0026\u003e\u003e fmap(FUNC func, async_generator\u003cT\u003e source);\n}\n```\n\n### Early termination of an async_generator\n\nWhen the `async_generator` object is destructed it requests cancellation of the underlying coroutine.\nIf the coroutine has already run to completion or is currently suspended in a `co_yield` expression\nthen the coroutine is destroyed immediately. Otherwise, the coroutine will continue execution until\nit either runs to completion or reaches the next `co_yield` expression.\n\nWhen the coroutine frame is destroyed the destructors of all variables in scope at that point will be\nexecuted to ensure the resources of the generator are cleaned up.\n\nNote that the caller must ensure that the `async_generator` object must not be destroyed while a\nconsumer coroutine is executing a `co_await` expression waiting for the next item to be produced.\n\n## `single_consumer_event`\n\nThis is a simple manual-reset event type that supports only a single\ncoroutine awaiting it at a time.\nThis can be used to \n\nAPI Summary:\n```c++\n// \u003ccppcoro/single_consumer_event.hpp\u003e\nnamespace cppcoro\n{\n  class single_consumer_event\n  {\n  public:\n    single_consumer_event(bool initiallySet = false) noexcept;\n    bool is_set() const noexcept;\n    void set();\n    void reset() noexcept;\n    Awaiter\u003cvoid\u003e operator co_await() const noexcept;\n  };\n}\n```\n\nExample:\n```c++\n#include \u003ccppcoro/single_consumer_event.hpp\u003e\n\ncppcoro::single_consumer_event event;\nstd::string value;\n\ncppcoro::task\u003c\u003e consumer()\n{\n  // Coroutine will suspend here until some thread calls event.set()\n  // eg. inside the producer() function below.\n  co_await event;\n\n  std::cout \u003c\u003c value \u003c\u003c std::endl;\n}\n\nvoid producer()\n{\n  value = \"foo\";\n\n  // This will resume the consumer() coroutine inside the call to set()\n  // if it is currently suspended.\n  event.set();\n}\n```\n\n## `single_consumer_async_auto_reset_event`\n\nThis class provides an async synchronisation primitive that allows a single coroutine to\nwait until the event is signalled by a call to the `set()` method.\n\nOnce the coroutine that is awaiting the event is released by either a prior or subsequent call to `set()`\nthe event is automatically reset back to the 'not set' state.\n\nThis class is a more efficient version of `async_auto_reset_event` that can be used in cases where\nonly a single coroutine will be awaiting the event at a time. If you need to support multiple concurrent\nawaiting coroutines on the event then use the `async_auto_reset_event` class instead.\n\nAPI Summary:\n```c++\n// \u003ccppcoro/single_consumer_async_auto_reset_event.hpp\u003e\nnamespace cppcoro\n{\n  class single_consumer_async_auto_reset_event\n  {\n  public:\n\n    single_consumer_async_auto_reset_event(\n      bool initiallySet = false) noexcept;\n\n    // Change the event to the 'set' state. If a coroutine is awaiting the\n    // event then the event is immediately transitioned back to the 'not set'\n    // state and the coroutine is resumed.\n    void set() noexcept;\n\n    // Returns an Awaitable type that can be awaited to wait until\n    // the event becomes 'set' via a call to the .set() method. If\n    // the event is already in the 'set' state then the coroutine\n    // continues without suspending.\n    // The event is automatically reset back to the 'not set' state\n    // before resuming the coroutine.\n    Awaiter\u003cvoid\u003e operator co_await() const noexcept;\n\n  };\n}\n```\n\nExample Usage:\n```c++\nstd::atomic\u003cint\u003e value;\ncppcoro::single_consumer_async_auto_reset_event valueDecreasedEvent;\n\ncppcoro::task\u003c\u003e wait_until_value_is_below(int limit)\n{\n  while (value.load(std::memory_order_relaxed) \u003e= limit)\n  {\n    // Wait until there has been some change that we're interested in.\n    co_await valueDecreasedEvent;\n  }\n}\n\nvoid change_value(int delta)\n{\n  value.fetch_add(delta, std::memory_order_relaxed);\n  // Notify the waiter if there has been some change.\n  if (delta \u003c 0) valueDecreasedEvent.set();\n}\n```\n\n## `async_mutex`\n\nProvides a simple mutual exclusion abstraction that allows the caller to 'co_await' the mutex\nfrom within a coroutine to suspend the coroutine until the mutex lock is acquired.\n\nThe implementation is lock-free in that a coroutine that awaits the mutex will not\nblock the thread but will instead suspend the coroutine and later resume it inside\nthe call to `unlock()` by the previous lock-holder.\n\nAPI Summary:\n```c++\n// \u003ccppcoro/async_mutex.hpp\u003e\nnamespace cppcoro\n{\n  class async_mutex_lock;\n  class async_mutex_lock_operation;\n  class async_mutex_scoped_lock_operation;\n\n  class async_mutex\n  {\n  public:\n    async_mutex() noexcept;\n    ~async_mutex();\n\n    async_mutex(const async_mutex\u0026) = delete;\n    async_mutex\u0026 operator(const async_mutex\u0026) = delete;\n\n    bool try_lock() noexcept;\n    async_mutex_lock_operation lock_async() noexcept;\n    async_mutex_scoped_lock_operation scoped_lock_async() noexcept;\n    void unlock();\n  };\n\n  class async_mutex_lock_operation\n  {\n  public:\n    bool await_ready() const noexcept;\n    bool await_suspend(std::experimental::coroutine_handle\u003c\u003e awaiter) noexcept;\n    void await_resume() const noexcept;\n  };\n\n  class async_mutex_scoped_lock_operation\n  {\n  public:\n    bool await_ready() const noexcept;\n    bool await_suspend(std::experimental::coroutine_handle\u003c\u003e awaiter) noexcept;\n    [[nodiscard]] async_mutex_lock await_resume() const noexcept;\n  };\n\n  class async_mutex_lock\n  {\n  public:\n    // Takes ownership of the lock.\n    async_mutex_lock(async_mutex\u0026 mutex, std::adopt_lock_t) noexcept;\n\n    // Transfer ownership of the lock.\n    async_mutex_lock(async_mutex_lock\u0026\u0026 other) noexcept;\n\n    async_mutex_lock(const async_mutex_lock\u0026) = delete;\n    async_mutex_lock\u0026 operator=(const async_mutex_lock\u0026) = delete;\n\n    // Releases the lock by calling unlock() on the mutex.\n    ~async_mutex_lock();\n  };\n}\n```\n\nExample usage:\n```c++\n#include \u003ccppcoro/async_mutex.hpp\u003e\n#include \u003ccppcoro/task.hpp\u003e\n#include \u003cset\u003e\n#include \u003cstring\u003e\n\ncppcoro::async_mutex mutex;\nstd::set\u003cstd::string\u003e values;\n\ncppcoro::task\u003c\u003e add_item(std::string value)\n{\n  cppcoro::async_mutex_lock lock = co_await mutex.scoped_lock_async();\n  values.insert(std::move(value));\n}\n```\n\n## `async_manual_reset_event`\n\nA manual-reset event is a coroutine/thread-synchronisation primitive that allows one or more threads\nto wait until the event is signalled by a thread that calls `set()`.\n\nThe event is in one of two states; *'set'* and *'not set'*.\n\nIf the event is in the *'set'* state when a coroutine awaits the event then the coroutine\ncontinues without suspending. However if the coroutine is in the *'not set'* state then the\ncoroutine is suspended until some thread subsequently calls the `set()` method.\n\nAny threads that were suspended while waiting for the event to become *'set'* will be resumed\ninside the next call to `set()` by some thread.\n\nNote that you must ensure that no coroutines are awaiting a *'not set'* event when the\nevent is destructed as they will not be resumed.\n\nExample:\n```c++\ncppcoro::async_manual_reset_event event;\nstd::string value;\n\nvoid producer()\n{\n  value = get_some_string_value();\n\n  // Publish a value by setting the event.\n  event.set();\n}\n\n// Can be called many times to create many tasks.\n// All consumer tasks will wait until value has been published.\ncppcoro::task\u003c\u003e consumer()\n{\n  // Wait until value has been published by awaiting event.\n  co_await event;\n\n  consume_value(value);\n}\n```\n\nAPI Summary:\n```c++\nnamespace cppcoro\n{\n  class async_manual_reset_event_operation;\n\n  class async_manual_reset_event\n  {\n  public:\n    async_manual_reset_event(bool initiallySet = false) noexcept;\n    ~async_manual_reset_event();\n\n    async_manual_reset_event(const async_manual_reset_event\u0026) = delete;\n    async_manual_reset_event(async_manual_reset_event\u0026\u0026) = delete;\n    async_manual_reset_event\u0026 operator=(const async_manual_reset_event\u0026) = delete;\n    async_manual_reset_event\u0026 operator=(async_manual_reset_event\u0026\u0026) = delete;\n\n    // Wait until the event becomes set.\n    async_manual_reset_event_operation operator co_await() const noexcept;\n\n    bool is_set() const noexcept;\n\n    void set() noexcept;\n\n    void reset() noexcept;\n\n  };\n\n  class async_manual_reset_event_operation\n  {\n  public:\n    async_manual_reset_event_operation(async_manual_reset_event\u0026 event) noexcept;\n\n    bool await_ready() const noexcept;\n    bool await_suspend(std::experimental::coroutine_handle\u003c\u003e awaiter) noexcept;\n    void await_resume() const noexcept;\n  };\n}\n```\n\n## `async_auto_reset_event`\n\nAn auto-reset event is a coroutine/thread-synchronisation primitive that allows one or more threads\nto wait until the event is signalled by a thread by calling `set()`.\n\nOnce a coroutine that is awaiting the event is released by either a prior or subsequent call to `set()`\nthe event is automatically reset back to the 'not set' state.\n\nAPI Summary:\n```c++\n// \u003ccppcoro/async_auto_reset_event.hpp\u003e\nnamespace cppcoro\n{\n  class async_auto_reset_event_operation;\n\n  class async_auto_reset_event\n  {\n  public:\n\n    async_auto_reset_event(bool initiallySet = false) noexcept;\n\n    ~async_auto_reset_event();\n\n    async_auto_reset_event(const async_auto_reset_event\u0026) = delete;\n    async_auto_reset_event(async_auto_reset_event\u0026\u0026) = delete;\n    async_auto_reset_event\u0026 operator=(const async_auto_reset_event\u0026) = delete;\n    async_auto_reset_event\u0026 operator=(async_auto_reset_event\u0026\u0026) = delete;\n\n    // Wait for the event to enter the 'set' state.\n    //\n    // If the event is already 'set' then the event is set to the 'not set'\n    // state and the awaiting coroutine continues without suspending.\n    // Otherwise, the coroutine is suspended and later resumed when some\n    // thread calls 'set()'.\n    //\n    // Note that the coroutine may be resumed inside a call to 'set()'\n    // or inside another thread's call to 'operator co_await()'.\n    async_auto_reset_event_operation operator co_await() const noexcept;\n\n    // Set the state of the event to 'set'.\n    //\n    // If there are pending coroutines awaiting the event then one\n    // pending coroutine is resumed and the state is immediately\n    // set back to the 'not set' state.\n    //\n    // This operation is a no-op if the event was already 'set'.\n    void set() noexcept;\n\n    // Set the state of the event to 'not-set'.\n    //\n    // This is a no-op if the state was already 'not set'.\n    void reset() noexcept;\n\n  };\n\n  class async_auto_reset_event_operation\n  {\n  public:\n    explicit async_auto_reset_event_operation(async_auto_reset_event\u0026 event) noexcept;\n    async_auto_reset_event_operation(const async_auto_reset_event_operation\u0026 other) noexcept;\n\n    bool await_ready() const noexcept;\n    bool await_suspend(std::experimental::coroutine_handle\u003c\u003e awaiter) noexcept;\n    void await_resume() const noexcept;\n\n  };\n}\n```\n\n## `async_latch`\n\nAn async latch is a synchronisation primitive that allows coroutines to asynchronously\nwait until a counter has been decremented to zero.\n\nThe latch is a single-use object. Once the counter reaches zero the latch becomes 'ready'\nand will remain ready until the latch is destroyed.\n\nAPI Summary:\n```c++\n// \u003ccppcoro/async_latch.hpp\u003e\nnamespace cppcoro\n{\n  class async_latch\n  {\n  public:\n\n    // Initialise the latch with the specified count.\n    async_latch(std::ptrdiff_t initialCount) noexcept;\n\n    // Query if the count has reached zero yet.\n    bool is_ready() const noexcept;\n\n    // Decrement the count by n.\n    // This will resume any waiting coroutines if the count reaches zero\n    // as a result of this call.\n    // It is undefined behaviour to decrement the count below zero.\n    void count_down(std::ptrdiff_t n = 1) noexcept;\n\n    // Wait until the latch becomes ready.\n    // If the latch count is not yet zero then the awaiting coroutine will\n    // be suspended and later resumed by a call to count_down() that decrements\n    // the count to zero. If the latch count was already zero then the coroutine\n    // continues without suspending.\n    Awaiter\u003cvoid\u003e operator co_await() const noexcept;\n\n  };\n}\n```\n\n## `cancellation_token`\n\nA `cancellation_token` is a value that can be passed to a function that allows the caller to subsequently communicate a request to cancel the operation to that function.\n\nTo obtain a `cancellation_token` that is able to be cancelled you must first create a `cancellation_source` object.\nThe `cancellation_source::token()` method can be used to manufacture new `cancellation_token` values that are linked to that `cancellation_source` object.\n\nWhen you want to later request cancellation of an operation you have passed a `cancellation_token` to\nyou can call `cancellation_source::request_cancellation()` on an associated `cancellation_source` object.\n\nFunctions can respond to a request for cancellation in one of two ways:\n1. Poll for cancellation at regular intervals by calling either `cancellation_token::is_cancellation_requested()` or `cancellation_token::throw_if_cancellation_requested()`.\n2. Register a callback to be executed when cancellation is requested using the `cancellation_registration` class.\n\nAPI Summary:\n```c++\nnamespace cppcoro\n{\n  class cancellation_source\n  {\n  public:\n    // Construct a new, independently cancellable cancellation source.\n    cancellation_source();\n\n    // Construct a new reference to the same cancellation state.\n    cancellation_source(const cancellation_source\u0026 other) noexcept;\n    cancellation_source(cancellation_source\u0026\u0026 other) noexcept;\n\n    ~cancellation_source();\n\n    cancellation_source\u0026 operator=(const cancellation_source\u0026 other) noexcept;\n    cancellation_source\u0026 operator=(cancellation_source\u0026\u0026 other) noexcept;\n\n    bool is_cancellation_requested() const noexcept;\n    bool can_be_cancelled() const noexcept;\n    void request_cancellation();\n\n    cancellation_token token() const noexcept;\n  };\n\n  class cancellation_token\n  {\n  public:\n    // Construct a token that can't be cancelled.\n    cancellation_token() noexcept;\n\n    cancellation_token(const cancellation_token\u0026 other) noexcept;\n    cancellation_token(cancellation_token\u0026\u0026 other) noexcept;\n\n    ~cancellation_token();\n\n    cancellation_token\u0026 operator=(const cancellation_token\u0026 other) noexcept;\n    cancellation_token\u0026 operator=(cancellation_token\u0026\u0026 other) noexcept;\n\n    bool is_cancellation_requested() const noexcept;\n    void throw_if_cancellation_requested() const;\n\n    // Query if this token can ever have cancellation requested.\n    // Code can use this to take a more efficient code-path in cases\n    // that the operation does not need to handle cancellation.\n    bool can_be_cancelled() const noexcept;\n  };\n\n  // RAII class for registering a callback to be executed if cancellation\n  // is requested on a particular cancellation token.\n  class cancellation_registration\n  {\n  public:\n\n    // Register a callback to be executed if cancellation is requested.\n    // Callback will be called with no arguments on the thread that calls\n    // request_cancellation() if cancellation is not yet requested, or\n    // called immediately if cancellation has already been requested.\n    // Callback must not throw an unhandled exception when called.\n    template\u003ctypename CALLBACK\u003e\n    cancellation_registration(cancellation_token token, CALLBACK\u0026\u0026 callback);\n\n    cancellation_registration(const cancellation_registration\u0026 other) = delete;\n\n    ~cancellation_registration();\n  };\n\n  class operation_cancelled : public std::exception\n  {\n  public:\n    operation_cancelled();\n    const char* what() const override;\n  };\n}\n```\n\nExample: Polling Approach\n```c++\ncppcoro::task\u003c\u003e do_something_async(cppcoro::cancellation_token token)\n{\n  // Explicitly define cancellation points within the function\n  // by calling throw_if_cancellation_requested().\n  token.throw_if_cancellation_requested();\n\n  co_await do_step_1();\n\n  token.throw_if_cancellation_requested();\n\n  do_step_2();\n\n  // Alternatively, you can query if cancellation has been\n  // requested to allow yourself to do some cleanup before\n  // returning.\n  if (token.is_cancellation_requested())\n  {\n    display_message_to_user(\"Cancelling operation...\");\n    do_cleanup();\n    throw cppcoro::operation_cancelled{};\n  }\n\n  do_final_step();\n}\n```\n\nExample: Callback Approach\n```c++\n// Say we already have a timer abstraction that supports being\n// cancelled but it doesn't support cancellation_tokens natively.\n// You can use a cancellation_registration to register a callback\n// that calls the existing cancellation API. e.g.\ncppcoro::task\u003c\u003e cancellable_timer_wait(cppcoro::cancellation_token token)\n{\n  auto timer = create_timer(10s);\n\n  cppcoro::cancellation_registration registration(token, [\u0026]\n  {\n    // Call existing timer cancellation API.\n    timer.cancel();\n  });\n\n  co_await timer;\n}\n```\n\n## `static_thread_pool`\n\nThe `static_thread_pool` class provides an abstraction that lets you schedule work\non a fixed-size pool of threads.\n\nThis class implements the **Scheduler** concept (see below).\n\nYou can enqueue work to the thread-pool by executing `co_await threadPool.schedule()`.\nThis operation will suspend the current coroutine, enqueue it for execution on the\nthread-pool and the thread pool will then resume the coroutine when a thread in the\nthread-pool is next free to run the coroutine. **This operation is guaranteed not\nto throw and, in the common case, will not allocate any memory**.\n\nThis class makes use of a work-stealing algorithm to load-balance work across multiple\nthreads. Work enqueued to the thread-pool from a thread-pool thread will be scheduled\nfor execution on the same thread in a LIFO queue. Work enqueued to the thread-pool from\na remote thread will be enqueued to a global FIFO queue. When a worker thread runs out\nof work from its local queue it first tries to dequeue work from the global queue. If\nthat queue is empty then it next tries to steal work from the back of the queues of\nthe other worker threads.\n\nAPI Summary:\n```c++\nnamespace cppcoro\n{\n  class static_thread_pool\n  {\n  public:\n    // Initialise the thread-pool with a number of threads equal to\n    // std::thread::hardware_concurrency().\n    static_thread_pool();\n\n    // Initialise the thread pool with the specified number of threads.\n    explicit static_thread_pool(std::uint32_t threadCount);\n\n    std::uint32_t thread_count() const noexcept;\n\n    class schedule_operation\n    {\n    public:\n      schedule_operation(static_thread_pool* tp) noexcept;\n\n      bool await_ready() noexcept;\n      bool await_suspend(std::experimental::coroutine_handle\u003c\u003e h) noexcept;\n      bool await_resume() noexcept;\n\n    private:\n      // unspecified\n    };\n\n    // Return an operation that can be awaited by a coroutine.\n    //\n    // \n    [[nodiscard]]\n    schedule_operation schedule() noexcept;\n\n  private:\n\n    // Unspecified\n\n  };\n}\n```\n\nExample usage: Simple\n```c++\ncppcoro::task\u003cstd::string\u003e do_something_on_threadpool(cppcoro::static_thread_pool\u0026 tp)\n{\n  // First schedule the coroutine onto the threadpool.\n  co_await tp.schedule();\n\n  // When it resumes, this coroutine is now running on the threadpool.\n  do_something();\n}\n```\n\nExample usage: Doing things in parallel - using `schedule_on()` operator with `static_thread_pool`.\n```c++\ncppcoro::task\u003cdouble\u003e dot_product(static_thread_pool\u0026 tp, double a[], double b[], size_t count)\n{\n  if (count \u003e 1000)\n  {\n    // Subdivide the work recursively into two equal tasks\n    // The first half is scheduled to the thread pool so it can run concurrently\n    // with the second half which continues on this thread.\n    size_t halfCount = count / 2;\n    auto [first, second] = co_await when_all(\n      schedule_on(tp, dot_product(tp, a, b, halfCount),\n      dot_product(tp, a + halfCount, b + halfCount, count - halfCount));\n    co_return first + second;\n  }\n  else\n  {\n    double sum = 0.0;\n    for (size_t i = 0; i \u003c count; ++i)\n    {\n      sum += a[i] * b[i];\n    }\n    co_return sum;\n  }\n}\n```\n\n## `io_service`\n\nThe `io_service` class provides an abstraction for processing I/O completion events\nfrom asynchronous I/O operations.\n\nWhen an asynchronous I/O operation completes, the coroutine that was awaiting\nthat operation will be resumed on an I/O thread inside a call to one of the\nevent-processing methods: `process_events()`, `process_pending_events()`,\n`process_one_event()` or `process_one_pending_event()`.\n\nThe `io_service` class does not manage any I/O threads.\nYou must ensure that some thread calls one of the event-processing methods for coroutines awaiting I/O\ncompletion events to be dispatched. This can either be a dedicated thread that calls `process_events()`\nor mixed in with some other event loop (e.g. a UI event loop) by periodically polling for new events\nvia a call to `process_pending_events()` or `process_one_pending_event()`.\n\nThis allows integration of the `io_service` event-loop with other event loops, such as a user-interface event loop.\n\nYou can multiplex processing of events across multiple threads by having multiple threads call\n`process_events()`. You can specify a hint as to the maximum number of threads to have actively\nprocessing events via an optional `io_service` constructor parameter.\n\nOn Windows, the implementation makes use of the Windows I/O Completion Port facility to dispatch\nevents to I/O threads in a scalable manner.\n\nAPI Summary:\n```c++\nnamespace cppcoro\n{\n  class io_service\n  {\n  public:\n\n    class schedule_operation;\n    class timed_schedule_operation;\n\n    io_service();\n    io_service(std::uint32_t concurrencyHint);\n\n    io_service(io_service\u0026\u0026) = delete;\n    io_service(const io_service\u0026) = delete;\n    io_service\u0026 operator=(io_service\u0026\u0026) = delete;\n    io_service\u0026 operator=(const io_service\u0026) = delete;\n\n    ~io_service();\n\n    // Scheduler methods\n\n    [[nodiscard]]\n    schedule_operation schedule() noexcept;\n\n    template\u003ctypename REP, typename RATIO\u003e\n    [[nodiscard]]\n    timed_schedule_operation schedule_after(\n      std::chrono::duration\u003cREP, RATIO\u003e delay,\n      cppcoro::cancellation_token cancellationToken = {}) noexcept;\n\n    // Event-loop methods\n    //\n    // I/O threads must call these to process I/O events and execute\n    // scheduled coroutines.\n\n    std::uint64_t process_events();\n    std::uint64_t process_pending_events();\n    std::uint64_t process_one_event();\n    std::uint64_t process_one_pending_event();\n\n    // Request that all threads processing events exit their event loops.\n    void stop() noexcept;\n\n    // Query if some thread has called stop()\n    bool is_stop_requested() const noexcept;\n\n    // Reset the event-loop after a call to stop() so that threads can\n    // start processing events again.\n    void reset();\n\n    // Reference-counting methods for tracking outstanding references\n    // to the io_service.\n    //\n    // The io_service::stop() method will be called when the last work\n    // reference is decremented.\n    //\n    // Use the io_work_scope RAII class to manage calling these methods on\n    // entry-to and exit-from a scope.\n    void notify_work_started() noexcept;\n    void notify_work_finished() noexcept;\n\n  };\n\n  class io_service::schedule_operation\n  {\n  public:\n    schedule_operation(const schedule_operation\u0026) noexcept;\n    schedule_operation\u0026 operator=(const schedule_operation\u0026) noexcept;\n\n    bool await_ready() const noexcept;\n    void await_suspend(std::experimental::coroutine_handle\u003c\u003e awaiter) noexcept;\n    void await_resume() noexcept;\n  };\n\n  class io_service::timed_schedule_operation\n  {\n  public:\n    timed_schedule_operation(timed_schedule_operation\u0026\u0026) noexcept;\n\n    timed_schedule_operation(const timed_schedule_operation\u0026) = delete;\n    timed_schedule_operation\u0026 operator=(const timed_schedule_operation\u0026) = delete;\n    timed_schedule_operation\u0026 operator=(timed_schedule_operation\u0026\u0026) = delete;\n\n    bool await_ready() const noexcept;\n    void await_suspend(std::experimental::coroutine_handle\u003c\u003e awaiter);\n    void await_resume();\n  };\n\n  class io_work_scope\n  {\n  public:\n\n    io_work_scope(io_service\u0026 ioService) noexcept;\n\n    io_work_scope(const io_work_scope\u0026 other) noexcept;\n    io_work_scope(io_work_scope\u0026\u0026 other) noexcept;\n\n    ~io_work_scope();\n\n    io_work_scope\u0026 operator=(const io_work_scope\u0026 other) noexcept;\n    io_work_scope\u0026 operator=(io_work_scope\u0026\u0026 other) noexcept;\n\n    io_service\u0026 service() const noexcept;\n  };\n\n}\n```\n\nExample:\n```c++\n#include \u003ccppcoro/task.hpp\u003e\n#include \u003ccppcoro/task.hpp\u003e\n#include \u003ccppcoro/io_service.hpp\u003e\n#include \u003ccppcoro/read_only_file.hpp\u003e\n\n#include \u003cexperimental/filesystem\u003e\n#include \u003cmemory\u003e\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n\nnamespace fs = std::experimental::filesystem;\n\ncppcoro::task\u003cstd::uint64_t\u003e count_lines(cppcoro::io_service\u0026 ioService, fs::path path)\n{\n  auto file = cppcoro::read_only_file::open(ioService, path);\n\n  constexpr size_t bufferSize = 4096;\n  auto buffer = std::make_unique\u003cstd::uint8_t[]\u003e(bufferSize);\n\n  std::uint64_t newlineCount = 0;\n\n  for (std::uint64_t offset = 0, fileSize = file.size(); offset \u003c fileSize;)\n  {\n    const auto bytesToRead = static_cast\u003csize_t\u003e(\n      std::min\u003cstd::uint64_t\u003e(bufferSize, fileSize - offset));\n\n    const auto bytesRead = co_await file.read(offset, buffer.get(), bytesToRead);\n\n    newlineCount += std::count(buffer.get(), buffer.get() + bytesRead, '\\n');\n\n    offset += bytesRead;\n  }\n\n  co_return newlineCount;\n}\n\ncppcoro::task\u003c\u003e run(cppcoro::io_service\u0026 ioService)\n{\n  cppcoro::io_work_scope ioScope(ioService);\n\n  auto lineCount = co_await count_lines(ioService, fs::path{\"foo.txt\"});\n\n  std::cout \u003c\u003c \"foo.txt has \" \u003c\u003c lineCount \u003c\u003c \" lines.\" \u003c\u003c std::endl;;\n}\n\ncppcoro::task\u003c\u003e process_events(cppcoro::io_service\u0026 ioService)\n{\n  // Process events until the io_service is stopped.\n  // ie. when the last io_work_scope goes out of scope.\n  ioService.process_events();\n  co_return;\n}\n\nint main()\n{\n  cppcoro::io_service ioService;\n\n  cppcoro::sync_wait(cppcoro::when_all_ready(\n    run(ioService),\n    process_events(ioService)));\n\n  return 0;\n}\n```\n\n### `io_service` as a scheduler\n\nAn `io_sevice` class implements the interfaces for the `Scheduler` and `DelayedScheduler` concepts.\n\nThis allows a coroutine to suspend execution on the current thread and schedule itself for resumption\non an I/O thread associated with a particular `io_service` object.\n\nExample:\n```c++\ncppcoro::task\u003c\u003e do_something(cppcoro::io_service\u0026 ioService)\n{\n  // Coroutine starts execution on the thread of the task awaiter.\n\n  // A coroutine can transfer execution to an I/O thread by awaiting the\n  // result of io_service::schedule().\n  co_await ioService.schedule();\n\n  // At this point, the coroutine is now executing on an I/O thread\n  // inside a call to one of the io_service event processing methods.\n\n  // A coroutine can also perform a delayed-schedule that will suspend\n  // the coroutine for a specified duration of time before scheduling\n  // it for resumption on an I/O thread.\n  co_await ioService.schedule_after(100ms);\n\n  // At this point, the coroutine is executing on a potentially different I/O thread.\n}\n```\n\n## `file`, `readable_file`, `writable_file`\n\nThese types are abstract base-classes for performing concrete file I/O.\n\nAPI Summary:\n```c++\nnamespace cppcoro\n{\n  class file_read_operation;\n  class file_write_operation;\n\n  class file\n  {\n  public:\n\n    virtual ~file();\n\n    std::uint64_t size() const;\n\n  protected:\n\n    file(file\u0026\u0026 other) noexcept;\n\n  };\n\n  class readable_file : public virtual file\n  {\n  public:\n\n    [[nodiscard]]\n    file_read_operation read(\n      std::uint64_t offset,\n      void* buffer,\n      std::size_t byteCount,\n      cancellation_token ct = {}) const noexcept;\n\n  };\n\n  class writable_file : public virtual file\n  {\n  public:\n\n    void set_size(std::uint64_t fileSize);\n\n    [[nodiscard]]\n    file_write_operation write(\n      std::uint64_t offset,\n      const void* buffer,\n      std::size_t byteCount,\n      cancellation_token ct = {}) noexcept;\n\n  };\n\n  class file_read_operation\n  {\n  public:\n\n    file_read_operation(file_read_operation\u0026\u0026 other) noexcept;\n\n    bool await_ready() const noexcept;\n    bool await_suspend(std::experimental::coroutine_handle\u003c\u003e awaiter);\n    std::size_t await_resume();\n\n  };\n\n  class file_write_operation\n  {\n  public:\n\n    file_write_operation(file_write_operation\u0026\u0026 other) noexcept;\n\n    bool await_ready() const noexcept;\n    bool await_suspend(std::experimental::coroutine_handle\u003c\u003e awaiter);\n    std::size_t await_resume();\n\n  };\n}\n```\n\n## `read_only_file`, `write_only_file`, `read_write_file`\n\nThese types represent concrete file I/O classes.\n\nAPI Summary:\n```c++\nnamespace cppcoro\n{\n  class read_only_file : public readable_file\n  {\n  public:\n\n    [[nodiscard]]\n    static read_only_file open(\n      io_service\u0026 ioService,\n      const std::experimental::filesystem::path\u0026 path,\n      file_share_mode shareMode = file_share_mode::read,\n      file_buffering_mode bufferingMode = file_buffering_mode::default_);\n\n  };\n\n  class write_only_file : public writable_file\n  {\n  public:\n\n    [[nodiscard]]\n    static write_only_file open(\n      io_service\u0026 ioService,\n      const std::experimental::filesystem::path\u0026 path,\n      file_open_mode openMode = file_open_mode::create_or_open,\n      file_share_mode shareMode = file_share_mode::none,\n      file_buffering_mode bufferingMode = file_buffering_mode::default_);\n\n  };\n\n  class read_write_file : public readable_file, public writable_file\n  {\n  public:\n\n    [[nodiscard]]\n    static read_write_file open(\n      io_service\u0026 ioService,\n      const std::experimental::filesystem::path\u0026 path,\n      file_open_mode openMode = file_open_mode::create_or_open,\n      file_share_mode shareMode = file_share_mode::none,\n      file_buffering_mode bufferingMode = file_buffering_mode::default_);\n\n  };\n}\n```\n\nAll `open()` functions throw `std::system_error` on failure.\n\n# Networking\n\nNOTE: Networking abstractions are currently only supported on the Windows platform.\nLinux support will be coming soon.\n\n## `socket`\n\nThe socket class can be used to send/receive data over the network asynchronously.\n\nCurrently only supports TCP/IP, UDP/IP over IPv4 and IPv6.\n\nAPI Summary:\n```c++\n// \u003ccppcoro/net/socket.hpp\u003e\nnamespace cppcoro::net\n{\n  class socket\n  {\n  public:\n\n    static socket create_tcpv4(ip_service\u0026 ioSvc);\n    static socket create_tcpv6(ip_service\u0026 ioSvc);\n    static socket create_updv4(ip_service\u0026 ioSvc);\n    static socket create_udpv6(ip_service\u0026 ioSvc);\n\n    socket(socket\u0026\u0026 other) noexcept;\n\n    ~socket();\n\n    socket\u0026 operator=(socket\u0026\u0026 other) noexcept;\n\n    // Return the native socket handle for the socket\n    \u003cplatform-specific\u003e native_handle() noexcept;\n\n    const ip_endpoint\u0026 local_endpoint() const noexcept;\n    const ip_endpoint\u0026 remote_endpoint() const noexcept;\n\n    void bind(const ip_endpoint\u0026 localEndPoint);\n\n    void listen();\n\n    [[nodiscard]]\n    Awaitable\u003cvoid\u003e connect(const ip_endpoint\u0026 remoteEndPoint) noexcept;\n    [[nodiscard]]\n    Awaitable\u003cvoid\u003e connect(const ip_endpoint\u0026 remoteEndPoint,\n                            cancellation_token ct) noexcept;\n\n    [[nodiscard]]\n    Awaitable\u003cvoid\u003e accept(socket\u0026 acceptingSocket) noexcept;\n    [[nodiscard]]\n    Awaitable\u003cvoid\u003e accept(socket\u0026 acceptingSocket,\n                           cancellation_token ct) noexcept;\n\n    [[nodiscard]]\n    Awaitable\u003cvoid\u003e disconnect() noexcept;\n    [[nodiscard]]\n    Awaitable\u003cvoid\u003e disconnect(cancellation_token ct) noexcept;\n\n    [[nodiscard]]\n    Awaitable\u003cstd::size_t\u003e send(const void* buffer, std::size_t size) noexcept;\n    [[nodiscard]]\n    Awaitable\u003cstd::size_t\u003e send(const void* buffer,\n                                std::size_t size,\n                                cancellation_token ct) noexcept;\n\n    [[nodiscard]]\n    Awaitable\u003cstd::size_t\u003e recv(void* buffer, std::size_t size) noexcept;\n    [[nodiscard]]\n    Awaitable\u003cstd::size_t\u003e recv(void* buffer,\n                                std::size_t size,\n                                cancellation_token ct) noexcept;\n\n    [[nodiscard]]\n    socket_recv_from_operation recv_from(\n        void* buffer,\n        std::size_t size) noexcept;\n    [[nodiscard]]\n    socket_recv_from_operation_cancellable recv_from(\n        void* buffer,\n        std::size_t size,\n        cancellation_token ct) noexcept;\n\n    [[nodiscard]]\n    socket_send_to_operation send_to(\n        const ip_endpoint\u0026 destination,\n        const void* buffer,\n        std::size_t size) noexcept;\n    [[nodiscard]]\n    socket_send_to_operation_cancellable send_to(\n        const ip_endpoint\u0026 destination,\n        const void* buffer,\n        std::size_t size,\n        cancellation_token ct) noexcept;\n\n    void close_send();\n    void close_recv();\n\n  };\n}\n```\n\nExample: Echo Server\n```c++\n#include \u003ccppcoro/net/socket.hpp\u003e\n#include \u003ccppcoro/io_service.hpp\u003e\n#include \u003ccppcoro/cancellation_source.hpp\u003e\n#include \u003ccppcoro/async_scope.hpp\u003e\n#include \u003ccppcoro/on_scope_exit.hpp\u003e\n\n#include \u003cmemory\u003e\n#include \u003ciostream\u003e\n\ncppcoro::task\u003cvoid\u003e handle_connection(socket s)\n{\n  try\n  {\n    const size_t bufferSize = 16384;\n    auto buffer = std::make_unique\u003cunsigned char[]\u003e(bufferSize);\n    size_t bytesRead;\n    do {\n      // Read some bytes\n      bytesRead = co_await s.recv(buffer.get(), bufferSize);\n\n      // Write some bytes\n      size_t bytesWritten = 0;\n      while (bytesWritten \u003c bytesRead) {\n        bytesWritten += co_await s.send(\n          buffer.get() + bytesWritten,\n          bytesRead - bytesWritten);\n      }\n    } while (bytesRead != 0);\n\n    s.close_send();\n\n    co_await s.disconnect();\n  }\n  catch (...)\n  {\n    std::cout \u003c\u003c \"connection failed\" \u003c\u003c std::\n  }\n}\n\ncppcoro::task\u003cvoid\u003e echo_server(\n  cppcoro::net::ipv4_endpoint endpoint,\n  cppcoro::io_service\u0026 ioSvc,\n  cancellation_token ct)\n{\n  cppcoro::async_scope scope;\n\n  std::exception_ptr ex;\n  try\n  {\n    auto listeningSocket = cppcoro::net::socket::create_tcpv4(ioSvc);\n    listeningSocket.bind(endpoint);\n    listeningSocket.listen();\n\n    while (true) {\n      auto connection = cppcoro::net::socket::create_tcpv4(ioSvc);\n      co_await listeningSocket.accept(connection, ct);\n      scope.spawn(handle_connection(std::move(connection)));\n    }\n  }\n  catch (cppcoro::operation_cancelled)\n  {\n  }\n  catch (...)\n  {\n    ex = std::current_exception();\n  }\n\n  // Wait until all handle_connection tasks have finished.\n  co_await scope.join();\n\n  if (ex) std::rethrow_exception(ex);\n}\n\nint main(int argc, const char* argv[])\n{\n    cppcoro::io_service ioSvc;\n\n    if (argc != 2) return -1;\n\n    auto endpoint = cppcoro::ipv4_endpoint::from_string(argv[1]);\n    if (!endpoint) return -1;\n\n    (void)cppcoro::sync_wait(cppcoro::when_all(\n        [\u0026]() -\u003e task\u003c\u003e\n        {\n            // Shutdown the event loop once finished.\n            auto stopOnExit = cppcoro::on_scope_exit([\u0026] { ioSvc.stop(); });\n\n            cppcoro::cancellation_source canceller;\n            co_await cppcoro::when_all(\n                [\u0026]() -\u003e task\u003c\u003e\n                {\n                    // Run for 30s then stop accepting new connections.\n                    co_await ioSvc.schedule_after(std::chrono::seconds(30));\n                    canceller.request_cancellation();\n                }(),\n                echo_server(*endpoint, ioSvc, canceller.token()));\n        }(),\n        [\u0026]() -\u003e task\u003c\u003e\n        {\n            ioSvc.process_events();\n        }()));\n\n    return 0;\n}\n```\n\n## `ip_address`, `ipv4_address`, `ipv6_address`\n\nHelper classes for representing an IP address.\n\nAPI Synopsis:\n```c++\nnamespace cppcoro::net\n{\n  class ipv4_address\n  {\n    using bytes_t = std::uint8_t[4];\n  public:\n    constexpr ipv4_address();\n    explicit constexpr ipv4_address(std::uint32_t integer);\n    explicit constexpr ipv4_address(const std::uint8_t(\u0026bytes)[4]);\n    explicit constexpr ipv4_address(std::uint8_t b0,\n                                    std::uint8_t b1,\n                                    std::uint8_t b2,\n                                    std::uint8_t b3);\n\n    constexpr const bytes_t\u0026 bytes() const;\n\n    cosntexpr std::uint32_t to_integer() const;\n\n    static constexpr ipv4_address loopback();\n\n    constexpr bool is_loopback() const;\n    constexpr bool is_private_network() const;\n\n    constexpr bool operator==(ipv4_address other) const;\n    constexpr bool operator!=(ipv4_address other) const;\n    constexpr bool operator\u003c(ipv4_address other) const;\n    constexpr bool operator\u003e(ipv4_address other) const;\n    constexpr bool operator\u003c=(ipv4_address other) const;\n    constexpr bool operator\u003e=(ipv4_address other) const;\n\n    std::string to_string();\n\n    static std::optional\u003cipv4_address\u003e from_string(std::string_view string) noexcept;\n  };\n\n  class ipv6_address\n  {\n    using bytes_t = std::uint8_t[16];\n  public:\n    constexpr ipv6_address();\n\n    explicit constexpr ipv6_address(\n      std::uint64_t subnetPrefix,\n      std::uint64_t interfaceIdentifier);\n\n    constexpr ipv6_address(\n      std::uint16_t part0,\n      std::uint16_t part1,\n      std::uint16_t part2,\n      std::uint16_t part3,\n      std::uint16_t part4,\n      std::uint16_t part5,\n      std::uint16_t part6,\n      std::uint16_t part7);\n\n    explicit constexpr ipv6_address(\n        const std::uint16_t(\u0026parts)[8]);\n\n    explicit constexpr ipv6_address(\n        const std::uint8_t(bytes)[16]);\n\n    constexpr const bytes_t\u0026 bytes() const;\n\n    constexpr std::uint64_t subnet_prefix() const;\n    constexpr std::uint64_t interface_identifier() const;\n\n    static constexpr ipv6_address unspecified();\n    static constexpr ipv6_address loopback();\n\n    static std::optional\u003cipv6_address\u003e from_string(std::string_view string) noexcept;\n\n    std::string to_string() const;\n\n    constexpr bool operator==(const ipv6_address\u0026 other) const;\n    constexpr bool operator!=(const ipv6_address\u0026 other) const;\n    constexpr bool operator\u003c(const ipv6_address\u0026 other) const;\n    constexpr bool operator\u003e(const ipv6_address\u0026 other) const;\n    constexpr bool operator\u003c=(const ipv6_address\u0026 other) const;\n    constexpr bool operator\u003e=(const ipv6_address\u0026 other) const;\n\n  };\n\n  class ip_address\n  {\n  public:\n\n    // Constructs to IPv4 address 0.0.0.0\n    ip_address() noexcept;\n\n    ip_address(ipv4_address address) noexcept;\n    ip_address(ipv6_address address) noexcept;\n\n    bool is_ipv4() const noexcept;\n    bool is_ipv6() const noexcept;\n\n    const ipv4_address\u0026 to_ipv4() const;\n    const ipv6_address\u0026 to_ipv6() const;\n\n    const std::uint8_t* bytes() const noexcept;\n\n    std::string to_string() const;\n\n    static std::optional\u003cip_address\u003e from_string(std::string_view string) noexcept;\n\n    bool operator==(const ip_address\u0026 rhs) const noexcept;\n    bool operator!=(const ip_address\u0026 rhs) const noexcept;\n\n    //  ipv4_address sorts less than ipv6_address\n    bool operator\u003c(const ip_address\u0026 rhs) const noexcept;\n    bool operator\u003e(const ip_address\u0026 rhs) const noexcept;\n    bool operator\u003c=(const ip_address\u0026 rhs) const noexcept;\n    bool operator\u003e=(const ip_address\u0026 rhs) const noexcept;\n\n  };\n}\n```\n\n## `ip_endpoint`, `ipv4_endpoint` `ipv6_endpoint`\n\nHelper classes for representing an IP address and port-number.\n\nAPI Synopsis:\n```c++\nnamespace cppcoro::net\n{\n  class ipv4_endpoint\n  {\n  public:\n    ipv4_endpoint() noexcept;\n    explicit ipv4_endpoint(ipv4_address address, std::uint16_t port = 0) noexcept;\n\n    const ipv4_address\u0026 address() const noexcept;\n    std::uint16_t port() const noexcept;\n\n    std::string to_string() const;\n    static std::optional\u003cipv4_endpoint\u003e from_string(std::string_view string) noexcept;\n  };\n\n  bool operator==(const ipv4_endpoint\u0026 a, const ipv4_endpoint\u0026 b);\n  bool operator!=(const ipv4_endpoint\u0026 a, const ipv4_endpoint\u0026 b);\n  bool operator\u003c(const ipv4_endpoint\u0026 a, const ipv4_endpoint\u0026 b);\n  bool operator\u003e(const ipv4_endpoint\u0026 a, const ipv4_endpoint\u0026 b);\n  bool operator\u003c=(const ipv4_endpoint\u0026 a, const ipv4_endpoint\u0026 b);\n  bool operator\u003e=(const ipv4_endpoint\u0026 a, const ipv4_endpoint\u0026 b);\n\n  class ipv6_endpoint\n  {\n  public:\n    ipv6_endpoint() noexcept;\n    explicit ipv6_endpoint(ipv6_address address, std::uint16_t port = 0) noexcept;\n\n    const ipv6_address\u0026 address() const noexcept;\n    std::uint16_t port() const noexcept;\n\n    std::string to_string() const;\n    static std::optional\u003cipv6_endpoint\u003e from_string(std::string_view string) noexcept;\n  };\n\n  bool operator==(const ipv6_endpoint\u0026 a, const ipv6_endpoint\u0026 b);\n  bool operator!=(const ipv6_endpoint\u0026 a, const ipv6_endpoint\u0026 b);\n  bool operator\u003c(const ipv6_endpoint\u0026 a, const ipv6_endpoint\u0026 b);\n  bool operator\u003e(const ipv6_endpoint\u0026 a, const ipv6_endpoint\u0026 b);\n  bool operator\u003c=(const ipv6_endpoint\u0026 a, const ipv6_endpoint\u0026 b);\n  bool operator\u003e=(const ipv6_endpoint\u0026 a, const ipv6_endpoint\u0026 b);\n\n  class ip_endpoint\n  {\n  public:\n     // Constructs to IPv4 end-point 0.0.0.0:0\n     ip_endpoint() noexcept;\n\n     ip_endpoint(ipv4_endpoint endpoint) noexcept;\n     ip_endpoint(ipv6_endpoint endpoint) noexcept;\n\n     bool is_ipv4() const noexcept;\n     bool is_ipv6() const noexcept;\n\n     const ipv4_endpoint\u0026 to_ipv4() const;\n     const ipv6_endpoint\u0026 to_ipv6() const;\n\n     ip_address address() const noexcept;\n     std::uint16_t port() const noexcept;\n\n     std::string to_string() const;\n\n     static std::optional\u003cip_endpoint\u003e from_string(std::string_view string) noexcept;\n\n     bool operator==(const ip_endpoint\u0026 rhs) const noexcept;\n     bool operator!=(const ip_endpoint\u0026 rhs) const noexcept;\n\n     //  ipv4_endpoint sorts less than ipv6_endpoint\n     bool operator\u003c(const ip_endpoint\u0026 rhs) const noexcept;\n     bool operator\u003e(const ip_endpoint\u0026 rhs) const noexcept;\n     bool operator\u003c=(const ip_endpoint\u0026 rhs) const noexcept;\n     bool operator\u003e=(const ip_endpoint\u0026 rhs) const noexcept;\n  };\n}\n```\n\n# Functions\n\n## `sync_wait()`\n\nThe `sync_wait()`function can be used to synchronously wait until the specified `awaitable`\ncompletes.\n\nThe specified awaitable will be `co_await`ed on current thread inside a newly created coroutine.\n\nThe `sync_wait()` call will block until the operation completes and will return the result of\nthe `co_await` expression or rethrow the exception if the `co_await` expression completed with\nan unhandled exception.\n\nThe `sync_wait()` function is mostly useful for starting a top-level task from within `main()`\nand waiting until the task finishes, in practise it is the only way to start the first/top-level\n`task`.\n\nAPI Summary:\n```c++\n// \u003ccppcoro/sync_wait.hpp\u003e\nnamespace cppcoro\n{\n  template\u003ctypename AWAITABLE\u003e\n  auto sync_wait(AWAITABLE\u0026\u0026 awaitable)\n    -\u003e typename awaitable_traits\u003cAWAITABLE\u0026\u0026\u003e::await_result_t;\n}\n```\n\nExamples:\n```c++\nvoid example_task()\n{\n  auto makeTask = []() -\u003e task\u003cstd::string\u003e\n  {\n    co_return \"foo\";\n  };\n\n  auto task = makeTask();\n\n  // start the lazy task and wait until it completes\n  sync_wait(task); // -\u003e \"foo\"\n  sync_wait(makeTask()); // -\u003e \"foo\"\n}\n\nvoid example_shared_task()\n{\n  auto makeTask = []() -\u003e shared_task\u003cstd::string\u003e\n  {\n    co_return \"foo\";\n  };\n\n  auto task = makeTask();\n  // start the shared task and wait until it completes\n  sync_wait(task) == \"foo\";\n  sync_wait(makeTask()) == \"foo\";\n}\n```\n\n## `when_all_ready()`\n\nThe `when_all_ready()` function can be used to create a new awaitable that completes when\nall of the input awaitables complete.\n\nInput tasks can be any type of awaitable.\n\nWhen the returned awaitable is `co_await`ed it will `co_await` each of the input awaitables\nin turn on the awaiting thread in the order they are passed to the `when_all_ready()`\nfunction. If these tasks to not complete synchronously then they will execute concurrently.\n\nOnce all of the `co_await` expressions on input awaitables have run to completion the\nreturned awaitable will complete and resume the awaiting coroutine. The awaiting coroutine\nwill be resumed on the thread of the input awaitable that is last to complete.\n\nThe returned awaitable is guaranteed not to throw an exception when `co_await`ed,\neven if some of the input awaitables fail with an unhandled exception.\n\nNote, however, that the `when_all_ready()` call itself may throw `std::bad_alloc` if it\nwas unable to allocate memory for the coroutine frames required to await each of the\ninput awaitables. It may also throw an exception if any of the input awaitable objects\nthrow from their copy/move constructors.\n\nThe result of `co_await`ing the returned awaitable is a `std::tuple` or `std::vector`\nof `when_all_task\u003cRESULT\u003e` objects. These objects allow you to obtain the result (or exception)\nof each input awaitable separately by calling the `when_all_task\u003cRESULT\u003e::result()`\nmethod of the corresponding output task.\nThis allows the caller to concurrently await multiple awaitables and synchronise on\ntheir completion while still retaining the ability to subsequently inspect the results of\neach of the `co_await` operations for success/failure.\n\nThis differs from `when_all()` where the failure of any individual `co_await` operation\ncauses the overall operation to fail with an exception. This means you cannot determine\nwhich of the component `co_await` operations failed and also prevents you from obtaining\nthe results of the other `co_await` operations.\n\nAPI summary:\n```c++\n// \u003ccppcoro/when_all_ready.hpp\u003e\nnamespace cppcoro\n{\n  // Concurrently await multiple awaitables.\n  //\n  // Returns an awaitable object that, when co_await'ed, will co_await each of the input\n  // awaitable objects and will resume the awaiting coroutine only when all of the\n  // component co_await operations complete.\n  //\n  // Result of co_await'ing the returned awaitable is a std::tuple of detail::when_all_task\u003cT\u003e,\n  // one for each input awaitable and where T is the result-type of the co_await expression\n  // on the corresponding awaitable.\n  //\n  // AWAITABLES must be awaitable types and must be movable (if passed as rvalue) or copyable\n  // (if passed as lvalue). The co_await expression will be executed on an rvalue of the\n  // copied awaitable.\n  template\u003ctypename... AWAITABLES\u003e\n  auto when_all_ready(AWAITABLES\u0026\u0026... awaitables)\n    -\u003e Awaitable\u003cstd::tuple\u003cdetail::when_all_task\u003ctypename awaitable_traits\u003cAWAITABLES\u003e::await_result_t\u003e...\u003e\u003e;\n\n  // Concurrently await each awaitable in a vector of input awaitables.\n  template\u003c\n    typename AWAITABLE,\n    typename RESULT = typename awaitable_traits\u003cAWAITABLE\u003e::await_result_t\u003e\n  auto when_all_ready(std::vector\u003cAWAITABLE\u003e awaitables)\n    -\u003e Awaitable\u003cstd::vector\u003cdetail::when_all_task\u003cRESULT\u003e\u003e\u003e;\n}\n```\n\nExample usage:\n```c++\ntask\u003cstd::string\u003e get_record(int id);\n\ntask\u003c\u003e example1()\n{\n  // Run 3 get_record() operations concurrently and wait until they're all ready.\n  // Returns a std::tuple of tasks that can be unpacked using structured bindings.\n  auto [task1, task2, task3] = co_await when_all_ready(\n    get_record(123),\n    get_record(456),\n    get_record(789));\n\n  // Unpack the result of each task\n  std::string\u0026 record1 = task1.result();\n  std::string\u0026 record2 = task2.result();\n  std::string\u0026 record3 = task3.result();\n\n  // Use records....\n}\n\ntask\u003c\u003e example2()\n{\n  // Create the input tasks. They don't start executing yet.\n  std::vector\u003ctask\u003cstd::string\u003e\u003e tasks;\n  for (int i = 0; i \u003c 1000; ++i)\n  {\n    tasks.emplace_back(get_record(i));\n  }\n\n  // Execute all tasks concurrently.\n  std::vector\u003cdetail::when_all_task\u003cstd::string\u003e\u003e resultTasks =\n    co_await when_all_ready(std::move(tasks));\n\n  // Unpack and handle each result individually once they're all complete.\n  for (int i = 0; i \u003c 1000; ++i)\n  {\n    try\n    {\n      std::string\u0026 record = tasks[i].result();\n      std::cout \u003c\u003c i \u003c\u003c \" = \" \u003c\u003c record \u003c\u003c std::endl;\n    }\n    catch (const std::exception\u0026 ex)\n    {\n      std::cout \u003c\u003c i \u003c\u003c \" : \" \u003c\u003c ex.what() \u003c\u003c std::endl;\n    }\n  }\n}\n```\n\n## `when_all()`\n\nThe `when_all()` function can be used to create a new Awaitable that when `co_await`ed\nwill `co_await` each of the input awaitables concurrently and return an aggregate of\ntheir individual results.\n\nWhen the returned awaitable is awaited, it will `co_await` each of the input awaitables\non the current thread. Once the first awaitable suspends, the second task will be started,\nand so on. The operations execute concurrently until they have all run to completion.\n\nOnce all component `co_await` operations have run to completion, an aggregate of the\nresults is constructed from each individual result. If an exception is thrown by any\nof the input tasks or if the construction of the aggregate result throws an exception\nthen the exception will propagate out of the `co_await` of the returned awaitable.\n\nIf multiple `co_await` operations fail with an exception then one of the exceptions\nwill propagate out of the `co_await when_all()` expression the other exceptions will be silently\nignored. It is not specified which operation's exception will be chosen.\n\nIf it is important to know which component `co_await` operation failed or to retain\nthe ability to obtain results of other operations even if some of them fail then you\nyou should use `when_all_ready()` instead.\n\nAPI Summary:\n```c++\n// \u003ccppcoro/when_all.hpp\u003e\nnamespace cppcoro\n{\n  // Variadic version.\n  //\n  // Note that if the result of `co_await awaitable` yields a void-type\n  // for some awaitables then the corresponding component for that awaitable\n  // in the tuple will be an empty struct of type detail::void_value.\n  template\u003ctypename... AWAITABLES\u003e\n  auto when_all(AWAITABLES\u0026\u0026... awaitables)\n    -\u003e Awaitable\u003cstd::tuple\u003ctypename awaitable_traits\u003cAWAITABLES\u003e::await_result_t...\u003e\u003e;\n\n  // Overload for vector\u003cAwaitable\u003cvoid\u003e\u003e.\n  template\u003c\n    typename AWAITABLE,\n    typename RESULT = typename awaitable_traits\u003cAWAITABLE\u003e::await_result_t,\n    std::enable_if_t\u003cstd::is_void_v\u003cRESULT\u003e, int\u003e = 0\u003e\n  auto when_all(std::vector\u003cAWAITABLE\u003e awaitables)\n    -\u003e Awaitable\u003cvoid\u003e;\n\n  // Overload for vector\u003cAwaitable\u003cNonVoid\u003e\u003e that yield a value when awaited.\n  template\u003c\n    typename AWAITABLE,\n    typename RESULT = typename awaitable_traits\u003cAWAITABLE\u003e::await_result_t,\n    std::enable_if_t\u003c!std::is_void_v\u003cRESULT\u003e, int\u003e = 0\u003e\n  auto when_all(std::vector\u003cAWAITABLE\u003e awaitables)\n    -\u003e Awaitable\u003cstd::vector\u003cstd::conditional_t\u003c\n         std::is_lvalue_reference_v\u003cRESULT\u003e,\n         std::reference_wrapper\u003cstd::remove_reference_t\u003cRESULT\u003e\u003e,\n         std::remove_reference_t\u003cRESULT\u003e\u003e\u003e\u003e;\n}\n```\n\nExamples:\n```c++\ntask\u003cA\u003e get_a();\ntask\u003cB\u003e get_b();\n\ntask\u003c\u003e example1()\n{\n  // Run get_a() and get_b() concurrently.\n  // Task yields a std::tuple\u003cA, B\u003e which can be unpacked using structured bindings.\n  auto [a, b] = co_await when_all(get_a(), get_b());\n\n  // use a, b\n}\n\ntask\u003cstd::string\u003e get_record(int id);\n\ntask\u003c\u003e example2()\n{\n  std::vector\u003ctask\u003cstd::string\u003e\u003e tasks;\n  for (int i = 0; i \u003c 1000; ++i)\n  {\n    tasks.emplace_back(get_record(i));\n  }\n\n  // Concurrently execute all get_record() tasks.\n  // If any of them fail with an exception then the exception will propagate\n  // out of the co_await expression once they have all completed.\n  std::vector\u003cstd::string\u003e records = co_await when_all(std::move(tasks));\n\n  // Process results\n  for (int i = 0; i \u003c 1000; ++i)\n  {\n    std::cout \u003c\u003c i \u003c\u003c \" = \" \u003c\u003c records[i] \u003c\u003c std::endl;\n  }\n}\n```\n\n## `fmap()`\n\nThe `fmap()` function can be used to apply a callable function to the value(s) contained within\na container-type, returning a new container-type of the results of applying the function the\ncontained value(s).\n\nThe `fmap()` function can apply a function to values of type `generator\u003cT\u003e`, `recursive_generator\u003cT\u003e`\nand `async_generator\u003cT\u003e` as well as any value that supports the `Awaitable` concept (eg. `task\u003cT\u003e`).\n\nEach of these types provides an overload for `fmap()` that takes two arguments; a function to apply\nand the container value.\nSee documentation for each type for the supported `fmap()` overloads.\n\nFor example, the `fmap()` function can be used to apply a function to the eventual result of\na `task\u003cT\u003e`, producing a new `task\u003cU\u003e` that will complete with the return-value of the function.\n```c++\n// Given a function you want to apply that converts\n// a value of type A to value of type B.\nB a_to_b(A value);\n\n// And a task that yields a value of type A\ncppcoro::task\u003cA\u003e get_an_a();\n\n// We can apply the function to the result of the task using fmap()\n// and obtain a new task yielding the result.\ncppcoro::task\u003cB\u003e bTask = fmap(a_to_b, get_an_a());\n\n// An alternative syntax is to use the pipe notation.\ncppcoro::task\u003cB\u003e bTask = get_an_a() | cppcoro::fmap(a_to_b);\n```\n\nAPI Summary:\n```c++\n// \u003ccppcoro/fmap.hpp\u003e\nnamespace cppcoro\n{\n  template\u003ctypename FUNC\u003e\n  struct fmap_transform\n  {\n    fmap_transform(FUNC\u0026\u0026 func) noexcept(std::is_nothrow_move_constructible_v\u003cFUNC\u003e);\n    FUNC func;\n  };\n\n  // Type-deducing constructor for fmap_transform object that can be used\n  // in conjunction with operator|.\n  template\u003ctypename FUNC\u003e\n  fmap_transform\u003cFUNC\u003e fmap(FUNC\u0026\u0026 func);\n\n  // operator| overloads for providing pipe-based syntactic sugar for fmap()\n  // such that the expression:\n  //   \u003cvalue-expr\u003e | cppcoro::fmap(\u003cfunc-expr\u003e)\n  // is equivalent to:\n  //   fmap(\u003cfunc-expr\u003e, \u003cvalue-expr\u003e)\n\n  template\u003ctypename T, typename FUNC\u003e\n  decltype(auto) operator|(T\u0026\u0026 value, fmap_transform\u003cFUNC\u003e\u0026\u0026 transform);\n\n  template\u003ctypename T, typename FUNC\u003e\n  decltype(auto) operator|(T\u0026\u0026 value, fmap_transform\u003cFUNC\u003e\u0026 transform);\n\n  template\u003ctypename T, typename FUNC\u003e\n  decltype(auto) operator|(T\u0026\u0026 value, const fmap_transform\u003cFUNC\u003e\u0026 transform);\n\n  // Generic overload for all awaitable types.\n  //\n  // Returns an awaitable that when co_awaited, co_awaits the specified awaitable\n  // and applies the specified func to the result of the 'co_await awaitable'\n  // expression as if by 'std::invoke(func, co_await awaitable)'.\n  //\n  // If the type of 'co_await awaitable' expression is 'void' then co_awaiting the\n  // returned awaitable is equivalent to 'co_await awaitable, func()'.\n  template\u003c\n    typename FUNC,\n    typename AWAITABLE,\n    std::enable_if_t\u003cis_awaitable_v\u003cAWAITABLE\u003e, int\u003e = 0\u003e\n  auto fmap(FUNC\u0026\u0026 func, AWAITABLE\u0026\u0026 awaitable)\n    -\u003e Awaitable\u003cstd::invoke_result_t\u003cFUNC, typename awaitable_traits\u003cAWAITABLE\u003e::await_result_t\u003e\u003e;\n}\n```\n\nThe `fmap()` function is designed to look up the correct overload by argument-dependent\nlookup (ADL) so it should generally be called without the `cppcoro::` prefix.\n\n## `resume_on()`\n\nThe `resume_on()` function can be used to control the execution context that an awaitable\nwill resume the awaiting coroutine on when awaited. When applied to an `async_generator`\nit controls which execution context the `co_await g.begin()` and `co_await ++it` operations\nresume the awaiting coroutines on.\n\nNormally, the awaiting coroutine of an awaitable (eg. a `task`) or `async_generator` will\nresume execution on whatever thread the operation completed on. In some cases this may not\nbe the thread that you want to continue executing on. In these cases you can use the\n`resume_on()` function to create a new awaitable or generator that will resume execution\non a thread associated with a specified scheduler.\n\nThe `resume_on()` function can be used either as a normal function returning a new awaitable/generator.\nOr it can be used in a pipeline-syntax.\n\nExample:\n```c++\ntask\u003crecord\u003e load_record(int id);\n\nui_thread_scheduler uiThreadScheduler;\n\ntask\u003c\u003e example()\n{\n  // This will start load_record() on the current thread.\n  // Then when load_record() completes (probably on an I/O thread)\n  // it will reschedule execution onto thread pool and call to_json\n  // Once to_json completes it will transfer execution onto the\n  // ui thread before resuming this coroutine and returning the json text.\n  task\u003cstd::string\u003e jsonTask =\n    load_record(123)\n    | cppcoro::resume_on(threadpool::default())\n    | cppcoro::fmap(to_json)\n    | cppcoro::resume_on(uiThreadScheduler);\n\n  // At this point, all we've done is create a pipeline of tasks.\n  // The tasks haven't started executing yet.\n\n  // Await the result. Starts the pipeline of tasks.\n  std::string jsonText = co_await jsonTask;\n\n  // Guaranteed to be executing on ui thread here.\n\n  someUiControl.set_text(jsonText);\n}\n```\n\nAPI Summary:\n```c++\n// \u003ccppcoro/resume_on.hpp\u003e\nnamespace cppcoro\n{\n  template\u003ctypename SCHEDULER, typename AWAITABLE\u003e\n  auto resume_on(SCHEDULER\u0026 scheduler, AWAITABLE awaitable)\n    -\u003e Awaitable\u003ctypename awaitable_traits\u003cAWAITABLE\u003e::await_traits_t\u003e;\n\n  template\u003ctypename SCHEDULER, typename T\u003e\n  async_generator\u003cT\u003e resume_on(SCHEDULER\u0026 scheduler, async_generator\u003cT\u003e source);\n\n  template\u003ctypename SCHEDULER\u003e\n  struct resume_on_transform\n  {\n    explicit resume_on_transform(SCHEDULER\u0026 scheduler) noexcept;\n    SCHEDULER\u0026 scheduler;\n  };\n\n  // Construct a transform/operation that can be applied to a source object\n  // using \"pipe\" notation (ie. operator|).\n  template\u003ctypename SCHEDULER\u003e\n  resume_on_transform\u003cSCHEDULER\u003e resume_on(SCHEDULER\u0026 scheduler) noexcept;\n\n  // Equivalent to 'resume_on(transform.scheduler, std::forward\u003cT\u003e(value))'\n  template\u003ctypename T, typename SCHEDULER\u003e\n  decltype(auto) operator|(T\u0026\u0026 value, resume_on_transform\u003cSCHEDULER\u003e transform)\n  {\n    return resume_on(transform.scheduler, std::forward\u003cT\u003e(value));\n  }\n}\n```\n\n## `schedule_on()`\n\nThe `schedule_on()` function can be used to change the execution context that a given\nawaitable or `async_generator` starts executing on.\n\nWhen applied to an `async_generator` it also affects which execution context it resumes\non after `co_yield` statement.\n\nNote that the `schedule_on` transform does not specify the thread that the awaitable or\n`async_generator` will complete or yield results on, that is up to the implementation of\nthe awaitable or generator.\n\nSee the `resume_on()` operator for a transform that controls the thread the operation completes on.\n\nFor example:\n```c++\ntask\u003cint\u003e get_value();\nio_service ioSvc;\n\ntask\u003c\u003e example()\n{\n  // Starts executing get_value() on the current thread.\n  int a = co_await get_value();\n\n  // Starts executing get_value() on a thread associated with ioSvc.\n  int b = co_await schedule_on(ioSvc, get_value());\n}\n```\n\nAPI Summary:\n```c++\n// \u003ccppcoro/schedule_on.hpp\u003e\nnamespace cppcoro\n{\n  // Return a task that yields the same result as 't' but that\n  // ensures that 't' is co_await'ed on a thread associated with\n  // the specified scheduler. Resulting task will complete on\n  // whatever thread 't' would normally complete on.\n  template\u003ctypename SCHEDULER, typename AWAITABLE\u003e\n  auto schedule_on(SCHEDULER\u0026 scheduler, AWAITABLE awaitable)\n    -\u003e Awaitable\u003ctypename awaitable_traits\u003cAWAITABLE\u003e::await_result_t\u003e;\n\n  // Return a generator that yields the same sequence of results as\n  // 'source' but that ensures that execution of the coroutine starts\n  // execution on a thread associated with 'scheduler' and resumes\n  // after a 'co_yield' on a thread associated with 'scheduler'.\n  template\u003ctypename SCHEDULER, typename T\u003e\n  async_generator\u003cT\u003e schedule_on(SCHEDULER\u0026 scheduler, async_generator\u003cT\u003e source);\n\n  template\u003ctypename SCHEDULER\u003e\n  struct schedule_on_transform\n  {\n    explicit schedule_on_transform(SCHEDULER\u0026 scheduler) noexcept;\n    SCHEDULER\u0026 scheduler;\n  };\n\n  template\u003ctypename SCHEDULER\u003e\n  schedule_on_transform\u003cSCHEDULER\u003e schedule_on(SCHEDULER\u0026 scheduler) noexcept;\n\n  template\u003ctypename T, typename SCHEDULER\u003e\n  decltype(auto) operator|(T\u0026\u0026 value, schedule_on_transform\u003cSCHEDULER\u003e transform);\n}\n```\n\n# Metafunctions\n\n## `awaitable_traits\u003cT\u003e`\n\nThis template metafunction can be used to determine what the resulting type of a `co_await` expression\nwill be if applied to an expression of type `T`.\n\nNote that this assumes the value of type `T` is being awaited in a context where it is unaffected by\nany `await_transform` applied by the coroutine's promise object. The results may differ if a value\nof type `T` is awaited in such a context.\n\nThe `awaitable_traits\u003cT\u003e` template metafunction does not define the `awaiter_t` or `await_result_t`\nnested typedefs if type, `T`, is not awaitable. This allows its use in SFINAE contexts that disables\noverloads when `T` is not awaitable.\n\nAPI Summary:\n```c++\n// \u003ccppcoro/awaitable_traits.hpp\u003e\nnamespace cppcoro\n{\n  template\u003ctypename T\u003e\n  struct awaitable_traits\n  {\n    // The type that results from applying `operator co_await()` to a value\n    // of type T, if T supports an `operator co_await()`, otherwise is type `T\u0026\u0026`.\n    typename awaiter_t = \u003cunspecified\u003e;\n\n    // The type of the result of co_await'ing a value of type T.\n    typename await_result_t = \u003cunspecified\u003e;\n  };\n}\n```\n\n## `is_awaitable\u003cT\u003e`\n\nThe `is_awaitable\u003cT\u003e` template metafunction allows you to query whether or not a given\ntype can be `co_await`ed or not from within a coroutine.\n\nAPI Summary:\n```c++\n// \u003ccppcoro/is_awaitable.hpp\u003e\nnamespace cppcoro\n{\n  template\u003ctypename T\u003e\n  struct is_awaitable : std::bool_constant\u003c...\u003e\n  {};\n\n  template\u003ctypename T\u003e\n  constexpr bool is_awaitable_v = is_awaitable\u003cT\u003e::value;\n}\n```\n\n# Concepts\n\n## `Awaitable\u003cT\u003e` concept\n\nAn `Awaitable\u003cT\u003e` is a concept that indicates that a type can be `co_await`ed in a coroutine context\nthat has no `await_transform` overloads and that the result of the `co_await` expression has type, `T`.\n\nFor example, the type `task\u003cT\u003e` implements the concept `Awaitable\u003cT\u0026\u0026\u003e` whereas the type `task\u003cT\u003e\u0026`\nimplements the concept `Awaitable\u003cT\u0026\u003e`.\n\n## `Awaiter\u003cT\u003e` concept\n\nAn `Awaiter\u003cT\u003e` is a concept that indicates a type contains the `await_ready`, `await_suspend` and\n`await_resume` methods required to implement the protocol for suspending/resuming an awaiting\ncoroutine.\n\nA type that satisfies `Awaiter\u003cT\u003e` must have, for an instance of the type, `awaiter`:\n- `awaiter.await_ready()` -\u003e `bool`\n- `awaiter.await_suspend(std::experimental::coroutine_handle\u003cvoid\u003e{})` -\u003e `void` or `bool` or `std::experimental::coroutine_handle\u003cP\u003e` for some `P`.\n- `awaiter.await_resume()` -\u003e `T`\n\nAny type that implements the `Awaiter\u003cT\u003e` concept also implements the `Awaitable\u003cT\u003e` concept.\n\n## `Scheduler` concept\n\nA `Scheduler` is a concept that allows scheduling execution of coroutines within some execution context.\n\n```c++\nconcept Scheduler\n{\n  Awaitable\u003cvoid\u003e schedule();\n}\n```\n\nGiven a type, `S`, that implements the `Scheduler` concept, and an instance, `s`, of type `S`:\n* The `s.schedule()` method returns an awaitable-type such that `co_await s.schedule()`\n  will unconditionally suspend the current coroutine and schedule it for resumption on the\n  execution context associated with the scheduler, `s`.\n* The result of the `co_await s.schedule()` expression has type `void`.\n\n```c++\ncppcoro::task\u003c\u003e f(Scheduler\u0026 scheduler)\n{\n  // Execution of the coroutine is initially on the caller's execution context.\n\n  // Suspends execution of the coroutine and schedules it for resumption on\n  // the scheduler's execution context.\n  co_await scheduler.schedule();\n\n  // At this point the coroutine is now executing on the scheduler's\n  // execution context.\n}\n```\n\n## `DelayedScheduler` concept\n\nA `DelayedScheduler` is a concept that allows a coroutine to schedule itself for execution on\nthe scheduler's execution context after a specified duration of time has elapsed.\n\n```c++\nconcept DelayedScheduler : Scheduler\n{\n  template\u003ctypename REP, typename RATIO\u003e\n  Awaitable\u003cvoid\u003e schedule_after(std::chrono::duration\u003cREP, RATIO\u003e delay);\n\n  template\u003ctypename REP, typename RATIO\u003e\n  Awaitable\u003cvoid\u003e schedule_after(\n    std::chrono::duration\u003cREP, RATIO\u003e delay,\n    cppcoro::cancellation_token cancellationToken);\n}\n```\n\nGiven a type, `S`, that implements the `DelayedScheduler` and an instance, `s` of type `S`:\n* The `s.schedule_after(delay)` method returns an object that can be awaited\n  such that `co_await s.schedule_after(delay)` suspends the current coroutine\n  for a duration of `delay` before scheduling the coroutine for resumption on\n  the execution context associated with the scheduler, `s`.\n* The `co_await s.schedule_after(delay)` expression has type `void`.\n\n# Building\n\nThe cppcoro library supports building under Windows with Visual Studio 2017 and Linux with Clang 5.0+.\n\nThis library makes use of the [Cake build system](https://github.com/lewissbaker/cake) (no, not the [C# one](http://cakebuild.net/)).\n\nThe cake build system is checked out automatically as a git submodule so you don't need to download or install it separately.\n\n## Building on Windows\n\nThis library currently requires Visual Studio 2017 or later and the Windows 10 SDK.\n\nSupport for Clang ([#3](https://github.com/lewissbaker/cppcoro/issues/3)) and Linux ([#15](https://github.com/lewissbaker/cppcoro/issues/15)) is planned.\n\n### Prerequisites\n\nThe Cake build-system is implemented in Python and requires Python 2.7 to be installed.\n\nEnsure Python 2.7 interpreter is in your PATH and available as 'python'.\n\nEnsure Visual Studio 2017 Update 3 or later is installed.\nNote that there are some known issues with coroutines in Update 2 or earlier that have been fixed in Update 3.\n\nYou can also use an experimental version of the Visual Studio compiler by downloading a NuGet package from https://vcppdogfooding.azurewebsites.net/ and unzipping the .nuget file to a directory.\nJust update the `config.cake` file to point at the unzipped location by modifying and uncommenting the following line:\n```python\nnugetPath = None # r'C:\\Path\\To\\VisualCppTools.14.0.25224-Pre'\n```\n\nEnsure that you have the Windows 10 SDK installed.\nIt will use the latest Windows 10 SDK and Universal C Runtime version by default.\n\n### Cloning the repository\n\nThe cppcoro repository makes use of git submodules to pull in the source for the Cake build system.\n\nThis means you need to pass the `--recursive` flag to the `git clone` command. eg.\n```\nc:\\Code\u003e git clone --recursive https://github.com/lewissbaker/cppcoro.git\n```\n\nIf you have already cloned cppcoro, then you should update the submodules after pulling changes.\n```\nc:\\Code\\cppcoro\u003e git submodule update --init --recursive\n```\n\n### Building from the command-line\n\nTo build from the command-line just run 'cake.bat' in the workspace root.\n\neg.\n```\nC:\\cppcoro\u003e cake.bat\nBuilding with C:\\cppcoro\\config.cake - Variant(release='debug', platform='windows', architecture='x86', compilerFamily='msvc', compiler='msvc14.10')\nBuilding with C:\\cppcoro\\config.cake - Variant(release='optimised', platform='windows', architecture='x64', compilerFamily='msvc', compiler='msvc14.10')\nBuilding with C:\\cppcoro\\config.cake - Variant(release='debug', platform='windows', architecture='x64', compilerFamily='msvc', compiler='msvc14.10')\nBuilding with C:\\cppcoro\\config.cake - Variant(release='optimised', platform='windows', architecture='x86', compilerFamily='msvc', compiler='msvc14.10')\nCompiling test\\main.cpp\nCompiling test\\main.cpp\nCompiling test\\main.cpp\nCompiling test\\main.cpp\n...\nLinking build\\windows_x86_msvc14.10_debug\\test\\run.exe\nLinking build\\windows_x64_msvc14.10_optimised\\test\\run.exe\nLinking build\\windows_x86_msvc14.10_optimised\\test\\run.exe\nLinking build\\windows_x64_msvc14.10_debug\\test\\run.exe\nGenerating code\nFinished generating code\nGenerating code\nFinished generating code\nBuild succeeded.\nBuild took 0:00:02.419.\n```\n\nBy default, running `cake` with no arguments will build all projects with all build variants and execute the unit-tests.\nYou can narrow what is built by passing additional command-line arguments.\neg.\n```\nc:\\cppcoro\u003e cake.bat release=debug architecture=x64 lib/build.cake\nBuilding with C:\\Users\\Lewis\\Code\\cppcoro\\config.cake - Variant(release='debug', platform='windows', architecture='x64', compilerFamily='msvc', compiler='msvc14.10')\nArchiving build\\windows_x64_msvc14.10_debug\\lib\\cppcoro.lib\nBuild succeeded.\nBuild took 0:00:00.321.\n```\n\nYou can run `cake --help` to list available command-line options.\n\n### Building Visual Studio project files\n\nTo develop from within Visual Studio you can build .vcproj/.sln files by running `cake.bat -p`.\n\neg.\n```\nc:\\cppcoro\u003e cake.bat -p\nBuilding with C:\\cppcoro\\config.cake - Variant(release='debug', platform='windows', architecture='x86', compilerFamily='msvc', compiler='msvc14.10')\nBuilding with C:\\cppcoro\\config.cake - Variant(release='optimised', platform='windows', architecture='x64', compilerFamily='msvc', compiler='msvc14.10')\nBuilding with C:\\cppcoro\\config.cake - Variant(release='debug', platform='windows', architecture='x64', compilerFamily='msvc', compiler='msvc14.10')\nBuilding with C:\\cppcoro\\config.cake - Variant(release='optimised', platform='windows', architecture='x86', compilerFamily='msvc', compiler='msvc14.10')\nGenerating Solution build/project/cppcoro.sln\nGenerating Project build/project/cppcoro_tests.vcxproj\nGenerating Filters build/project/cppcoro_tests.vcxproj.filters\nGenerating Project build/project/cppcoro.vcxproj\nGenerating Filters build/project/cppcoro.vcxproj.filters\nBuild succeeded.\nBuild took 0:00:00.247.\n```\n\nWhen you build these projects from within Visual Studio it will call out to cake to perform the compilation.\n\n## Building on Linux\n\nThe cppcoro project can also be built under Linux using Clang + libc++ 5.0 or later.\n\nBuilding cppcoro has been tested under Ubuntu 17.04.\n\n### Prerequisities\n\nEnsure you have the following packages installed:\n* Python 2.7\n* Clang \u003e= 5.0\n* LLD \u003e= 5.0\n* libc++ \u003e= 5.0\n\n\n### Building cppcoro\n\nThis is assuming you have Clang and libc++ built and installed.\n\nIf you don't have Clang configured yet, see the following sections\nfor details on setting up Clang for building with cppcoro.\n\nCheckout cppcoro and its submodules:\n```\ngit clone --recursive https://github.com/lewissbaker/cppcoro.git cppcoro\n```\n\nRun `init.sh` to setup the `cake` bash function:\n```\ncd cppcoro\nsource init.sh\n```\n\nThen you can run `cake` from the workspace root to build cppcoro and run tests:\n```\n$ cake\n```\n\nYou can specify additional command-line arguments to customise the build:\n* `--help` will print out help for command-line arguments\n* `--debug=run` will show the build command-lines being run\n* `release=debug` or `release=optimised` will limit the build variant to\n   either debug or optimised (by default it will build both).\n* `lib/build.cake` will just build the cppcoro library and not the tests.\n* `test/build.cake@task_tests.cpp` will just compile a particular source file\n\nFor example:\n```\n$ cake --debug=run release=debug lib/build.cake\n```\n\n### Customising location of Clang\n\nIf your clang compiler is not located at `/usr/bin/clang` then you need to\nmodify the `config.cake` file to tell cake where to find clang.\n\nEdit the following line in `config.cake`:\n```python\n  # If you have built your own version of Clang, you can modify\n  # this variable to point to the CMAKE_INSTALL_PREFIX for\n  # where you have installed your clang/libcxx build.\n  clangInstallPrefix = '/usr'\n```\n\nIf you have `libc++` installed in a different location then you can\ncustomise its location by modifying the following line in `config.cake`.\n```python\n  # Set this to the install-prefix of where libc++ is installed.\n  # You only need to set this if it is not installed at the same\n  # location as clangInstallPrefix.\n  libCxxInstallPrefix = None # '/path/to/install'\n```\n\nIf the install location has multiple versions of Clang installed and\nthe one you want to use is not `\u003cinstall-prefix\u003e/bin/clang` then you\ncan explicitly specify which one to use by modifying the `config.cake`\nfile to specify the name of the clang binaries:\n```python\n  compiler = ClangCompiler(\n    configuration=configuration,\n    clangExe=cake.path.join(clangBinPath, 'clang-6.0'),\n    llvmArExe=cake.path.join(clangBinPath, 'llvm-ar-6.0'),\n    binPaths=[clangBinPath])\n```\n\n### Using a snapshot build of Clang\n\nIf your Linux distribution does not have a version of Clang 5.0 or later\navailable, you can install a snapshot build from the LLVM project.\n\nFollow instructions at http://apt.llvm.org/ to setup your package manager\nto support pulling from the LLVM package manager.\n\nFor example, for Ubuntu 17.04 Zesty:\n\nEdit `/etc/apt/sources.list` and add the following lines:\n```\ndeb http://apt.llvm.org/zesty/ llvm-toolchain-zesty main\ndeb-src http://apt.llvm.org/zesty/ llvm-toolchain-zesty main\n```\n\nInstall the PGP key for those packages:\n```\n$ wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -\n```\n\nInstall Clang and LLD:\n```\n$ sudo apt-get install clang-6.0 lld-6.0\n```\n\nThe LLVM snapshot builds do not include libc++ versions so you'll need to build that yourself.\nSee below.\n\n### Building your own Clang\n\nYou can also use the bleeding-edge Clang version by building Clang from source yourself.\n\nSee instructions here: \n\nTo do this you will need to install the following pre-requisites:\n```\n$ sudo apt-get install git cmake ninja-build clang lld\n```\n\nNote that we are using your distribution's version of clang to build\nclang from source. GCC could also be used here instead.\n\n\nCheckout LLVM + Clang + LLD + libc++ repositories:\n```\nmkdir llvm\ncd llvm\ngit clone --depth=1 https://github.com/llvm-mirror/llvm.git llvm\ngit clone --depth=1 https://github.com/llvm-mirror/clang.git llvm/tools/clang\ngit clone --depth=1 https://github.com/llvm-mirror/lld.git llvm/tools/lld\ngit clone --depth=1 https://github.com/llvm-mirror/libcxx.git llvm/projects/libcxx\nln -s llvm/tools/clang clang\nln -s llvm/tools/lld lld\nln -s llvm/projects/libcxx libcxx\n```\n\nConfigure and build Clang:\n```\nmkdir clang-build\ncd clang-build\ncmake -GNinja \\\n      -DCMAKE_CXX_COMPILER=/usr/bin/clang++ \\\n      -DCMAKE_C_COMPILER=/usr/bin/clang \\\n      -DCMAKE_BUILD_TYPE=MinSizeRel \\\n      -DCMAKE_INSTALL_PREFIX=\"/path/to/clang/install\"\n      -DCMAKE_BUILD_WITH_INSTALL_RPATH=\"yes\" \\\n      -DLLVM_TARGETS_TO_BUILD=X86 \\\n      -DLLVM_ENABLE_PROJECTS=\"lld;clang\" \\\n      ../llvm\nninja install-clang \\\n      install-clang-headers \\\n      install-llvm-ar \\\n      install-lld\n```\n\n### Building libc++\n\nThe cppcoro project requires libc++ as it contains the `\u003cexperimental/coroutine\u003e`\nheader required to use C++ coroutines under Clang.\n\nCheckout `libc++` + `llvm`:\n```\nmkdir llvm\ncd llvm\ngit clone --depth=1 https://github.com/llvm-mirror/llvm.git llvm\ngit clone --depth=1 https://github.com/llvm-mirror/libcxx.git llvm/projects/libcxx\nln -s llvm/projects/libcxx libcxx\n```\n\nBuild `libc++`:\n```\nmkdir libcxx-build\ncd libcxx-build\ncmake -GNinja \\\n      -DCMAKE_CXX_COMPILER=\"/path/to/clang/install/bin/clang++\" \\\n      -DCMAKE_C_COMPILER=\"/path/to/clang/install/bin/clang\" \\\n      -DCMAKE_BUILD_TYPE=Release \\\n      -DCMAKE_INSTALL_PREFIX=\"/path/to/clang/install\" \\\n      -DLLVM_PATH=\"../llvm\" \\\n      -DLIBCXX_CXX_ABI=libstdc++ \\\n      -DLIBCXX_CXX_ABI_INCLUDE_PATHS=\"/usr/include/c++/6.3.0/;/usr/include/x86_64-linux-gnu/c++/6.3.0/\" \\\n      ../libcxx\nninja cxx\nninja install\n```\n\nThis will build and install libc++ into the same install directory where you have clang installed.\n\n# Support\n\nGitHub issues are the primary mechanism for support, bug reports and feature requests.\n\nContributions are welcome and pull-requests will be happily reviewed.\nI only ask that you agree to license any contributions that you make under the MIT license.\n\nIf you have general questions about C++ coroutines, you can generally find someone to help\nin the `#coroutines` channel on [Cpplang Slack](https://cpplang.slack.com/) group.\n","versions":[{"ref":"master","manifest":"targets = [ \"//:cppcoro\" ]","lockFile":"manifest = \"39fd315e0f05b1752757bcfcd16b587805409d88b91bb0b93be412974ad6df78\"\n\n","buck":"load('//:buckaroo_macros.bzl', 'buckaroo_deps')\nload('//:subdir_glob.bzl', 'subdir_glob')\n\ncxx_library(\n  name = 'cppcoro',\n  header_namespace = '',\n  exported_headers = subdir_glob([\n    ('include', '**/*.hpp'),\n  ]),\n  headers = subdir_glob([\n    ('lib', '**/*.hpp'),\n  ]),\n  srcs = [\n    'lib/async_auto_reset_event.cpp',\n    'lib/async_manual_reset_event.cpp',\n    'lib/async_mutex.cpp',\n    'lib/cancellation_state.cpp',\n    'lib/cancellation_token.cpp',\n    'lib/cancellation_source.cpp',\n    'lib/cancellation_registration.cpp',\n    'lib/lightweight_manual_reset_event.cpp',\n    'lib/ip_address.cpp',\n    'lib/ip_endpoint.cpp',\n    'lib/ipv4_address.cpp',\n    'lib/ipv4_endpoint.cpp',\n    'lib/ipv6_address.cpp',\n    'lib/ipv6_endpoint.cpp',\n    'lib/static_thread_pool.cpp',\n    'lib/auto_reset_event.cpp',\n    'lib/spin_wait.cpp',\n    'lib/spin_mutex.cpp',\n  ],\n  # srcs = glob([\n    # 'lib/**/*.cpp',\n  # ]),\n  deps = buckaroo_deps(),\n  visibility = [\n    'PUBLIC',\n  ],\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-19T10:52:46Z","updatedUpstream":"2021-01-13T12:24:15Z","contributors":[{"login":"lewissbaker","avatarUrl":"https://avatars1.githubusercontent.com/u/211814?v=4"},{"login":"ericniebler","avatarUrl":"https://avatars1.githubusercontent.com/u/225757?v=4"},{"login":"modocache","avatarUrl":"https://avatars0.githubusercontent.com/u/552921?u=1d02d9f7cb26d05a02a3dd31c13eec531bc17ea7\u0026v=4"},{"login":"lunastorm","avatarUrl":"https://avatars0.githubusercontent.com/u/1013760?v=4"},{"login":"mwinterb","avatarUrl":"https://avatars1.githubusercontent.com/u/1081839?v=4"},{"login":"BillyONeal","avatarUrl":"https://avatars0.githubusercontent.com/u/1544943?v=4"},{"login":"YehezkelShB","avatarUrl":"https://avatars3.githubusercontent.com/u/3028031?u=09ff4cb08e1a6be6b00fabb5f94ba42b3c1a4b77\u0026v=4"},{"login":"andreasbuhr","avatarUrl":"https://avatars3.githubusercontent.com/u/3892222?u=618b5d3fb0cd3a4b2c32156f88ffb8bdf79df840\u0026v=4"},{"login":"Uran198","avatarUrl":"https://avatars3.githubusercontent.com/u/3969221?u=7a5ecd45a5155db9c735a21194f68b16bd1b96db\u0026v=4"},{"login":"blapid","avatarUrl":"https://avatars0.githubusercontent.com/u/4070103?v=4"},{"login":"grishavanika","avatarUrl":"https://avatars3.githubusercontent.com/u/7958078?u=1f928bf191f5b80f79d796a682d95ab9f1ad0f9e\u0026v=4"},{"login":"anlongfei","avatarUrl":"https://avatars3.githubusercontent.com/u/9415737?u=21c4093bae80a4855986e350a9387e3ab01a8143\u0026v=4"},{"login":"nathiss","avatarUrl":"https://avatars1.githubusercontent.com/u/11808334?v=4"},{"login":"menefotto","avatarUrl":"https://avatars0.githubusercontent.com/u/12408563?u=1dbad929453056889f4c8c172b781890d641a6da\u0026v=4"},{"login":"lofcek","avatarUrl":"https://avatars3.githubusercontent.com/u/14615461?v=4"},{"login":"gomez-addams","avatarUrl":"https://avatars2.githubusercontent.com/u/17425260?u=cd5f411bda26b4da642a52b7108fdbaa33b7ac5d\u0026v=4"},{"login":"denchat","avatarUrl":"https://avatars0.githubusercontent.com/u/19730041?v=4"},{"login":"Alinshans","avatarUrl":"https://avatars2.githubusercontent.com/u/20122802?u=d1515d6d024376864aee5dbafa7e114b1443544b\u0026v=4"},{"login":"fghzxm","avatarUrl":"https://avatars1.githubusercontent.com/u/32954258?v=4"},{"login":"yaoxinliu","avatarUrl":"https://avatars1.githubusercontent.com/u/34788154?v=4"},{"login":"GouravKumar2","avatarUrl":"https://avatars2.githubusercontent.com/u/72178223?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":1533,"forks":212,"topics":["coroutines","cplusplus","asynchronous-programming","async-await","coroutines-ts","windows","msvc","clang","cpp","async","asyncio","linux"]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"lewissbaker-cppcoro"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>