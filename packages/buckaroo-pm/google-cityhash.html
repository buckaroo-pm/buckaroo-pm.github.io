<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/google-cityhash/logo.png"/></div><div><h1>buckaroo-pm/google-cityhash</h1><div style="max-width:600px">Automatically exported from code.google.com/p/cityhash</div><br/><div><b>708</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><p>CityHash, a family of hash functions for strings.</p><h1>Introduction</h1><p>CityHash provides hash functions for strings.  The functions mix the
input bits thoroughly but are not suitable for cryptography.  See
&quot;Hash Quality,&quot; below, for details on how CityHash was tested and so on.</p><p>We provide reference implementations in C++, with a friendly MIT license.</p><p>CityHash32() returns a 32-bit hash.</p><p>CityHash64() and similar return a 64-bit hash.</p><p>CityHash128() and similar return a 128-bit hash and are tuned for
strings of at least a few hundred bytes.  Depending on your compiler
and hardware, it&#x27;s likely faster than CityHash64() on sufficiently long
strings.  It&#x27;s slower than necessary on shorter strings, but we expect
that case to be relatively unimportant.</p><p>CityHashCrc128() and similar are variants of CityHash128() that depend
on _mm_crc32_u64(), an intrinsic that compiles to a CRC32 instruction
on some CPUs.  However, none of the functions we provide are CRCs.</p><p>CityHashCrc256() is a variant of CityHashCrc128() that also depends
on _mm_crc32_u64().  It returns a 256-bit hash.</p><p>All members of the CityHash family were designed with heavy reliance
on previous work by Austin Appleby, Bob Jenkins, and others.
For example, CityHash32 has many similarities with Murmur3a.</p><h1>Performance on long strings: 64-bit CPUs</h1><p>We are most excited by the performance of CityHash64() and its variants on
short strings, but long strings are interesting as well.</p><p>CityHash is intended to be fast, under the constraint that it hash very
well.  For CPUs with the CRC32 instruction, CRC is speedy, but CRC wasn&#x27;t
designed as a hash function and shouldn&#x27;t be used as one.  CityHashCrc128()
is not a CRC, but it uses the CRC32 machinery.</p><p>On a single core of a 2.67GHz Intel Xeon X5550, CityHashCrc256 peaks at about
5 to 5.5 bytes/cycle.  The other CityHashCrc functions are wrappers around
CityHashCrc256 and should have similar performance on long strings.
(CityHashCrc256 in v1.0.3 was even faster, but we decided it wasn&#x27;t as thorough
as it should be.)  CityHash128 peaks at about 4.3 bytes/cycle.  The fastest
Murmur variant on that hardware, Murmur3F, peaks at about 2.4 bytes/cycle.
We expect the peak speed of CityHash128 to dominate CityHash64, which is
aimed more toward short strings or use in hash tables.</p><p>For long strings, a new function by Bob Jenkins, SpookyHash, is just
slightly slower than CityHash128 on Intel x86-64 CPUs, but noticeably
faster on AMD x86-64 CPUs.  For hashing long strings on AMD CPUs
and/or CPUs without the CRC instruction, SpookyHash may be just as
good or better than any of the CityHash variants.</p><h1>Performance on short strings: 64-bit CPUs</h1><p>For short strings, e.g., most hash table keys, CityHash64 is faster than
CityHash128, and probably faster than all the aforementioned functions,
depending on the mix of string lengths.  Here are a few results from that
same hardware, where we (unrealistically) tested a single string length over
and over again:</p><h2>Hash              Results</h2><p>CityHash64 v1.0.3 7ns for 1 byte, or 6ns for 8 bytes, or 9ns for 64 bytes
Murmur2 (64-bit)  6ns for 1 byte, or 6ns for 8 bytes, or 15ns for 64 bytes
Murmur3F          14ns for 1 byte, or 15ns for 8 bytes, or 23ns for 64 bytes</p><p>We don&#x27;t have CityHash64 benchmarks results for v1.1, but we expect the
numbers to be similar.</p><h1>Performance: 32-bit CPUs</h1><p>CityHash32 is the newest variant of CityHash.  It is intended for
32-bit hardware in general but has been mostly tested on x86.  Our benchmarks
suggest that Murmur3 is the nearest competitor to CityHash32 on x86.
We don&#x27;t know of anything faster that has comparable quality.  The speed rankings
in our testing: CityHash32 &gt; Murmur3f &gt; Murmur3a (for long strings), and
CityHash32 &gt; Murmur3a &gt; Murmur3f (for short strings).</p><h1>Installation</h1><p>We provide reference implementations of several CityHash functions, written
in C++.  The build system is based on autoconf.  It defaults the C++
compiler flags to &quot;-g -O2&quot;, which is probably slower than -O3 if you are
using gcc.  YMMV.</p><p>On systems with gcc, we generally recommend:</p><p>./configure
make all check CXXFLAGS=&quot;-g -O3&quot;
sudo make install</p><p>Or, if your system has the CRC32 instruction, and you want to build everything:</p><p>./configure --enable-sse4.2
make all check CXXFLAGS=&quot;-g -O3 -msse4.2&quot;
sudo make install</p><p>Note that our build system doesn&#x27;t try to determine the appropriate compiler
flag for enabling SSE4.2.  For gcc it is &quot;-msse4.2&quot;.  The --enable-sse4.2
flag to the configure script controls whether citycrc.h is installed when
you &quot;make install.&quot;  In general, picking the right compiler flags can be
tricky, and may depend on your compiler, your hardware, and even how you
plan to use the library.</p><p>For generic information about how to configure this software, please try:</p><p>./configure --help</p><p>Failing that, please work from city.cc and city*.h, as they contain all the
necessary code.</p><h1>Usage</h1><p>The above installation instructions will produce a single library.  It will
contain CityHash32(), CityHash64(), and CityHash128(), and their variants,
and possibly CityHashCrc128(), CityHashCrc128WithSeed(), and
CityHashCrc256().  The functions with Crc in the name are declared in
citycrc.h; the rest are declared in city.h.</p><h1>Limitations</h1><ol><li>CityHash32 is intended for little-endian 32-bit code, and everything else in</li></ol><p>the current version of CityHash is intended for little-endian 64-bit CPUs.</p><p>All functions that don&#x27;t use the CRC32 instruction should work in
little-endian 32-bit or 64-bit code.  CityHash should work on big-endian CPUs
as well, but we haven&#x27;t tested that very thoroughly yet.</p><ol start="2"><li>CityHash is fairly complex.  As a result of its complexity, it may not</li></ol><p>perform as expected on some compilers.  For example, preliminary reports
suggest that some Microsoft compilers compile CityHash to assembly that&#x27;s
10-20% slower than it could be.</p><h1>Hash Quality</h1><p>We like to test hash functions with SMHasher, among other things.
SMHasher isn&#x27;t perfect, but it seems to find almost any significant flaw.
SMHasher is available at <a href="http://code.google.com/p/smhasher/">http://code.google.com/p/smhasher/</a></p><p>SMHasher is designed to pass a 32-bit seed to the hash functions it tests.
No CityHash function is designed to work that way, so we adapt as follows:
For our functions that accept a seed, we use the given seed directly (padded
with zeroes); for our functions that don&#x27;t accept a seed, we hash the
concatenation of the given seed and the input string.</p><p>The CityHash functions have the following flaws according to SMHasher:</p><p>(1) CityHash64: none</p><p>(2) CityHash64WithSeed: none</p><p>(3) CityHash64WithSeeds: did not test</p><p>(4) CityHash128: none</p><p>(5) CityHash128WithSeed: none</p><p>(6) CityHashCrc128: none</p><p>(7) CityHashCrc128WithSeed: none</p><p>(8) CityHashCrc256: none</p><p>(9) CityHash32: none</p><p>Some minor flaws in 32-bit and 64-bit functions are harmless, as we
expect the primary use of these functions will be in hash tables.  We
may have gone slightly overboard in trying to please SMHasher and other
similar tests, but we don&#x27;t want anyone to choose a different hash function
because of some minor issue reported by a quality test.</p><h1>For more information</h1><p><a href="http://code.google.com/p/cityhash/">http://code.google.com/p/cityhash/</a></p><p><a href="mailto:cityhash-discuss@googlegroups.com">cityhash-discuss@googlegroups.com</a></p><p>Please feel free to send us comments, questions, bug reports, or patches.</p></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/google-cityhash","name":"google/cityhash","licence":"NOASSERTION","description":"Automatically exported from code.google.com/p/cityhash","readme":"CityHash, a family of hash functions for strings.\n\n\nIntroduction\n============\n\nCityHash provides hash functions for strings.  The functions mix the\ninput bits thoroughly but are not suitable for cryptography.  See\n\"Hash Quality,\" below, for details on how CityHash was tested and so on.\n\nWe provide reference implementations in C++, with a friendly MIT license.\n\nCityHash32() returns a 32-bit hash.\n\nCityHash64() and similar return a 64-bit hash.\n\nCityHash128() and similar return a 128-bit hash and are tuned for\nstrings of at least a few hundred bytes.  Depending on your compiler\nand hardware, it's likely faster than CityHash64() on sufficiently long\nstrings.  It's slower than necessary on shorter strings, but we expect\nthat case to be relatively unimportant.\n\nCityHashCrc128() and similar are variants of CityHash128() that depend\non _mm_crc32_u64(), an intrinsic that compiles to a CRC32 instruction\non some CPUs.  However, none of the functions we provide are CRCs.\n\nCityHashCrc256() is a variant of CityHashCrc128() that also depends\non _mm_crc32_u64().  It returns a 256-bit hash.\n\nAll members of the CityHash family were designed with heavy reliance\non previous work by Austin Appleby, Bob Jenkins, and others.\nFor example, CityHash32 has many similarities with Murmur3a.\n\nPerformance on long strings: 64-bit CPUs\n========================================\n \nWe are most excited by the performance of CityHash64() and its variants on\nshort strings, but long strings are interesting as well.\n\nCityHash is intended to be fast, under the constraint that it hash very\nwell.  For CPUs with the CRC32 instruction, CRC is speedy, but CRC wasn't\ndesigned as a hash function and shouldn't be used as one.  CityHashCrc128()\nis not a CRC, but it uses the CRC32 machinery.\n\nOn a single core of a 2.67GHz Intel Xeon X5550, CityHashCrc256 peaks at about\n5 to 5.5 bytes/cycle.  The other CityHashCrc functions are wrappers around\nCityHashCrc256 and should have similar performance on long strings.\n(CityHashCrc256 in v1.0.3 was even faster, but we decided it wasn't as thorough\nas it should be.)  CityHash128 peaks at about 4.3 bytes/cycle.  The fastest\nMurmur variant on that hardware, Murmur3F, peaks at about 2.4 bytes/cycle.\nWe expect the peak speed of CityHash128 to dominate CityHash64, which is\naimed more toward short strings or use in hash tables.\n\nFor long strings, a new function by Bob Jenkins, SpookyHash, is just\nslightly slower than CityHash128 on Intel x86-64 CPUs, but noticeably\nfaster on AMD x86-64 CPUs.  For hashing long strings on AMD CPUs\nand/or CPUs without the CRC instruction, SpookyHash may be just as\ngood or better than any of the CityHash variants.\n\nPerformance on short strings: 64-bit CPUs\n=========================================\n\nFor short strings, e.g., most hash table keys, CityHash64 is faster than\nCityHash128, and probably faster than all the aforementioned functions,\ndepending on the mix of string lengths.  Here are a few results from that\nsame hardware, where we (unrealistically) tested a single string length over\nand over again:\n\nHash              Results\n------------------------------------------------------------------------------\nCityHash64 v1.0.3 7ns for 1 byte, or 6ns for 8 bytes, or 9ns for 64 bytes\nMurmur2 (64-bit)  6ns for 1 byte, or 6ns for 8 bytes, or 15ns for 64 bytes\nMurmur3F          14ns for 1 byte, or 15ns for 8 bytes, or 23ns for 64 bytes\n\nWe don't have CityHash64 benchmarks results for v1.1, but we expect the\nnumbers to be similar.\n\nPerformance: 32-bit CPUs\n========================\n\nCityHash32 is the newest variant of CityHash.  It is intended for\n32-bit hardware in general but has been mostly tested on x86.  Our benchmarks\nsuggest that Murmur3 is the nearest competitor to CityHash32 on x86.\nWe don't know of anything faster that has comparable quality.  The speed rankings\nin our testing: CityHash32 \u003e Murmur3f \u003e Murmur3a (for long strings), and\nCityHash32 \u003e Murmur3a \u003e Murmur3f (for short strings).\n\nInstallation\n============\n\nWe provide reference implementations of several CityHash functions, written\nin C++.  The build system is based on autoconf.  It defaults the C++\ncompiler flags to \"-g -O2\", which is probably slower than -O3 if you are\nusing gcc.  YMMV.\n\nOn systems with gcc, we generally recommend:\n\n./configure\nmake all check CXXFLAGS=\"-g -O3\"\nsudo make install\n\nOr, if your system has the CRC32 instruction, and you want to build everything:\n\n./configure --enable-sse4.2\nmake all check CXXFLAGS=\"-g -O3 -msse4.2\"\nsudo make install\n\nNote that our build system doesn't try to determine the appropriate compiler\nflag for enabling SSE4.2.  For gcc it is \"-msse4.2\".  The --enable-sse4.2\nflag to the configure script controls whether citycrc.h is installed when\nyou \"make install.\"  In general, picking the right compiler flags can be\ntricky, and may depend on your compiler, your hardware, and even how you\nplan to use the library.\n\nFor generic information about how to configure this software, please try:\n\n./configure --help\n\nFailing that, please work from city.cc and city*.h, as they contain all the\nnecessary code.\n\n\nUsage\n=====\n\nThe above installation instructions will produce a single library.  It will\ncontain CityHash32(), CityHash64(), and CityHash128(), and their variants,\nand possibly CityHashCrc128(), CityHashCrc128WithSeed(), and\nCityHashCrc256().  The functions with Crc in the name are declared in\ncitycrc.h; the rest are declared in city.h.\n\n\nLimitations\n===========\n\n1) CityHash32 is intended for little-endian 32-bit code, and everything else in\nthe current version of CityHash is intended for little-endian 64-bit CPUs.\n\nAll functions that don't use the CRC32 instruction should work in\nlittle-endian 32-bit or 64-bit code.  CityHash should work on big-endian CPUs\nas well, but we haven't tested that very thoroughly yet.\n\n2) CityHash is fairly complex.  As a result of its complexity, it may not\nperform as expected on some compilers.  For example, preliminary reports\nsuggest that some Microsoft compilers compile CityHash to assembly that's\n10-20% slower than it could be.\n\n\nHash Quality\n============\n\nWe like to test hash functions with SMHasher, among other things.\nSMHasher isn't perfect, but it seems to find almost any significant flaw.\nSMHasher is available at http://code.google.com/p/smhasher/\n\nSMHasher is designed to pass a 32-bit seed to the hash functions it tests.\nNo CityHash function is designed to work that way, so we adapt as follows:\nFor our functions that accept a seed, we use the given seed directly (padded\nwith zeroes); for our functions that don't accept a seed, we hash the\nconcatenation of the given seed and the input string.\n\nThe CityHash functions have the following flaws according to SMHasher:\n\n(1) CityHash64: none\n\n(2) CityHash64WithSeed: none\n\n(3) CityHash64WithSeeds: did not test\n\n(4) CityHash128: none\n\n(5) CityHash128WithSeed: none\n\n(6) CityHashCrc128: none\n\n(7) CityHashCrc128WithSeed: none\n\n(8) CityHashCrc256: none\n\n(9) CityHash32: none\n\nSome minor flaws in 32-bit and 64-bit functions are harmless, as we\nexpect the primary use of these functions will be in hash tables.  We\nmay have gone slightly overboard in trying to please SMHasher and other\nsimilar tests, but we don't want anyone to choose a different hash function\nbecause of some minor issue reported by a quality test.\n\n\nFor more information\n====================\n\nhttp://code.google.com/p/cityhash/\n\ncityhash-discuss@googlegroups.com\n\nPlease feel free to send us comments, questions, bug reports, or patches.\n","versions":[{"ref":"master","manifest":"targets = [ \"//:cityhash\" ]\n","lockFile":"manifest = \"acbb1c915b976fa3e373b3434ec017d51215af31b1d3f009caab041bf6d390d8\"\n\n","buck":"load('//:subdir_glob.bzl', 'subdir_glob')\n\ngenrule(\n  name = 'config',\n  out = 'config.h',\n  cmd = 'touch $OUT'\n) \n\ncxx_library(\n  name = 'cityhash',\n  header_namespace = '',\n  srcs = glob(['src/city.cc']),\n  exported_headers = subdir_glob([\n    ('src', '*.h')\n  ]),\n  headers = [':config'],\n  visibility = [\"PUBLIC\"]\n)\n\ncxx_binary(\n  name = 'test',\n  srcs = ['src/city-test.cc'],\n  deps = [':cityhash']\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-24T11:33:31Z","updatedUpstream":"2021-01-13T17:50:23Z","contributors":[{"login":"cdibona","avatarUrl":"https://avatars1.githubusercontent.com/u/165353?v=4"},{"login":"dberlin","avatarUrl":"https://avatars3.githubusercontent.com/u/324715?v=4"},{"login":"google-admin","avatarUrl":"https://avatars3.githubusercontent.com/u/3605123?u=cbaa690ef0ae81e5c1bd47bdfaed42fc66161792\u0026v=4"},{"login":"googlebot","avatarUrl":"https://avatars1.githubusercontent.com/u/5384588?u=b2b68981375faf7e582e8bf043e4d16f9bff44dd\u0026v=4"},{"login":"jyrkialakuijala","avatarUrl":"https://avatars3.githubusercontent.com/u/9086028?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":708,"forks":136,"topics":[]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"google-cityhash"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>