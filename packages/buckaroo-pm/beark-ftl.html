<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/beark-ftl/logo.png"/></div><div><h1>buckaroo-pm/beark-ftl</h1><div style="max-width:600px">C++ template library for fans of functional programming</div><br/><div><b>971</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><h1>FTL - The Functional Template Library</h1><p><a href="https://travis-ci.org/beark/ftl"><img src="https://travis-ci.org/beark/ftl.png?branch=master" alt="Build Status"/></a></p><p>C++ template library for fans of functional programming.</p><p>This project is currently on hiatus. Not sure when/if I&#x27;ll resume work on it.</p><p>If you want to play around with it anyway, you need to compile in C++11 mode with gcc-4.8 or later or clang-3.2 or later. Not sure if newer MSVC versions would work or not.</p><h2>Tutorials</h2><ul><li><a href="docs/Parsec-I.md">Parser Combinator Part I: Simple Parser</a></li><li><a href="docs/Parsec-II.md">Parser Combinator Part II: Parser Generator Library</a></li></ul><h2>Showcases</h2><p>A couple of quick showcases of some rather neat things the FTL gives you.</p><h3>Curried Function Calling</h3><p>One of the typically functional conventions brought to C++ by FTL is support for curried functions and function objects. A curried function is an n-ary function that can be invoked one argument at a time; each step returning a <em>new</em> function object of arity <em>n-1</em>. Once enough parameters have been applied (when <em>n</em> reaches <em>0</em>), the actual computation is performed and the result is returned. One of the uses of this is to achieve very convenient partial function application. For example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">auto</span><span> plus </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">curry</span><span class="token" style="color:#999">(</span><span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>plus</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">auto</span><span> addOne </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">plus</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">1</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:#07a">auto</span><span> x </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">addOne</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">2</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:slategray">// x = 3</span><span>
</span><span></span><span class="token" style="color:#07a">auto</span><span> y </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">addOne</span><span class="token" style="color:#999">(</span><span>x</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:slategray">// y = 4</span></code></pre><p>As mentioned, all of the function objects provided by FTL are curried by default and do not require an <code>ftl::curry</code> call first. Partial application is thus in many cases extremely concise and clean. Note, however, that without, for instance, a wrapping lambda function, it is not possible to partially apply parameters other than in the exact order they appear. For example, the following are all valid:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">auto</span><span> f </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">curriedTernaryFn</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">1</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">auto</span><span> g </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">curriedTernaryFn</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">1</span><span class="token" style="color:#999">,</span><span class="token" style="color:#905">2</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:#DD4A68">f</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">2</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">3</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> </span><span class="token" style="color:#DD4A68">f</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">2</span><span class="token" style="color:#999">,</span><span class="token" style="color:#905">3</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;&amp;</span><span> </span><span class="token" style="color:#DD4A68">f</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">2</span><span class="token" style="color:#999">,</span><span class="token" style="color:#905">3</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> </span><span class="token" style="color:#DD4A68">g</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">3</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:slategray">// true</span></code></pre><p>But it is not possible to &quot;skip&quot; a parameter or leave a placeholder, as in:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">using</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>placeholders</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>_1</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">auto</span><span> f </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">bind</span><span class="token" style="color:#999">(</span><span>ternaryFn</span><span class="token" style="color:#999">,</span><span> _1</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#905">2</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#905">3</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>Currying by itself is a very nice thing to have, but what <em>truly</em> makes it shine is when used in combination with e.g. higher order functions. See for instance applicative style coding, which is not nearly as nice without currying.</p><h3>Expanding The Standard Library</h3><p>One of the nice things about FTL is that it does not try to replace or supercede the standard library, it tries to <em>expand</em> it when possible. These expansions include giving existing types concept instances for e.g. Functor, Monad, Monoid, and others. For example, in FTL, <code>std::shared_ptr</code> is a monad. This means we can sequence a series of operations working on shared pointers without ever having to explicitly check for validity—while still being assured there are no attempts to access an invalid pointer.</p><p>For example, given</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>shared_ptr</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span>a</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> </span><span class="token" style="color:#DD4A68">foo</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>shared_ptr</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span>b</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> </span><span class="token" style="color:#DD4A68">bar</span><span class="token" style="color:#999">(</span><span>a</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>We can simply write</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>shared_ptr</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span>b</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> ptr </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">foo</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;&gt;=</span><span> bar</span><span class="token" style="color:#999">;</span></code></pre><p>Instead of</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>shared_ptr</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span>b</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> </span><span class="token" style="color:#DD4A68">ptr</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">nullptr</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">auto</span><span> ptra </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">foo</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">if</span><span class="token" style="color:#999">(</span><span>ptra</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>    ptr </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">bar</span><span class="token" style="color:#999">(</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>ptra</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#999">}</span></code></pre><p>Which would be the equivalent FTL-less version of the above.</p><p>Monadic code may perhaps often look strange if you&#x27;re not used to all the operators, but once you&#x27;ve got that, reading it becomes amazingly easy and clear. <code>operator&gt;&gt;=</code> above is used to sequence two monadic computations, where the second is dependant on the result of the first. Exactly what it does varies with monad instance, but in the case of <code>shared_ptr</code>, it essentially performs <code>nullptr</code> checks and either aborts the expression (returning a <code>nullptr</code> initialised <code>shared_ptr</code>), or simply passes the valid result forward.</p><p>Other types that have been similarly endowed with new powers include: <code>std::future</code>, <code>std::list</code>, <code>std::vector</code>, <code>std::forward_list</code>, <code>std::map</code>, <code>std::unordered_map</code>, <code>std::set</code>, and more.</p><h3>Sum/Union Types With Pattern Matching</h3><p>For those not familiar with sum types, they can be viewed as tagged unions. In other words, they are defined at compile time by a set of possible types, and at run-time their value will be of exactly one of those types at any particular instance. A quick example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>sum_type</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>string</span><span class="token" style="color:#999">,</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> x</span><span class="token" style="color:#999">{</span><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>constructor</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#905">3</span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">;</span></code></pre><p>Here, <code>x</code>, can take on any value that is either of type <code>std::string</code> or <code>int</code> and we&#x27;ve initialised it to be the integer value <code>3</code>. It is necessary to use the <code>constructor&lt;T&gt;</code> tag to specify what type to initialise to, because some types may have constructors accepting similar or even the same arguments.</p><p>Once we have our sum type, we can now pattern match—or <code>switch</code> on its type, if you prefer—to get a guaranteed safe way of accessing its value:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">int</span><span> y </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> x</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">match</span><span class="token" style="color:#999">(</span><span>
</span><span>    </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">int</span><span> x</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> </span><span class="token" style="color:#07a">return</span><span> x</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">+</span><span class="token" style="color:#905">1</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">,</span><span>           </span><span class="token" style="color:slategray">// This function will be invoked, with</span><span>
</span><span>                                        </span><span class="token" style="color:slategray">// 3 as parameter</span><span>
</span>
<span>    </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">const</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>string</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> </span><span class="token" style="color:#07a">return</span><span> </span><span class="token" style="color:#905">0</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span> </span><span class="token" style="color:slategray">// This function would have been invoked</span><span>
</span><span>                                        </span><span class="token" style="color:slategray">// if x was a string</span><span>
</span><span></span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>Unlike in a language with first class support for pattern matching, in FTL we are unfortunately forced to use functions as match clauses, as you can see above. This makes it slightly less compelling, but we do get the same static guarantees at least: FTL checks at compile time that you&#x27;ve covered every possible type the matched sum type could take on.</p><p>Note that <code>match</code> must return a value by default, to encourage the functional way where everything is an expression and therefore returns a value. This means, of course, that all match clauses must return values such that <code>std::common_type</code> can find a common type they are all implicitly convertible to.</p><p>If the above expression-semantic of <code>match</code> is not actually desirable, there is also <code>matchE</code>, which does &quot;effectful&quot; matches:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>x</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">matchE</span><span class="token" style="color:#999">(</span><span>
</span><span>    </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span> x</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">++</span><span>x</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">,</span><span>
</span><span>    </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">const</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>string</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span> x</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>cout </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;&lt;</span><span> x</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span>
</span><span></span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>Another possible point of inconvenience is if we have a complicated sum type of many sub-types. It can be quite a bother to write out every match case explicitly then, especially if we&#x27;re only interested in one or a couple. Enter <code>otherwise</code>:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>sum_type</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span>A</span><span class="token" style="color:#999">,</span><span>B</span><span class="token" style="color:#999">,</span><span>C</span><span class="token" style="color:#999">,</span><span>D</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> x</span><span class="token" style="color:#999">{</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">auto</span><span> r </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> x</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">match</span><span class="token" style="color:#999">(</span><span>
</span><span>    </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">const</span><span> B</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span> b</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> </span><span class="token" style="color:#07a">return</span><span> </span><span class="token" style="color:#DD4A68">f</span><span class="token" style="color:#999">(</span><span>b</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:slategray">// This function will be invoked only if</span><span>
</span><span>                                    </span><span class="token" style="color:slategray">// x&#x27;s value is of type B</span><span>
</span>
<span>    </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span>otherwise</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> </span><span class="token" style="color:#07a">return</span><span> </span><span class="token" style="color:#DD4A68">g</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span>    </span><span class="token" style="color:slategray">// This function will be invoked if x&#x27;s</span><span>
</span><span>                                    </span><span class="token" style="color:slategray">// value is of any type except B</span><span>
</span><span></span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>It is of course possible to have several specific match clauses before the otherwise-clause, but make sure to always put <code>otherwise</code> last—or else any clause appearing below it will never actually be executed. Simply put, matching is done in the order the expressions appear.</p><p>The true usefulness of <code>sum_type</code> isn&#x27;t so much the case where you use it directly. It&#x27;s when you use it to quickly and cleanly create new data types. For example, did you know both <code>ftl::maybe</code> and <code>ftl::either</code> are really just simple type aliases of <code>sum_type</code>? It&#x27;s true, <code>maybe</code> is defined simply as:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">template</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">typename</span><span> </span><span class="token" style="color:#DD4A68">T</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span>
</span><span></span><span class="token" style="color:#07a">using</span><span> maybe </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> sum_type</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span>T</span><span class="token" style="color:#999">,</span><span>Nothing</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">;</span></code></pre><p>That takes care of the vast majority of the logic required for <code>maybe</code>, though there is a number of convenience functions and definitions in addition.</p><h3>Applying Applicatives</h3><p>Adding a bit of the Applicative concept to the mix, we can do some quite concise calculations. Now, if we are given:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">int</span><span> </span><span class="token" style="color:#DD4A68">algorithm</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">int</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">int</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>maybe</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> </span><span class="token" style="color:#DD4A68">maybeGetAValue</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>maybe</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> </span><span class="token" style="color:#DD4A68">maybeGetAnother</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>maybe</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> </span><span class="token" style="color:#DD4A68">maybeGetAThird</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>where <code>ftl::maybe</code> is a type similar to e.g. <code>boost::optional</code>, provided by FTL (mostly to make sure there are no external dependencies save the standard library).</p><p>Then we can compute:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:slategray">/* ftl::operator% is short for ftl::fmap, basically the classic &quot;map&quot; function
</span><span class="token" style="color:slategray"> * of functional programming.
</span><span class="token" style="color:slategray"> * Similarly, ftl::operator* is short for ftl::aapply, the work horse function of
</span><span class="token" style="color:slategray"> * applicative programming style. It basically applies a function (the left hand
</span><span class="token" style="color:slategray"> * side) to one argument at a time (the right hand side).
</span><span class="token" style="color:slategray"> */</span><span>
</span><span></span><span class="token" style="color:#07a">using</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#07a">operator</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">%</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">using</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#07a">operator</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">auto</span><span> result </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span>
</span><span>	ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">curry</span><span class="token" style="color:#999">(</span><span>algorithm</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">%</span><span> </span><span class="token" style="color:#DD4A68">maybeGetAValue</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span> </span><span class="token" style="color:#DD4A68">maybeGetAnother</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span> </span><span class="token" style="color:#DD4A68">maybeGetAThird</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>which would compute the result of algorithm, but only if every one of the <code>maybe</code> functions returned a value.</p><p>In other words, without Functor&#x27;s <code>fmap</code> and Applicative&#x27;s <code>aapply</code>, it would have looked something like:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>maybe</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> result</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">auto</span><span> x </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">maybeGetAValue</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> y </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">maybeGetAnother</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> z </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">maybeGetAThird</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">if</span><span class="token" style="color:#999">(</span><span>x</span><span class="token" style="color:#999">.</span><span>is</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;&amp;</span><span> y</span><span class="token" style="color:#999">.</span><span>is</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;&amp;</span><span> z</span><span class="token" style="color:#999">.</span><span>is</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>    result </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">value</span><span class="token" style="color:#999">(</span><span class="token" style="color:#DD4A68">algorithm</span><span class="token" style="color:#999">(</span><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>get</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">(</span><span>x</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>get</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">(</span><span>y</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>get</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">(</span><span>z</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#999">}</span></code></pre><p>If <code>algorithm</code> had happened to be wrapped in an <code>ftl::function</code>, or else be one of the built-in, curried-by-default function objects of FTL, then the <code>curry</code> call could have been elided for even cleaner code.</p><p>Exactly what operation is done by <code>apply</code> varies from type to type. For example, with containers, it generally implies combining their elements in every possible combination. Thus</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#DD4A68">curry</span><span class="token" style="color:#999">(</span><span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>plus</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">%</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>list</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">{</span><span class="token" style="color:#905">1</span><span class="token" style="color:#999">,</span><span class="token" style="color:#905">2</span><span class="token" style="color:#999">}</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>list</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">{</span><span class="token" style="color:#905">5</span><span class="token" style="color:#999">,</span><span class="token" style="color:#905">10</span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">;</span></code></pre><p>can be read as &quot;for each element in <code>{1,2}</code>, combine it using <code>std::plus&lt;int&gt;</code> with each element in <code>{5,10}</code>&quot;, resulting in the list <code>{6, 11, 7, 12}</code>. Of course, what happens on a more technical level is that <code>std::plus&lt;int&gt;</code> is partially applied to each element in the first list, resulting in a list of unary functions, that in turn gets applied to each element in the second list.</p><p>A much less technical way of thinking—to gain some intuition for how applicative expressions behave—could be that <code>operator%</code> is an alias for function application, and <code>operator*</code> separates parameters. Except the parameters happen to be wrapped in some &quot;context&quot; or &quot;container&quot;.</p><p>This type of function application scales to arbitrary arity.</p><h3>Transformers</h3><p>No, not as in Optimus Prime! As in a monad transformer: a type transformer that takes one monad as parameter and &quot;magically&quot; adds functionality to it in the form of one of many other monads. For example, let&#x27;s say you want to add the functionality of the <code>maybe</code> monad to the list monad. You&#x27;d have to create a new type that combines the powers, then write all of those crazy monad instances and whatnot, right? Wrong!</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">template</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">typename</span><span> </span><span class="token" style="color:#DD4A68">T</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span>
</span><span></span><span class="token" style="color:#07a">using</span><span> listM </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>maybeT</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>list</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span>T</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;&gt;</span><span class="token" style="color:#999">;</span></code></pre><p>Bam! All the powers of lists and <code>maybe</code>s in one! What exactly does that mean though? Well, let&#x27;s see if we can get an intuition for it.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:slategray">// With the inplace tag, we can call list&#x27;s constructor directly</span><span>
</span><span>listM</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> ms</span><span class="token" style="color:#999">{</span><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">inplace_tag</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">value</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">1</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>maybe</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">{</span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">,</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">value</span><span class="token" style="color:#999">(</span><span class="token" style="color:#905">2</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:slategray">// Kind of useless, but demonstrates what&#x27;s going on</span><span>
</span><span></span><span class="token" style="color:#07a">for</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">auto</span><span> m </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>ms</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>    m</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">matchE</span><span class="token" style="color:#999">(</span><span>
</span><span>        </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">int</span><span> x</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>cout </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;&lt;</span><span> x </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;&lt;</span><span> </span><span class="token" style="color:#690">&quot;, &quot;</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">,</span><span>
</span><span>        </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span>ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>Nothing</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>cout </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;&lt;</span><span> </span><span class="token" style="color:#690">&quot;nothing, &quot;</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span>
</span><span>    </span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#999">}</span><span>
</span><span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>cout </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;&lt;</span><span> std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>endl</span><span class="token" style="color:#999">;</span></code></pre><p>If run, the above would produce:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>1, nothing, 2, </span></code></pre><p>So, pretty much a list of <code>maybe</code>s then, what&#x27;s the point? The point is, the new type <code>listM</code> is a monad, in pretty much the same way as <code>std::list</code> is, <em>except</em> we can apply, bind, and map functions that work with <code>T</code>s. That is, given the above list, <code>ms</code>, we can do:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">auto</span><span> ns </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">int</span><span> x</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> </span><span class="token" style="color:#07a">return</span><span> x</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-</span><span class="token" style="color:#905">1</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">%</span><span> ms</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:slategray">// Let&#x27;s say this invokes the same print loop as before</span><span>
</span><span></span><span class="token" style="color:#DD4A68">print</span><span class="token" style="color:#999">(</span><span>ns</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>Same deal, but if <code>ms</code> was a regular, untransformed list of <code>maybe</code>:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">auto</span><span> ns </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span>maybe</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span> x</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span>
</span><span>    </span><span class="token" style="color:#07a">return</span><span> x</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">match</span><span class="token" style="color:#999">(</span><span>
</span><span>        </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">int</span><span> x</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> </span><span class="token" style="color:#07a">return</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">value</span><span class="token" style="color:#999">(</span><span>x</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-</span><span class="token" style="color:#905">1</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">,</span><span>
</span><span>        </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span>otherwise</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span> </span><span class="token" style="color:#07a">return</span><span> ftl</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>nothing</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span class="token" style="color:#07a">int</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&gt;</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:#999">}</span><span>
</span><span>    </span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#999">}</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">%</span><span> ms</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:#DD4A68">print</span><span class="token" style="color:#999">(</span><span>ns</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>Output (in both cases):</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>0, nothing, 1, </span></code></pre><p>So, basically, this saves us the trouble of having to check for nothingness in the elements of <code>ns</code> (coincidentally—or not—exactly what the maybe monad does: allow us to elide lots of ifs or pattern matches).</p><p>Right, this is kinda neat, but not really all that exciting yet. The excitement comes when we stop to think a bit before we just arbitrarily throw together a couple of monads. For instance, check out the magic of the <code>either</code>-transformer on top of the <code>function</code> monad in the parser generator tutorial <a href="docs/Parsec-II.md">part 2</a>.</p><h3>Yet More Concepts</h3><p>In addition to the above concepts, FTL contains several more of the classic Haskell type classes: Monoids, Foldables, Zippables, and Orderables. These all express nice and abstracted interfaces that apply to many types, both built-in, standard library ones, and user defined ones (assuming one adds a concept instance). For instance, the code below uses the fact that an ordering is a Monoid to sort a vector of <code>MyType</code> by first one of its properties, then another.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">using</span><span> </span><span class="token" style="color:#07a">namespace</span><span> ftl</span><span class="token" style="color:#999">;</span><span>
</span><span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">sort</span><span class="token" style="color:#999">(</span><span>vec</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">begin</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> vec</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">end</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span>
</span><span>    </span><span class="token" style="color:#DD4A68">asc</span><span class="token" style="color:#999">(</span><span class="token" style="color:#DD4A68">comparing</span><span class="token" style="color:#999">(</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span>MyType</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>someProperty</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">^</span><span> </span><span class="token" style="color:#DD4A68">comparing</span><span class="token" style="color:#999">(</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span>MyType</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span>anotherProperty</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span>
</span><span></span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>The equivalent version without FTL might look a bit like this:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-cpp" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>std</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">::</span><span class="token" style="color:#DD4A68">sort</span><span class="token" style="color:#999">(</span><span>vec</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">begin</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> vec</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">end</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#999">[</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">const</span><span> MyType</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span> lhs</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> MyType</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span> rhs</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">{</span><span>
</span><span>    </span><span class="token" style="color:#07a">return</span><span> lhs</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">someProperty</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> rhs</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">someProperty</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span>
</span><span>        </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">?</span><span> lhs</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">anotherProperty</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span> rhs</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">anotherProperty</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span>
</span><span>        </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">:</span><span> lhs</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">someProperty</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span> rhs</span><span class="token" style="color:#999">.</span><span class="token" style="color:#DD4A68">someProperty</span><span class="token" style="color:#999">(</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#999">}</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>Personally, I find the former a lot cleaner and easier to read. The sort order is explicitly stated (<code>asc</code>), and then it just straight up says that we sort by comparing first <code>someProperty</code> and then <code>anotherProperty</code>. Fewer chances of subtle typos, less chance of screwing up the comparisons, much easier to extend, what&#x27;s not to like?</p></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/beark-ftl","name":"beark/ftl","licence":"Zlib","description":"C++ template library for fans of functional programming","readme":"FTL - The Functional Template Library\n=====================================\n\n[![Build Status](https://travis-ci.org/beark/ftl.png?branch=master)](https://travis-ci.org/beark/ftl)\n\nC++ template library for fans of functional programming.\n\nThis project is currently on hiatus. Not sure when/if I'll resume work on it.\n\nIf you want to play around with it anyway, you need to compile in C++11 mode with gcc-4.8 or later or clang-3.2 or later. Not sure if newer MSVC versions would work or not.\n\nTutorials\n---------\n* [Parser Combinator Part I: Simple Parser](docs/Parsec-I.md)\n* [Parser Combinator Part II: Parser Generator Library](docs/Parsec-II.md)\n\nShowcases\n---------\nA couple of quick showcases of some rather neat things the FTL gives you.\n\n### Curried Function Calling\nOne of the typically functional conventions brought to C++ by FTL is support for curried functions and function objects. A curried function is an n-ary function that can be invoked one argument at a time; each step returning a _new_ function object of arity _n-1_. Once enough parameters have been applied (when _n_ reaches _0_), the actual computation is performed and the result is returned. One of the uses of this is to achieve very convenient partial function application. For example:\n```cpp\nauto plus = ftl::curry(std::plus\u003cint\u003e);\nauto addOne = plus(1);\n\nauto x = addOne(2); // x = 3\nauto y = addOne(x); // y = 4\n```\nAs mentioned, all of the function objects provided by FTL are curried by default and do not require an `ftl::curry` call first. Partial application is thus in many cases extremely concise and clean. Note, however, that without, for instance, a wrapping lambda function, it is not possible to partially apply parameters other than in the exact order they appear. For example, the following are all valid:\n```cpp\nauto f = curriedTernaryFn(1);\nauto g = curriedTernaryFn(1,2);\n\nf(2)(3) == f(2,3) \u0026\u0026 f(2,3) == g(3); // true\n```\nBut it is not possible to \"skip\" a parameter or leave a placeholder, as in:\n```cpp\nusing std::placeholders::_1;\nauto f = std::bind(ternaryFn, _1, 2, 3);\n```\nCurrying by itself is a very nice thing to have, but what _truly_ makes it shine is when used in combination with e.g. higher order functions. See for instance applicative style coding, which is not nearly as nice without currying.\n\n### Expanding The Standard Library\nOne of the nice things about FTL is that it does not try to replace or supercede the standard library, it tries to _expand_ it when possible. These expansions include giving existing types concept instances for e.g. Functor, Monad, Monoid, and others. For example, in FTL, `std::shared_ptr` is a monad. This means we can sequence a series of operations working on shared pointers without ever having to explicitly check for validity\u0026mdash;while still being assured there are no attempts to access an invalid pointer.\n\nFor example, given\n```cpp\nshared_ptr\u003ca\u003e foo();\nshared_ptr\u003cb\u003e bar(a);\n```\n\nWe can simply write\n```cpp\nshared_ptr\u003cb\u003e ptr = foo() \u003e\u003e= bar;\n```\n\nInstead of\n```cpp\nshared_ptr\u003cb\u003e ptr(nullptr);\nauto ptra = foo();\nif(ptra) {\n    ptr = bar(*ptra);\n}\n```\n\nWhich would be the equivalent FTL-less version of the above.\n\nMonadic code may perhaps often look strange if you're not used to all the operators, but once you've got that, reading it becomes amazingly easy and clear. `operator\u003e\u003e=` above is used to sequence two monadic computations, where the second is dependant on the result of the first. Exactly what it does varies with monad instance, but in the case of `shared_ptr`, it essentially performs `nullptr` checks and either aborts the expression (returning a `nullptr` initialised `shared_ptr`), or simply passes the valid result forward.\n\nOther types that have been similarly endowed with new powers include: `std::future`, `std::list`, `std::vector`, `std::forward_list`, `std::map`, `std::unordered_map`, `std::set`, and more.\n\n### Sum/Union Types With Pattern Matching\nFor those not familiar with sum types, they can be viewed as tagged unions. In other words, they are defined at compile time by a set of possible types, and at run-time their value will be of exactly one of those types at any particular instance. A quick example:\n```cpp\nftl::sum_type\u003cstd::string,int\u003e x{ftl::constructor\u003cint\u003e(), 3};\n```\nHere, `x`, can take on any value that is either of type `std::string` or `int` and we've initialised it to be the integer value `3`. It is necessary to use the `constructor\u003cT\u003e` tag to specify what type to initialise to, because some types may have constructors accepting similar or even the same arguments.\n\nOnce we have our sum type, we can now pattern match\u0026mdash;or `switch` on its type, if you prefer\u0026mdash;to get a guaranteed safe way of accessing its value:\n```cpp\nint y = x.match(\n    [](int x){ return x+1; },           // This function will be invoked, with\n                                        // 3 as parameter\n\n    [](const std::string\u0026){ return 0; } // This function would have been invoked\n                                        // if x was a string\n);\n```\nUnlike in a language with first class support for pattern matching, in FTL we are unfortunately forced to use functions as match clauses, as you can see above. This makes it slightly less compelling, but we do get the same static guarantees at least: FTL checks at compile time that you've covered every possible type the matched sum type could take on.\n\nNote that `match` must return a value by default, to encourage the functional way where everything is an expression and therefore returns a value. This means, of course, that all match clauses must return values such that `std::common_type` can find a common type they are all implicitly convertible to.\n\nIf the above expression-semantic of `match` is not actually desirable, there is also `matchE`, which does \"effectful\" matches:\n```cpp\nx.matchE(\n    [](int\u0026 x){ ++x; },\n    [](const std::string\u0026 x){ std::cout \u003c\u003c x; }\n);\n```\n\nAnother possible point of inconvenience is if we have a complicated sum type of many sub-types. It can be quite a bother to write out every match case explicitly then, especially if we're only interested in one or a couple. Enter `otherwise`:\n```cpp\nftl::sum_type\u003cA,B,C,D\u003e x{...};\nauto r = x.match(\n    [](const B\u0026 b){ return f(b); }, // This function will be invoked only if\n                                    // x's value is of type B\n\n    [](otherwise){ return g(); }    // This function will be invoked if x's\n                                    // value is of any type except B\n);\n```\nIt is of course possible to have several specific match clauses before the otherwise-clause, but make sure to always put `otherwise` last\u0026mdash;or else any clause appearing below it will never actually be executed. Simply put, matching is done in the order the expressions appear.\n\nThe true usefulness of `sum_type` isn't so much the case where you use it directly. It's when you use it to quickly and cleanly create new data types. For example, did you know both `ftl::maybe` and `ftl::either` are really just simple type aliases of `sum_type`? It's true, `maybe` is defined simply as:\n```cpp\ntemplate\u003ctypename T\u003e\nusing maybe = sum_type\u003cT,Nothing\u003e;\n```\nThat takes care of the vast majority of the logic required for `maybe`, though there is a number of convenience functions and definitions in addition.\n\n### Applying Applicatives\nAdding a bit of the Applicative concept to the mix, we can do some quite concise calculations. Now, if we are given:\n```cpp\nint algorithm(int, int, int);\nftl::maybe\u003cint\u003e maybeGetAValue();\nftl::maybe\u003cint\u003e maybeGetAnother();\nftl::maybe\u003cint\u003e maybeGetAThird();\n```\nwhere `ftl::maybe` is a type similar to e.g. `boost::optional`, provided by FTL (mostly to make sure there are no external dependencies save the standard library).\n\nThen we can compute:\n```cpp\n/* ftl::operator% is short for ftl::fmap, basically the classic \"map\" function\n * of functional programming.\n * Similarly, ftl::operator* is short for ftl::aapply, the work horse function of\n * applicative programming style. It basically applies a function (the left hand\n * side) to one argument at a time (the right hand side).\n */\nusing ftl::operator%;\nusing ftl::operator*;\nauto result =\n\tftl::curry(algorithm) % maybeGetAValue() * maybeGetAnother() * maybeGetAThird();\n```\nwhich would compute the result of algorithm, but only if every one of the `maybe` functions returned a value.\n\nIn other words, without Functor's `fmap` and Applicative's `aapply`, it would have looked something like:\n```cpp\nftl::maybe\u003cint\u003e result;\nauto x = maybeGetAValue(), y = maybeGetAnother(), z = maybeGetAThird();\nif(x.is\u003cint\u003e() \u0026\u0026 y.is\u003cint\u003e() \u0026\u0026 z.is\u003cint\u003e()) {\n    result = ftl::value(algorithm(ftl::get\u003cint\u003e(x), ftl::get\u003cint\u003e(y), ftl::get\u003cint\u003e(z)));\n}\n```\nIf `algorithm` had happened to be wrapped in an `ftl::function`, or else be one of the built-in, curried-by-default function objects of FTL, then the `curry` call could have been elided for even cleaner code.\n\nExactly what operation is done by `apply` varies from type to type. For example, with containers, it generally implies combining their elements in every possible combination. Thus\n```cpp\ncurry(std::plus\u003cint\u003e) % std::list\u003cint\u003e{1,2} * std::list\u003cint\u003e{5,10};\n```\ncan be read as \"for each element in `{1,2}`, combine it using `std::plus\u003cint\u003e` with each element in `{5,10}`\", resulting in the list `{6, 11, 7, 12}`. Of course, what happens on a more technical level is that `std::plus\u003cint\u003e` is partially applied to each element in the first list, resulting in a list of unary functions, that in turn gets applied to each element in the second list.\n\nA much less technical way of thinking\u0026mdash;to gain some intuition for how applicative expressions behave\u0026mdash;could be that `operator%` is an alias for function application, and `operator*` separates parameters. Except the parameters happen to be wrapped in some \"context\" or \"container\".\n\nThis type of function application scales to arbitrary arity.\n\n### Transformers\nNo, not as in Optimus Prime! As in a monad transformer: a type transformer that takes one monad as parameter and \"magically\" adds functionality to it in the form of one of many other monads. For example, let's say you want to add the functionality of the `maybe` monad to the list monad. You'd have to create a new type that combines the powers, then write all of those crazy monad instances and whatnot, right? Wrong!\n\n```cpp\ntemplate\u003ctypename T\u003e\nusing listM = ftl::maybeT\u003cstd::list\u003cT\u003e\u003e;\n```\nBam! All the powers of lists and `maybe`s in one! What exactly does that mean though? Well, let's see if we can get an intuition for it.\n\n```cpp\n// With the inplace tag, we can call list's constructor directly\nlistM\u003cint\u003e ms{ftl::inplace_tag(), ftl::value(1), ftl::maybe\u003cint\u003e{}, ftl::value(2)};\n\n// Kind of useless, but demonstrates what's going on\nfor(auto m : *ms) {\n    m.matchE(\n        [](int x){ std::cout \u003c\u003c x \u003c\u003c \", \"; },\n        [](ftl::Nothing){ std::cout \u003c\u003c \"nothing, \"; }\n    );\n}\nstd::cout \u003c\u003c std::endl;\n```\nIf run, the above would produce:\n```\n1, nothing, 2, \n```\nSo, pretty much a list of `maybe`s then, what's the point? The point is, the new type `listM` is a monad, in pretty much the same way as `std::list` is, _except_ we can apply, bind, and map functions that work with `T`s. That is, given the above list, `ms`, we can do:\n\n```cpp\nauto ns = [](int x){ return x-1; } % ms;\n\n// Let's say this invokes the same print loop as before\nprint(ns);\n``` \nSame deal, but if `ms` was a regular, untransformed list of `maybe`:\n```cpp\nauto ns = [](maybe\u003cint\u003e x){\n    return x.match(\n        [](int x){ return ftl::value(x-1); },\n        [](otherwise){ return ftl::nothing\u003cint\u003e(); }\n    );\n} % ms;\n\nprint(ns);\n``` \nOutput (in both cases):\n```\n0, nothing, 1, \n```\nSo, basically, this saves us the trouble of having to check for nothingness in the elements of `ns` (coincidentally\u0026mdash;or not\u0026mdash;exactly what the maybe monad does: allow us to elide lots of ifs or pattern matches). \n\nRight, this is kinda neat, but not really all that exciting yet. The excitement comes when we stop to think a bit before we just arbitrarily throw together a couple of monads. For instance, check out the magic of the `either`-transformer on top of the `function` monad in the parser generator tutorial [part 2](docs/Parsec-II.md).\n\n### Yet More Concepts\nIn addition to the above concepts, FTL contains several more of the classic Haskell type classes: Monoids, Foldables, Zippables, and Orderables. These all express nice and abstracted interfaces that apply to many types, both built-in, standard library ones, and user defined ones (assuming one adds a concept instance). For instance, the code below uses the fact that an ordering is a Monoid to sort a vector of `MyType` by first one of its properties, then another.\n```cpp\nusing namespace ftl;\nstd::sort(vec.begin(), vec.end(),\n    asc(comparing(\u0026MyType::someProperty) ^ comparing(\u0026MyType::anotherProperty))\n);\n```\nThe equivalent version without FTL might look a bit like this:\n```cpp\nstd::sort(vec.begin(), vec.end(), [](const MyType\u0026 lhs, const MyType\u0026 rhs){\n    return lhs.someProperty() == rhs.someProperty()\n        ? lhs.anotherProperty() \u003c rhs.anotherProperty()\n        : lhs.someProperty() \u003c rhs.someProperty();\n});\n```\nPersonally, I find the former a lot cleaner and easier to read. The sort order is explicitly stated (`asc`), and then it just straight up says that we sort by comparing first `someProperty` and then `anotherProperty`. Fewer chances of subtle typos, less chance of screwing up the comparisons, much easier to extend, what's not to like?\n\n","versions":[{"ref":"master","manifest":"targets = [ '//:ftl' ]\n","lockFile":"manifest = \"654b0f867d08cd51948006eac0a5ccdc130e7b7ba217e2c08ea5b1a78f6eb1a0\"\n\n","buck":"load('//:subdir_glob.bzl', 'subdir_glob')\n\nprebuilt_cxx_library(\n  name = 'ftl',\n  header_namespace = '',\n  header_only = True,\n  exported_headers = subdir_glob([\n    ('include', '**/*.h')\n  ]),\n  visibility = ['PUBLIC']\n)\n\ncxx_binary(\n  name = 'example',\n  deps = [':ftl'],\n  headers = subdir_glob([\n    ('examples', '**/*.h')\n  ]),\n  srcs = glob(['examples/**/*.cpp'])\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-24T13:10:29Z","updatedUpstream":"2021-01-07T15:02:59Z","contributors":[{"login":"splinterofchaos","avatarUrl":"https://avatars0.githubusercontent.com/u/38515?v=4"},{"login":"rcook","avatarUrl":"https://avatars2.githubusercontent.com/u/425396?v=4"},{"login":"fhahn","avatarUrl":"https://avatars1.githubusercontent.com/u/450489?u=4c84b63d078cd6a10b04d46bdcf1f1605e75bd13\u0026v=4"},{"login":"jaredgrubb","avatarUrl":"https://avatars2.githubusercontent.com/u/1256381?v=4"},{"login":"beark","avatarUrl":"https://avatars1.githubusercontent.com/u/4073478?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":971,"forks":73,"topics":[]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"beark-ftl"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>