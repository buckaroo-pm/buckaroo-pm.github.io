{
  "packageName": "buckaroo-pm/martinmoene-optional-lite",
  "name": "martinmoene/optional-lite",
  "licence": "BSL-1.0",
  "description": "optional lite - A C++17-like optional, a nullable object for C++98, C++11 and later in a single-file header-only  library",
  "readme": "# optional lite: A single-file header-only version of a C++17-like optional, a nullable object for C++98, C++11 and later\n\n[![Language](https://img.shields.io/badge/C%2B%2B-98/11-blue.svg)](https://en.wikipedia.org/wiki/C%2B%2B#Standardization) [![License](https://img.shields.io/badge/license-BSL-blue.svg)](https://opensource.org/licenses/BSL-1.0) [![Build Status](https://travis-ci.org/martinmoene/optional-lite.svg?branch=master)](https://travis-ci.org/martinmoene/optional-lite) [![Build status](https://ci.appveyor.com/api/projects/status/1oq5gjm7bufrv6ib?svg=true)](https://ci.appveyor.com/project/martinmoene/optional-lite) [![Version](https://badge.fury.io/gh/martinmoene%2Foptional-lite.svg)](https://github.com/martinmoene/optional-lite/releases) [![download](https://img.shields.io/badge/latest-download-blue.svg)](https://raw.githubusercontent.com/martinmoene/optional-lite/master/include/nonstd/optional.hpp) [![Conan](https://img.shields.io/badge/on-conan-blue.svg)](https://bintray.com/martinmoene/nonstd-lite/optional-lite%3Anonstd-lite/_latestVersion) [![Try it online](https://img.shields.io/badge/on-wandbox-blue.svg)](https://wandbox.org/permlink/5lJEycDPjE6e02fV)\n\n**Contents**  \n- [Example usage](#example-usage)\n- [In a nutshell](#in-a-nutshell)\n- [License](#license)\n- [Dependencies](#dependencies)\n- [Installation](#installation)\n- [Synopsis](#synopsis)\n- [Comparison of std::optional, optional lite and Boost.Optional](#comparison-of-stdoptional-optional-lite-and-boostoptional)\n- [Reported to work with](#reported-to-work-with)\n- [Building the tests](#building-the-tests)\n- [Implementation notes](#implementation-notes)\n- [Other implementations of optional](#other-implementations-of-optional)\n- [Notes and references](#notes-and-references)\n- [Appendix](#appendix)\n\n\nExample usage\n-------------\n\n```C++\n#include \"nonstd/optional.hpp\"\n\n#include <cstdlib>\n#include <iostream>\n\nusing nonstd::optional;\nusing nonstd::nullopt;\n\noptional<int> to_int( char const * const text )\n{\n    char * pos = NULL;\n    const int value = strtol( text, &pos, 0 );\n\n    return pos == text ? nullopt : optional<int>( value );\n}\n\nint main( int argc, char * argv[] )\n{\n    char * text = argc > 1 ? argv[1] : \"42\";\n\n    optional<int> oi = to_int( text );\n\n    if ( oi ) std::cout << \"'\" << text << \"' is \" << *oi;\n    else      std::cout << \"'\" << text << \"' isn't a number\";\n}\n```\n### Compile and run\n```\nprompt>g++ -Wall -Wextra -std=c++03 -I.. -o to_int.exe to_int.cpp && to_int x1\n'x1' isn't a number\n```\n\nIn a nutshell\n---------------\n**optional lite** is a single-file header-only library to represent optional (nullable) objects and pass them by value. The library aims to provide a [C++17-like optional](http://en.cppreference.com/w/cpp/utility/optional) for use with C++98 and later. If available, std::optional is used. There's also a simpler version, [*optional bare*](https://github.com/martinmoene/optional-bare). Unlike *optional lite*, *optional bare* is limited to default-constructible and copyable types.\n\n**Features and properties of optional lite** are ease of installation (single header), freedom of dependencies other than the standard library and control over object alignment (if needed). *optional lite* shares the approach to in-place tags with [any-lite](https://github.com/martinmoene/any-lite), [expected-lite](https://github.com/martinmoene/expected-lite) and with [variant-lite](https://github.com/martinmoene/variant-lite) and these libraries can be used together.\n\n**Not provided** are reference-type optionals. *optional lite* doesn't handle overloaded *address of* operators.\n\nFor more examples, see [this answer on StackOverflow](http://stackoverflow.com/a/16861022) [8] and the [quick start guide](http://www.boost.org/doc/libs/1_57_0/libs/optional/doc/html/boost_optional/quick_start.html) [9] of Boost.Optional (note that its interface differs from *optional lite*).\n\n\nLicense\n-------\n*optional lite* is distributed under the [Boost Software License](LICENSE.txt).\n\n\nDependencies\n------------\n*optional lite* has no other dependencies than the [C++ standard library](http://en.cppreference.com/w/cpp/header).\n\n\nInstallation\n------------\n\n*optional lite* is a single-file header-only library. Put `optional.hpp` in the [include](include) folder directly into the project source tree or somewhere reachable from your project.\n\nOr, if you use the [conan package manager](https://www.conan.io/), follow these steps:\n\n1. Add *nonstd-lite* to the conan remotes:\n\n        conan remote add nonstd-lite https://api.bintray.com/conan/martinmoene/nonstd-lite\n\n2. Add a reference to *optional-lite* to the *requires* section of your project's `conanfile.txt` file:\n\n        [requires]\n        optional-lite/3.1.1@nonstd-lite/testing\n\n3. Run conan's install command:\n\n        conan install\n\n\nSynopsis\n--------\n\n**Contents**  \n[Types in namespace nonstd](#types-in-namespace-nonstd)  \n[Interface of *optional lite*](#interface-of-optional-lite)  \n[Algorithms for *optional lite*](#algorithms-for-optional-lite)  \n[Configuration](#configuration)  \n\n### Types and values in namespace nonstd\n\n| Purpose               | Type / value | Object |\n|-----------------------|--------------|--------|\n| To be, or not         | template< typename T ><br>class **optional**; |&nbsp;|\n| Disengaging           | struct **nullopt_t**;                | nullopt_t nullopt; |\n| Error reporting       | class **bad_optional_access**;       |&nbsp;  |\n| In-place construction | struct **in_place_tag**              | &nbsp; |\n| &nbsp;                | **in_place**                         | select type or index for in-place construction |\n| &nbsp;                | **in_place_type**                    | select type for in-place construction |\n| &emsp;(variant)       | **in_place_index**                   | select index for in-place construction |\n| &nbsp;                | **nonstd_lite_in_place_type_t**( T)  | macro for alias template in_place_type_t&lt;T>  |\n| &emsp;(variant)       | **nonstd_lite_in_place_index_t**( T )| macro for alias template in_place_index_t&lt;T> |\n\n### Interface of *optional lite*\n\n| Kind         | Std  | Method                                       | Result |\n|--------------|------|---------------------------------------------|--------|\n| Construction |&nbsp;| **optional**() noexcept                          | default construct a nulled object |\n| &nbsp;       |&nbsp;| **optional**( nullopt_t ) noexcept               | explicitly construct a nulled object |\n| &nbsp;       |&nbsp;| **optional**( optional const & rhs )             | move-construct from an other optional |\n| &nbsp;       | C++11| **optional**( optional && rhs ) noexcept(...)    | move-construct from an other optional |\n| &nbsp;       |&nbsp;| **optional**( value_type const & value )         | copy-construct from a value |\n| &nbsp;       | C++11| **optional**( value_type && value )              | move-construct from a value |\n| &nbsp;       | C++11| **explicit optional**( in_place_type_t&lt;T>, Args&&... args ) | in-place-construct type T |\n| &nbsp;       | C++11| **explicit optional**( in_place_type_t&lt;T>, std::initializer_list&lt;U> il, Args&&... args ) | in-place-construct type T |\n| Destruction  |&nbsp;| **~optional**()                                  | destruct current content, if any |\n| Assignment   |&nbsp;| optional & **operator=**( nullopt_t )            | null the object;<br>destruct current content, if any |\n| &nbsp;       |&nbsp;| optional & **operator=**( optional const & rhs ) | copy-assign from other optional;<br>destruct current content, if any |\n| &nbsp;       | C++11| optional & **operator=**( optional && rhs )      | move-assign from other optional;<br>destruct current content, if any |\n| &nbsp;       | C++11| template< class U, ...><br>**optional & operator=( U && v ) | move-assign from a value;<br>destruct current content, if any |\n| &nbsp;       | C++11| template< class... Args ><br>T & **emplace**( Args&&... args ) |  emplace type T |\n| &nbsp;       | C++11| template< class U, class... Args ><br>T & **emplace**( std::initializer_list&lt;U> il, Args&&... args ) |  emplace type T |\n| Swap         |&nbsp;| void **swap**( optional & rhs ) noexcept(...)    | swap with rhs |\n| Content      |&nbsp;| value_type const \\* **operator ->**() const       | pointer to current content (const);<br>must contain value |\n| &nbsp;       |&nbsp;| value_type \\* **operator ->**()                   | pointer to current content (non-const);<br>must contain value |\n| &nbsp;       |&nbsp;| value_type const & **operator \\***() &            | the current content (const ref);<br>must contain value |\n| &nbsp;       |&nbsp;| value_type & **operator \\***() &                  | the current content (non-const ref);<br>must contain value |\n| &nbsp;       | C++11| value_type const & **operator \\***() &&           | the current content (const ref);<br>must contain value |\n| &nbsp;       | C++11| value_type & **operator \\***() &&                 | the current content (non-const ref);<br>must contain value |\n| State        |&nbsp;| operator **bool**() const                        | true if content is present |\n| &nbsp;       |&nbsp;| bool **has_value**() const                       | true if content is present |\n| &nbsp;       |&nbsp;| value_type const & **value**() &                 | the current content (const ref);<br>throws bad_optional_access if nulled |\n| &nbsp;       |&nbsp;| value_type & **value**() &                       | the current content (non-const ref);<br>throws bad_optional_access if nulled |\n| &nbsp;       | C++11| value_type const & **value**() &&                | the current content (const ref);<br>throws bad_optional_access if nulled |\n| &nbsp;       | C++11| value_type & **value**() &&                      | the current content (non-const ref);<br>throws bad_optional_access if nulled |\n| &nbsp;       |<C++11| value_type **value_or**( value_type const & default_value ) const | the value, or default_value if nulled<br>value_type must be copy-constructible |\n| &nbsp;       | C++11| value_type **value_or**( value_type && default_value ) &  | the value, or default_value if nulled<br>value_type must be copy-constructible |\n| &nbsp;       | C++11| value_type **value_or**( value_type && default_value ) && | the value, or default_value if nulled<br>value_type must be copy-constructible |\n| Modifiers    |&nbsp;| void **reset**() noexcept                        | make empty |\n\n\n### Algorithms for *optional lite*\n\n| Kind                     | Std  | Function |\n|--------------------------|------|----------|\n| Relational operators     |&nbsp;| &nbsp;   |\n| ==                       |&nbsp;| template< typename T ><br>bool **operator==**( optional<T> const & x, optional<T> const & y ) |\n| !=                       |&nbsp;| template< typename T ><br>bool **operator!=**( optional<T> const & x, optional<T> const & y ) |\n| <                        |&nbsp;| template< typename T ><br>bool **operator<**( optional<T> const & x, optional<T> const & y )  |\n| >                        |&nbsp;| template< typename T ><br>bool **operator>**( optional<T> const & x, optional<T> const & y )  |\n| <=                       |&nbsp;| template< typename T ><br>bool **operator<=*( optional<T> const & x, optional<T> const & y ) |\n| >=                       |&nbsp;| template< typename T ><br>bool **operator>=*( optional<T> const & x, optional<T> const & y ) |\n| Comparison with nullopt  |&nbsp;| &nbsp;   |\n| ==                       |&nbsp;| template< typename T ><br>bool **operator==**( optional<T> const & x, nullopt_t ) noexcept |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator==**( nullopt_t, optional<T> const & x ) noexcept |\n| !=                       |&nbsp;| template< typename T ><br>bool **operator!=**( optional<T> const & x, nullopt_t ) noexcept |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator!=**( nullopt_t, optional<T> const & x ) noexcept |\n| <                        |&nbsp;| template< typename T ><br>bool **operator<**( optional<T> const &, nullopt_t ) noexcept    |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator<**( nullopt_t, optional<T> const & x ) noexcept  |\n| <=                       |&nbsp;| template< typename T ><br>bool **operator<=**( optional<T> const & x, nullopt_t ) noexcept |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator<=**( nullopt_t, optional<T> const & ) noexcept   |\n| >                        |&nbsp;| template< typename T ><br>bool **operator>**( optional<T> const & x, nullopt_t ) noexcept  |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator>**( nullopt_t, optional<T> const & ) noexcept    |\n| >=                       |&nbsp;| template< typename T ><br>bool **operator>=**( optional<T> const &, nullopt_t ) noexcept   |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator>=**( nullopt_t, optional<T> const & x ) noexcept |\n| Comparison with T        |&nbsp;| &nbsp;   |\n| ==                       |&nbsp;| template< typename T ><br>bool **operator==**( optional<T> const & x, const T& v )  |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator==**( T const & v, optional<T> const & x ) |\n| !=                       |&nbsp;| template< typename T ><br>bool **operator!=**( optional<T> const & x, const T& v )  |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator!=**( T const & v, optional<T> const & x ) |\n| <                        |&nbsp;| template< typename T ><br>bool **operator<**( optional<T> const & x, const T& v )   |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator<**( T const & v, optional<T> const & x )  |\n| <=                       |&nbsp;| template< typename T ><br>bool **operator<=**( optional<T> const & x, const T& v )  |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator<=**( T const & v, optional<T> const & x ) |\n| >                        |&nbsp;| template< typename T ><br>bool **operator>**( optional<T> const & x, const T& v )   |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator>**( T const & v, optional<T> const & x )  |\n| >=                       |&nbsp;| template< typename T ><br>bool **operator>=**( optional<T> const & x, const T& v )  |\n| &nbsp;                   |&nbsp;| template< typename T ><br>bool **operator>=**( T const & v, optional<T> const & x ) |\n| Specialized algorithms   |&nbsp;| &nbsp;   |\n| swap                     |&nbsp;| template< typename T ><br>void **swap**( optional<T> & x, optional<T> & y ) noexcept(...) |\n| create                   |<C++11| template< typename T ><br>optional&lt;T> **make_optional**( T const & v )      |\n| &nbsp;                   | C++11| template< class T ><br>optional< typename std::decay&lt;T>::type > **make_optional**( T && v ) |\n| &nbsp;                   | C++11| template< class T, class...Args ><br>optional&lt;T> **make_optional**( Args&&... args ) |\n| &nbsp;                   | C++11| template< class T, class U, class... Args ><br>optional&lt;T> **make_optional**( std::initializer_list&lt;U> il, Args&&... args ) |\n| hash                     | C++11| template< class T ><br>class **hash**< nonstd::optional&lt;T> > |\n\n\n### Configuration\n\n#### Standard selection macro\n\\-D<b>optional\\_CPLUSPLUS</b>=199711L\nDefine this macro to override the auto-detection of the supported C++ standard, if your compiler does not set the `__cplusplus` macro correctly.\n\n#### Disable exceptions\n-D<b>optional_CONFIG_NO_EXCEPTIONS</b>=0\nDefine this to 1 if you want to compile without exceptions. If not defined, the header tries and detect if exceptions have been disabled (e.g. via `-fno-exceptions`). Default is undefined.\n\n#### Macros to control alignment\n\nIf *optional lite* is compiled as C++11 or later, C++11 alignment facilities are used for storage of the underlying object. When compiled as pre-C++11, *optional lite* tries to determine proper alignment itself. If this doesn't work out, you can control alignment via the following macros. See also section [Implementation notes](#implementation-notes).\n\n-D<b>optional_CONFIG_MAX_ALIGN_HACK</b>=0  \nDefine this to 1 to use the *max align hack* for alignment. Default is 0.\n\n-D<b>optional_CONFIG_ALIGN_AS</b>=*pod-type*  \nDefine this to the *pod-type* you want to align to (no default).\n\n-D<b>optional_CONFIG_ALIGN_AS_FALLBACK</b>=*pod-type*  \nDefine this to the *pod-type* to use for alignment if the algorithm of *optional lite* cannot find a suitable POD type to use for alignment. Default is double.\n\n\nComparison of std::optional, optional lite and Boost.Optional\n-------------------------------------------------------------\n\n*optional lite* is inspired on std::optional, which in turn is inspired on Boost.Optional. Here are the significant differences.\n\n| Aspect                            | std::optional         | optional lite        | Boost.Optional |\n|-----------------------------------|-----------------------|----------------------|----------------|\n| Move semantics                    | yes                   | C++11                | no             |\n| noexcept                          | yes                   | C++11                | no             |\n| Hash support                      | yes                   | C++11                | no             |\n| Throwing value accessor           | yes                   | yes                  | no             |\n| Literal type\t                    | partially             | C++11/14             | no             |\n| In-place construction\t            | emplace, tag in_place | emplace, tag in_place| utility in_place_factory |\n| Disengaged state tag\t            | nullopt\t            | nullopt              | none           |\n| optional references               | no                    | no                   | yes            |\n| Conversion from optional&lt;U\\><br>to optional&lt;T\\>    | no | no               | yes            |\n| Duplicated interface functions 1) | no                    | no                   | yes            |\n| Explicit convert to ptr (get_ptr)\t| no                    | no                   | yes            |\n\n1) is_initialized(), reset(), get().\n\n\nReported to work with\n---------------------\nThe table below mentions the compiler versions *optional lite* is reported to work with.\n\nOS        | Compiler   | Versions |\n---------:|:-----------|:---------|\nWindows   | Clang/LLVM | ?        |\n&nbsp;    | GCC        | 5.2.0    |\n&nbsp;    | Visual C++<br>(Visual Studio)| 8 (2005), 10 (2010), 11 (2012),<br>12 (2013), 14 (2015) |\nGNU/Linux | Clang/LLVM | 3.5.0    |\n&nbsp;    | GCC        | 4.8.4    |\nOS X      | ?          | ?        |\n\n\nBuilding the tests\n------------------\nTo build the tests you need:\n\n- [CMake](http://cmake.org), version 2.8.12 or later to be installed and in your PATH.\n- A [suitable compiler](#reported-to-work-with).\n\nThe [*lest* test framework](https://github.com/martinmoene/lest)  is included in the [test folder](test).\n\nThe following steps assume that the [*optional lite* source code](https://github.com/martinmoene/optional-lite) has been cloned into a directory named `c:\\optional-lite`.\n\n1. Create a directory for the build outputs for a particular architecture.\nHere we use c:\\optional-lite\\build-win-x86-vc10.\n\n        cd c:\\optional-lite\n        md build-win-x86-vc10\n        cd build-win-x86-vc10\n\n2. Configure CMake to use the compiler of your choice (run `cmake --help` for a list).\n\n        cmake -G \"Visual Studio 10 2010\" -DOPTIONAL_LITE_OPT_BUILD_TESTS=ON ..\n\n3. Build the test suite in the Debug configuration (alternatively use Release).    \n\n        cmake --build . --config Debug\n\n4. Run the test suite.    \n\n        ctest -V -C Debug\n\nAll tests should pass, indicating your platform is supported and you are ready to use *optional lite*.\n\n\nImplementation notes\n--------------------\n\n### Object allocation and alignment\n\n*optional lite* reserves POD-type storage for an object of the underlying type inside a union to prevent unwanted construction and uses placement new to construct the object when required. Using non-placement new (malloc) to  obtain storage, ensures that the memory is properly aligned for the object's type, whereas that's not the case with placement new.\n\nIf you access data that's not properly aligned, it 1) may take longer than when it is properly aligned (on x86 processors), or 2) it may terminate the program immediately (many other processors).\n\nAlthough the C++ standard does not guarantee that all user-defined types have the alignment of some POD type, in practice it's likely they do [8, part 2].\n\nIf *optional lite* is compiled as C++11 or later, C++11 alignment facilities are used for storage of the underlying object. When compiling as pre-C++11, *optional lite* tries to determine proper alignment using meta programming. If this doesn't work out, you can control alignment via three macros.\n\n*optional lite* uses the following rules for alignment:\n\n1. If the program compiles as C++11 or later, C++11 alignment facilities  are used.\n\n2. If you define -D<b>optional_CONFIG_MAX_ALIGN_HACK</b>=1 the underlying type is aligned as the most restricted type in `struct max_align_t`. This potentially wastes many bytes per optional if the actually required alignment is much less, e.g. 24 bytes used instead of the 2 bytes required.\n\n3. If you define -D<b>optional_CONFIG_ALIGN_AS</b>=*pod-type* the underlying type is aligned as *pod-type*. It's your obligation to specify a type with proper alignment.\n\n4. If you define -D<b>optional_CONFIG_ALIGN_AS_FALLBACK</b>=*pod-type* the fallback type for alignment of rule 5 below becomes *pod-type*. It's your obligation to specify a type with proper alignment.\n\n5. At default, *optional lite* tries to find a POD type with the same alignment as the underlying type.\n\n\tThe algorithm for alignment of 5. is:\n\t- Determine the alignment A of the underlying type using `alignment_of<>`.\n\t- Find a POD type from the list `alignment_types` with exactly alignment A.\n\t- If no such POD type is found, use a type with a relatively strict alignment requirement such as double; this type is specified in  `optional_CONFIG_ALIGN_AS_FALLBACK` (default double).\n\nNote that the algorithm of 5. differs from the one Andrei Alexandrescu uses in [8, part 2].\n\nThe class template `alignment_of<>` is gleaned from [Boost.TypeTraits, alignment_of](http://www.boost.org/doc/libs/1_57_0/libs/type_traits/doc/html/boost_typetraits/reference/alignment_of.html) [11]. The storage type `storage_t<>` is adapted from the one I created for [spike-expected, expected lite](https://github.com/martinmoene/spike-expected) [13].\n\nFor more information on constructed unions and alignment, see [8-12].\n\n\nOther implementations of optional\n---------------------------------\n- Isabella Muerte. [MNMLSTC Core](https://github.com/mnmlstc/core) (C++11).\n- Andrzej Krzemieński. [optional (nullable) objects for C++14](https://github.com/akrzemi1/Optional). Reference implementation.\n- Simon Brand. [C++11/14/17 std::optional with functional-style extensions](https://github.com/TartanLlama/optional).\n\nNotes and references\n--------------------\n[1] CppReference. [Optional](http://en.cppreference.com/w/cpp/utility/optional).\n\n[2] ISO/IEC WG21. [N4606, section 20.6 Optional objects](http://wg21.link/n4606). July 2016.\n\n[3] Fernando Cacciola, Andrzej Krzemieński. [A proposal to add a utility class to represent optional objects (Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3793.html).\n\n[4] Andrzej Krzemieński. [optional (nullable) objects for C++14](https://github.com/akrzemi1/Optional). Reference implementation on GitHub.\n\n[5] Simon Brand. [P0798R0: Monadic operations for std::optional](https://wg21.tartanllama.xyz/monadic-optional).\n\n[6] Simon Brand. [C++11/14/17 std::optional with functional-style extensions ](https://github.com/TartanLlama/optional). Reference implementation on GitHub.\n\n[7] Fernando Cacciola. [Boost.Optional library](http://www.boost.org/doc/libs/1_49_0/libs/optional/doc/html/index.html).\n\n[8] StackOverflow. [How should one use std::optional?](http://stackoverflow.com/a/16861022). Answer by Timothy Shields. 31 May 2013.\n\n[9] Fernando Cacciola. [Boost.Optional Quick start guide](http://www.boost.org/doc/libs/1_57_0/libs/optional/doc/html/boost_optional/quick_start.html).\n\n[10] Andrei Alexandrescu. [Generic<Programming>: Discriminated Unions part 1](http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/2002/cexp2004/alexandr/alexandr.htm), [part 2](http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/2002/cexp2006/alexandr/alexandr.htm), [part 3](http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/2002/cexp2008/alexandr/alexandr.htm). April 2002.\n\n[11] Herb Sutter. [Style Case Study #3: Construction Unions](http://www.gotw.ca/gotw/085.htm). GotW #85. 2009\n\n[12] Kevin T. Manley. [Using Constructed Types in C++ Unions](http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/2002/0208/manley/manley.htm). C/C++ Users Journal, 20(8), August 2002.\n\n[13] StackOverflow. [Determining maximum possible alignment in C++](http://stackoverflow.com/a/3126992).\n\n[14] [Boost.TypeTraits, alignment_of](http://www.boost.org/doc/libs/1_57_0/libs/type_traits/doc/html/boost_typetraits/reference/alignment_of.html) ( [code](http://www.boost.org/doc/libs/1_57_0/boost/type_traits/alignment_of.hpp) ).\n\n[15] Martin Moene. [spike-expected](https://github.com/martinmoene/spike-expected) ([expected-lite.hpp](https://github.com/martinmoene/spike-expected/blob/master/exception_ptr_lite.hpp)).\n\n\nAppendix\n--------\n### A.1 Optional Lite test specification\n\n```\nunion: A C++03 union can only contain POD types\noptional: Allows to default construct an empty optional\noptional: Allows to explicitly construct a disengaged, empty optional via nullopt\noptional: Allows to default construct an empty optional with a non-default-constructible\noptional: Allows to copy-construct from empty optional\noptional: Allows to copy-construct from non-empty optional\noptional: Allows to move-construct from optional (C++11)\noptional: Allows to copy-construct from literal value\noptional: Allows to copy-construct from value\noptional: Allows to move-construct from value (C++11)\noptional: Allows to in-place construct from literal value (C++11)\noptional: Allows to in-place copy-construct from value (C++11)\noptional: Allows to in-place move-construct from value (C++11)\noptional: Allows to in-place copy-construct from initializer-list (C++11)\noptional: Allows to in-place move-construct from initializer-list (C++11)\noptional: Allows to assign nullopt to disengage\noptional: Allows to copy-assign from/to engaged and disengaged optionals\noptional: Allows to move-assign from/to engaged and disengaged optionals (C++11)\noptional: Allows to copy-assign from literal value\noptional: Allows to copy-assign from value\noptional: Allows to move-assign from value (C++11)\noptional: Allows to copy-emplace content from arguments (C++11)\noptional: Allows to move-emplace content from arguments (C++11)\noptional: Allows to copy-emplace content from intializer-list and arguments (C++11)\noptional: Allows to move-emplace content from intializer-list and arguments (C++11)\noptional: Allows to swap with other optional (member)\noptional: Allows to obtain pointer to value via operator->()\noptional: Allows to obtain value via operator*()\noptional: Allows to obtain moved-value via operator*()\noptional: Allows to obtain has_value() via operator bool()\noptional: Allows to obtain value via value()\noptional: Allows to obtain value or default via value_or()\noptional: Allows to obtain moved-value or moved-default via value_or() (C++11)\noptional: Throws bad_optional_access at disengaged access\noptional: Allows to reset content\noptional: Allows to swaps engage state and values (non-member)\noptional: Provides relational operators\noptional: Provides mixed-type relational operators\nmake_optional: Allows to copy-construct optional\nmake_optional: Allows to move-construct optional (C++11)\nmake_optional: Allows to in-place copy-construct optional from arguments (C++11)\nmake_optional: Allows to in-place move-construct optional from arguments (C++11)\nmake_optional: Allows to in-place copy-construct optional from initializer-list and arguments (C++11)\nmake_optional: Allows to in-place move-construct optional from initializer-list and arguments (C++11)\n```\n",
  "versions": [
    {
      "ref": "master",
      "manifest": "targets = [ \"//:optional-lite\" ]",
      "lockFile": "manifest = \"5b184fad0bc9b730884f01c5c637b2807f9f8e7a77dec73019d366ef5945706a\"\n\n",
      "buck": "load('//:subdir_glob.bzl', 'subdir_glob')\n\nprebuilt_cxx_library(\n  name = 'optional-lite',\n  header_namespace = '',\n  header_only = True,\n  exported_headers = subdir_glob([\n    ('include', '**/*.hpp'),\n  ]),\n  visibility = [\n    'PUBLIC',\n  ],\n)\n",
      "bazel": "",
      "deps": [],
      "lock": []
    }
  ],
  "updated": "2019-01-15T17:10:56Z",
  "updatedUpstream": "2021-01-05T16:50:06Z",
  "contributors": [
    {
      "login": "mabraham",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/112395?v=4"
    },
    {
      "login": "Dimon4eg",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/1271541?u=47cdf58df9a734d0b1456bfe657b20d6bed41b5a&v=4"
    },
    {
      "login": "njlr",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/1577531?u=b805a63f8054b62169749f2c9d2e89eb53af57d7&v=4"
    },
    {
      "login": "martinmoene",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/1999290?v=4"
    },
    {
      "login": "agauniyal",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/7630575?u=0cc8856bf0f3b02980d639f042df4265e0988cba&v=4"
    },
    {
      "login": "viettrungluu",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/9117111?v=4"
    },
    {
      "login": "LAJW",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/11063742?v=4"
    },
    {
      "login": "ngrodzitski",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/22771554?u=84c042f5dc975d7835eed9e573b3d5de94e5d192&v=4"
    },
    {
      "login": "past-due",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/30942300?v=4"
    },
    {
      "login": "medithe",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/40990424?v=4"
    }
  ],
  "fundingLinks": [],
  "contactLinks": [],
  "stars": 283,
  "forks": 37,
  "topics": [
    "cpp98",
    "cpp17",
    "no-dependencies",
    "single-file",
    "header-only",
    "optional",
    "optional-implementations"
  ]
}