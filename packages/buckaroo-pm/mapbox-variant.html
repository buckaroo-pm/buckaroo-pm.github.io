<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/mapbox-variant/logo.png"/></div><div><h1>buckaroo-pm/mapbox-variant</h1><div style="max-width:600px">C++11/C++14 Variant</div><br/><div><b>310</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">c-plus-plus</span></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><h1>Mapbox Variant</h1><p>An header-only alternative to <code>boost::variant</code> for C++11 and C++14</p><p><a href="https://travis-ci.org/mapbox/variant"><img src="https://secure.travis-ci.org/mapbox/variant.svg" alt="Build Status"/></a>
<a href="https://ci.appveyor.com/project/Mapbox/variant"><img src="https://ci.appveyor.com/api/projects/status/v9tatx21j1k0fcgy" alt="Build status"/></a>
<a href="https://coveralls.io/r/mapbox/variant?branch=master"><img src="https://coveralls.io/repos/mapbox/variant/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a></p><h2>Introduction</h2><p>Variant&#x27;s basic building blocks are:</p><ul><li><code>variant&lt;Ts...&gt;</code> - a type-safe representation for sum-types / discriminated unions</li><li><code>recursive_wrapper&lt;T&gt;</code> - a helper type to represent recursive &quot;tree-like&quot; variants</li><li><code>apply_visitor(visitor, myVariant)</code> - to invoke a custom visitor on the variant&#x27;s underlying type</li><li><code>get&lt;T&gt;()</code> - a function to directly unwrap a variant&#x27;s underlying type</li><li><code>.match([](Type){})</code> - a variant convenience member function taking an arbitrary number of lambdas creating a visitor behind the scenes and applying it to the variant</li></ul><h3>Basic Usage - HTTP API Example</h3><p>Suppose you want to represent a HTTP API response which is either a JSON result or an error:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>struct Result {
</span>  Json object;
<!-- -->};
<!-- -->
<!-- -->struct Error {
<!-- -->  int32_t code;
<!-- -->  string message;
<!-- -->};
</code></pre><p>You can represent this at type level using a variant which is either an <code>Error</code> or a <code>Result</code>:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>using Response = variant&lt;Error, Result&gt;;
</span>
<!-- -->Response makeRequest() {
<!-- -->  return Error{501, &quot;Not Implemented&quot;};
<!-- -->}
<!-- -->
<!-- -->Response ret = makeRequest();
</code></pre><p>To see which type the <code>Response</code> holds you pattern match on the variant unwrapping the underlying value:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>ret.match([] (Result r) { print(r.object); },
</span>          [] (Error e)  { print(e.message); });
</code></pre><p>Instead of using the variant&#x27;s convenience <code>.match</code> pattern matching function you can create a type visitor functor and use <code>apply_visitor</code> manually:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>struct ResponseVisitor {
</span>  void operator()(Result r) const {
<!-- -->    print(r.object);
<!-- -->  }
<!-- -->
<!-- -->  void operator()(Error e) const {
<!-- -->    print(e.message);
<!-- -->  }
<!-- -->};
<!-- -->
<!-- -->ResponseVisitor visitor;
<!-- -->apply_visitor(visitor, ret);
</code></pre><p>In both cases the compiler makes sure you handle all types the variant can represent at compile.</p><h3>Recursive Variants - JSON Example</h3><p><a href="http://www.json.org/">JSON</a> consists of types <code>String</code>, <code>Number</code>, <code>True</code>, <code>False</code>, <code>Null</code>, <code>Array</code> and <code>Object</code>.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>struct String { string value; };
</span>struct Number { double value; };
<!-- -->struct True   { };
<!-- -->struct False  { };
<!-- -->struct Null   { };
<!-- -->struct Array  { vector&lt;?&gt; values; };
<!-- -->struct Object { unordered_map&lt;string, ?&gt; values; };
</code></pre><p>This works for primitive types but how do we represent recursive types such as <code>Array</code> which can hold multiple elements and <code>Array</code> itself, too?</p><p>For these use cases Variant provides a <code>recursive_wrapper</code> helper type which lets you express recursive Variants.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>struct String { string value; };
</span>struct Number { double value; };
<!-- -->struct True   { };
<!-- -->struct False  { };
<!-- -->struct Null   { };
<!-- -->
<!-- -->// Forward declarations only
<!-- -->struct Array;
<!-- -->struct Object;
<!-- -->
<!-- -->using Value = variant&lt;String, Number, True, False, Null, recursive_wrapper&lt;Array&gt;, recursive_wrapper&lt;Object&gt;&gt;;
<!-- -->
<!-- -->struct Array {
<!-- -->  vector&lt;Value&gt; values;
<!-- -->};
<!-- -->
<!-- -->struct Object {
<!-- -->  unordered_map&lt;string, Value&gt; values;
<!-- -->};
</code></pre><p>For walking the JSON representation you can again either create a <code>JSONVisitor</code>:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>struct JSONVisitor {
</span>
<!-- -->  void operator()(Null) const {
<!-- -->    print(&quot;null&quot;);
<!-- -->  }
<!-- -->
<!-- -->  // same for all other JSON types
<!-- -->};
<!-- -->
<!-- -->JSONVisitor visitor;
<!-- -->apply_visitor(visitor, json);
</code></pre><p>Or use the convenience <code>.match</code> pattern matching function:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>json.match([] (Null) { print(&quot;null&quot;); },
</span>           ...);
</code></pre><p>To summarize: use <code>recursive_wrapper</code> to represent recursive &quot;tree-like&quot; representations:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>struct Empty { };
</span>struct Node;
<!-- -->
<!-- -->using Tree = variant&lt;Empty, recursive_wrapper&lt;Node&gt;&gt;;
<!-- -->
<!-- -->struct Node {
<!-- -->  uint64_t value;
<!-- -->}
</code></pre><h3>Advanced Usage Tips</h3><p>Creating type aliases for variants is a great way to reduce repetition.
Keep in mind those type aliases are not checked at type level, though.
We recommend creating a new type for all but basic variant usage:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>// the compiler can&#x27;t tell the following two apart
</span>using APIResult = variant&lt;Error, Result&gt;;
<!-- -->using FilesystemResult = variant&lt;Error, Result&gt;;
<!-- -->
<!-- -->// new type
<!-- -->struct APIResult : variant&lt;Error, Result&gt; {
<!-- -->  using Base = variant&lt;Error, Result&gt;;
<!-- -->  using Base::Base;
<!-- -->}
</code></pre><h2>Why use Mapbox Variant?</h2><p>Mapbox variant has the same speedy performance of <code>boost::variant</code> but is
faster to compile, results in smaller binaries, and has no dependencies.</p><p>For example on OS X 10.9 with clang++ and libc++:</p><table><thead><tr><th>Test</th><th>Mapbox Variant</th><th>Boost Variant</th></tr></thead><tbody><tr><td>Size of pre-compiled header (release / debug)</td><td>2.8/2.8 MB</td><td>12/15 MB</td></tr><tr><td>Size of simple program linking variant (release / debug)</td><td>8/24 K</td><td>12/40 K</td></tr><tr><td>Time to compile header</td><td>185 ms</td><td>675 ms</td></tr></tbody></table><p>(Numbers from an older version of Mapbox variant.)</p><h2>Goals</h2><p>Mapbox <code>variant</code> has been a very valuable, lightweight alternative for apps
that can use c++11 or c++14 but that do not want a boost dependency.
Mapbox <code>variant</code> has also been useful in apps that do depend on boost, like
mapnik, to help (slightly) with compile times and to majorly lessen dependence
on boost in core headers. The original goal and near term goal is to maintain
external API compatibility with <code>boost::variant</code> such that Mapbox <code>variant</code>
can be a &quot;drop in&quot;. At the same time the goal is to stay minimal: Only
implement the features that are actually needed in existing software. So being
an &quot;incomplete&quot; implementation is just fine.</p><p>Currently Mapbox variant doesn&#x27;t try to be API compatible with the upcoming
variant standard, because the standard is not finished and it would be too much
work. But we&#x27;ll revisit this decision in the future if needed.</p><p>If Mapbox variant is not for you, have a look at <a href="doc/other_implementations.md">these other
implementations</a>.</p><p>Want to know more about the upcoming standard? Have a look at our
<a href="doc/standards_effort.md">overview</a>.</p><p>Most modern high-level languages provide ways to express sum types directly.
If you&#x27;re curious have a look at Haskell&#x27;s pattern matching or Rust&#x27;s and Swift&#x27;s enums.</p><h2>Depends</h2><ul><li>Compiler supporting <code>-std=c++11</code> or <code>-std=c++14</code></li></ul><p>Tested with:</p><ul><li>g++-4.7</li><li>g++-4.8</li><li>g++-4.9</li><li>g++-5.2</li><li>clang++-3.5</li><li>clang++-3.6</li><li>clang++-3.7</li><li>clang++-3.8</li><li>clang++-3.9</li><li>Visual Studio 2015</li></ul><h2>Unit Tests</h2><p>On Unix systems compile and run the unit tests with <code>make test</code>.</p><p>On Windows run <code>scripts/build-local.bat</code>.</p><h2>Limitations</h2><ul><li>The <code>variant</code> can not hold references (something like <code>variant&lt;int&amp;&gt;</code> is
not possible). You might want to try <code>std::reference_wrapper</code> instead.</li></ul><h2>Deprecations</h2><ul><li>The included implementation of <code>optional</code> is deprecated and will be removed
in a future version. See <a href="https://github.com/mapbox/variant/issues/64">issue #64</a>.</li><li>Old versions of the code needed visitors to derive from <code>static_visitor</code>.
This is not needed any more and marked as deprecated. The <code>static_visitor</code>
class will be removed in future versions.</li></ul><h2>Benchmarks</h2><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>make bench</span></code></pre><h2>Check object sizes</h2><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>make sizes /path/to/boost/variant.hpp</span></code></pre></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/mapbox-variant","name":"mapbox/variant","licence":"NOASSERTION","description":"C++11/C++14 Variant","readme":"# Mapbox Variant\n\nAn header-only alternative to `boost::variant` for C++11 and C++14\n\n[![Build Status](https://secure.travis-ci.org/mapbox/variant.svg)](https://travis-ci.org/mapbox/variant)\n[![Build status](https://ci.appveyor.com/api/projects/status/v9tatx21j1k0fcgy)](https://ci.appveyor.com/project/Mapbox/variant)\n[![Coverage Status](https://coveralls.io/repos/mapbox/variant/badge.svg?branch=master\u0026service=github)](https://coveralls.io/r/mapbox/variant?branch=master)\n\n## Introduction\n\nVariant's basic building blocks are:\n\n- `variant\u003cTs...\u003e` - a type-safe representation for sum-types / discriminated unions\n- `recursive_wrapper\u003cT\u003e` - a helper type to represent recursive \"tree-like\" variants\n- `apply_visitor(visitor, myVariant)` - to invoke a custom visitor on the variant's underlying type\n- `get\u003cT\u003e()` - a function to directly unwrap a variant's underlying type\n- `.match([](Type){})` - a variant convenience member function taking an arbitrary number of lambdas creating a visitor behind the scenes and applying it to the variant\n\n### Basic Usage - HTTP API Example\n\nSuppose you want to represent a HTTP API response which is either a JSON result or an error:\n\n```c++\nstruct Result {\n  Json object;\n};\n\nstruct Error {\n  int32_t code;\n  string message;\n};\n```\n\nYou can represent this at type level using a variant which is either an `Error` or a `Result`:\n\n```c++\nusing Response = variant\u003cError, Result\u003e;\n\nResponse makeRequest() {\n  return Error{501, \"Not Implemented\"};\n}\n\nResponse ret = makeRequest();\n```\n\nTo see which type the `Response` holds you pattern match on the variant unwrapping the underlying value:\n\n```c++\nret.match([] (Result r) { print(r.object); },\n          [] (Error e)  { print(e.message); });\n```\n\nInstead of using the variant's convenience `.match` pattern matching function you can create a type visitor functor and use `apply_visitor` manually:\n\n```c++\nstruct ResponseVisitor {\n  void operator()(Result r) const {\n    print(r.object);\n  }\n\n  void operator()(Error e) const {\n    print(e.message);\n  }\n};\n\nResponseVisitor visitor;\napply_visitor(visitor, ret);\n```\n\nIn both cases the compiler makes sure you handle all types the variant can represent at compile.\n\n### Recursive Variants - JSON Example\n\n[JSON](http://www.json.org/) consists of types `String`, `Number`, `True`, `False`, `Null`, `Array` and `Object`.\n\n```c++\nstruct String { string value; };\nstruct Number { double value; };\nstruct True   { };\nstruct False  { };\nstruct Null   { };\nstruct Array  { vector\u003c?\u003e values; };\nstruct Object { unordered_map\u003cstring, ?\u003e values; };\n```\n\nThis works for primitive types but how do we represent recursive types such as `Array` which can hold multiple elements and `Array` itself, too?\n\nFor these use cases Variant provides a `recursive_wrapper` helper type which lets you express recursive Variants.\n\n```c++\nstruct String { string value; };\nstruct Number { double value; };\nstruct True   { };\nstruct False  { };\nstruct Null   { };\n\n// Forward declarations only\nstruct Array;\nstruct Object;\n\nusing Value = variant\u003cString, Number, True, False, Null, recursive_wrapper\u003cArray\u003e, recursive_wrapper\u003cObject\u003e\u003e;\n\nstruct Array {\n  vector\u003cValue\u003e values;\n};\n\nstruct Object {\n  unordered_map\u003cstring, Value\u003e values;\n};\n```\n\nFor walking the JSON representation you can again either create a `JSONVisitor`:\n\n```c++\nstruct JSONVisitor {\n\n  void operator()(Null) const {\n    print(\"null\");\n  }\n\n  // same for all other JSON types\n};\n\nJSONVisitor visitor;\napply_visitor(visitor, json);\n```\n\nOr use the convenience `.match` pattern matching function:\n\n```c++\njson.match([] (Null) { print(\"null\"); },\n           ...);\n```\n\nTo summarize: use `recursive_wrapper` to represent recursive \"tree-like\" representations:\n\n```c++\nstruct Empty { };\nstruct Node;\n\nusing Tree = variant\u003cEmpty, recursive_wrapper\u003cNode\u003e\u003e;\n\nstruct Node {\n  uint64_t value;\n}\n```\n\n### Advanced Usage Tips\n\nCreating type aliases for variants is a great way to reduce repetition.\nKeep in mind those type aliases are not checked at type level, though.\nWe recommend creating a new type for all but basic variant usage:\n\n```c++\n// the compiler can't tell the following two apart\nusing APIResult = variant\u003cError, Result\u003e;\nusing FilesystemResult = variant\u003cError, Result\u003e;\n\n// new type\nstruct APIResult : variant\u003cError, Result\u003e {\n  using Base = variant\u003cError, Result\u003e;\n  using Base::Base;\n}\n```\n\n## Why use Mapbox Variant?\n\nMapbox variant has the same speedy performance of `boost::variant` but is\nfaster to compile, results in smaller binaries, and has no dependencies.\n\nFor example on OS X 10.9 with clang++ and libc++:\n\nTest | Mapbox Variant | Boost Variant\n---- | -------------- | -------------\nSize of pre-compiled header (release / debug) | 2.8/2.8 MB         | 12/15 MB\nSize of simple program linking variant (release / debug)     | 8/24 K             | 12/40 K\nTime to compile header     | 185 ms             |  675 ms\n\n(Numbers from an older version of Mapbox variant.)\n\n## Goals\n\nMapbox `variant` has been a very valuable, lightweight alternative for apps\nthat can use c++11 or c++14 but that do not want a boost dependency.\nMapbox `variant` has also been useful in apps that do depend on boost, like\nmapnik, to help (slightly) with compile times and to majorly lessen dependence\non boost in core headers. The original goal and near term goal is to maintain\nexternal API compatibility with `boost::variant` such that Mapbox `variant`\ncan be a \"drop in\". At the same time the goal is to stay minimal: Only\nimplement the features that are actually needed in existing software. So being\nan \"incomplete\" implementation is just fine.\n\nCurrently Mapbox variant doesn't try to be API compatible with the upcoming\nvariant standard, because the standard is not finished and it would be too much\nwork. But we'll revisit this decision in the future if needed.\n\nIf Mapbox variant is not for you, have a look at [these other\nimplementations](doc/other_implementations.md).\n\nWant to know more about the upcoming standard? Have a look at our\n[overview](doc/standards_effort.md).\n\nMost modern high-level languages provide ways to express sum types directly.\nIf you're curious have a look at Haskell's pattern matching or Rust's and Swift's enums.\n\n## Depends\n\n- Compiler supporting `-std=c++11` or `-std=c++14`\n\nTested with:\n\n- g++-4.7\n- g++-4.8\n- g++-4.9\n- g++-5.2\n- clang++-3.5\n- clang++-3.6\n- clang++-3.7\n- clang++-3.8\n- clang++-3.9\n- Visual Studio 2015\n\n## Unit Tests\n\nOn Unix systems compile and run the unit tests with `make test`.\n\nOn Windows run `scripts/build-local.bat`.\n\n## Limitations\n\n- The `variant` can not hold references (something like `variant\u003cint\u0026\u003e` is\n  not possible). You might want to try `std::reference_wrapper` instead.\n\n## Deprecations\n\n- The included implementation of `optional` is deprecated and will be removed\n  in a future version. See [issue #64](https://github.com/mapbox/variant/issues/64).\n- Old versions of the code needed visitors to derive from `static_visitor`.\n  This is not needed any more and marked as deprecated. The `static_visitor`\n  class will be removed in future versions.\n\n## Benchmarks\n\n    make bench\n\n## Check object sizes\n\n    make sizes /path/to/boost/variant.hpp\n","versions":[{"ref":"master","manifest":"targets = [ \"//:variant\" ]\n","lockFile":"manifest = \"365e5aaf42b3c1e4a9feb65c09afd6e70c767992892c7b11ecff344eda9e8a41\"\n\n","buck":"load('//:subdir_glob.bzl', 'subdir_glob')\n\nprebuilt_cxx_library(\n  name = 'variant',\n  header_namespace = 'mapbox',\n  header_only = True,\n  exported_headers = subdir_glob([\n    ('include/mapbox', '**/*.hpp'),\n  ]),\n  visibility = [\n    'PUBLIC',\n  ],\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-16T10:14:46Z","updatedUpstream":"2021-01-07T08:01:53Z","contributors":[{"login":"zugaldia","avatarUrl":"https://avatars1.githubusercontent.com/u/6964?u=e17bd7e9c8e0d4ca1df6956596cffc4ef10176de\u0026v=4"},{"login":"bookest","avatarUrl":"https://avatars1.githubusercontent.com/u/14640?u=75e815f366d32a63b0d223fe47182a1570a96bb3\u0026v=4"},{"login":"springmeyer","avatarUrl":"https://avatars1.githubusercontent.com/u/20300?v=4"},{"login":"mikelmaron","avatarUrl":"https://avatars1.githubusercontent.com/u/22896?u=f22126445e688b260ca316709407189f669c2083\u0026v=4"},{"login":"mourner","avatarUrl":"https://avatars2.githubusercontent.com/u/25395?u=6f04fa0e30ee06ee7ef8d13dd6c166d0ca70aeea\u0026v=4"},{"login":"sbma44","avatarUrl":"https://avatars2.githubusercontent.com/u/31717?v=4"},{"login":"sgillies","avatarUrl":"https://avatars3.githubusercontent.com/u/33697?u=518c359114c548926c56fef4b51a123e9a4a5d47\u0026v=4"},{"login":"kkaefer","avatarUrl":"https://avatars1.githubusercontent.com/u/52399?u=7b3a53dfef51246b5c1342108a664842b4ea3571\u0026v=4"},{"login":"alfwatt","avatarUrl":"https://avatars1.githubusercontent.com/u/53469?u=ff9e35352887e919bfd74b6ad0bee578af80e165\u0026v=4"},{"login":"anderco","avatarUrl":"https://avatars1.githubusercontent.com/u/55106?v=4"},{"login":"yuletide","avatarUrl":"https://avatars3.githubusercontent.com/u/58695?u=6322adc3fcbff377e32f0e6299d7aaddd841dc6e\u0026v=4"},{"login":"artemp","avatarUrl":"https://avatars1.githubusercontent.com/u/59056?u=84b41abea2ca9e9c6e5a6af9277ee06e8376c68f\u0026v=4"},{"login":"tristen","avatarUrl":"https://avatars1.githubusercontent.com/u/61150?u=40b52d083ac2c6f414ef35c79271c776787e7bd0\u0026v=4"},{"login":"ivovandongen","avatarUrl":"https://avatars1.githubusercontent.com/u/64527?u=e284cc763f7ca8765196fc0f6279e7538742cdfd\u0026v=4"},{"login":"brunoabinader","avatarUrl":"https://avatars2.githubusercontent.com/u/76133?v=4"},{"login":"apendleton","avatarUrl":"https://avatars3.githubusercontent.com/u/78930?u=911348d600e91c721685538a958ee4252a854589\u0026v=4"},{"login":"yhahn","avatarUrl":"https://avatars1.githubusercontent.com/u/83384?u=b2c1ca34e763ba420f510b5a1d62201c1d9624eb\u0026v=4"},{"login":"PureW","avatarUrl":"https://avatars0.githubusercontent.com/u/85910?v=4"},{"login":"AlekseiCherkes","avatarUrl":"https://avatars3.githubusercontent.com/u/87640?u=f75d2bf7fd442db59db853feab57a208761fddef\u0026v=4"},{"login":"ianshward","avatarUrl":"https://avatars2.githubusercontent.com/u/91258?u=5e631aa4328b540f955d9c2e9e2588fcc1bd0d0d\u0026v=4"},{"login":"gundersen","avatarUrl":"https://avatars0.githubusercontent.com/u/93353?v=4"},{"login":"willwhite","avatarUrl":"https://avatars1.githubusercontent.com/u/93564?u=3e17a4a45e3ce686ca811d9ed79257db04ff345f\u0026v=4"},{"login":"lxbarth","avatarUrl":"https://avatars2.githubusercontent.com/u/98233?u=3ca609d2f417501e961958c5bef2f99327b3f84e\u0026v=4"},{"login":"jfirebaugh","avatarUrl":"https://avatars0.githubusercontent.com/u/98601?u=5b527e69ac7e93e41d9a9518e805e99bd4a08389\u0026v=4"},{"login":"kshehadeh","avatarUrl":"https://avatars0.githubusercontent.com/u/107061?u=d5e994f10868eb85c21bc5b8793da960f3044ed6\u0026v=4"}],"fundingLinks":[],"contactLinks":[],"stars":310,"forks":79,"topics":["c-plus-plus"]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"mapbox-variant"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>