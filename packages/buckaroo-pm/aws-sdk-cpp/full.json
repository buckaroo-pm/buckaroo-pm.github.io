{
  "packageName": "buckaroo-pm/aws-sdk-cpp",
  "name": "aws/aws-sdk-cpp",
  "licence": "Apache-2.0",
  "description": "AWS SDK for C++",
  "readme": "# Upgrading Notes\nFor 0.12+ all applications must call the Aws::InitAPI() function before making any other SDK calls, and the Aws::ShutdownAPI function when finished using the SDK. More information can be found here:\nhttps://aws.amazon.com/blogs/developer/aws-sdk-for-c-simplified-configuration-and-initialization/\n\n# AWS SDK for C++\nThe AWS SDK for C++ provides a modern C++ (version C++ 11 or later) interface for Amazon Web Services (AWS). It is meant to be performant and fully functioning with low- and high-level SDKs, while minimizing dependencies and providing platform portability (Windows, OSX, Linux, and mobile).  \n\nAWS SDK for C++ is in now in General Availability and recommended for production use. We invite our customers to join\nthe development efforts by submitting pull requests and sending us feedback and ideas via GitHub Issues.\n\n## Getting Help\nPlease use these community resources for getting help. We use the GitHub issues for tracking bugs and feature requests.\n* Ask a question on StackOverflow and tag it with the `aws-sdk-cpp` tag. \n* If it turns out that you may have found a bug, please open an issue\n* Open a support ticket with [AWS Support]( https://console.aws.amazon.com/support/home#/)\n \n \n## Opening Issues\nIf you encounter a bug with the AWS SDK for C++ we would like to hear about it. Search the [existing issues]( https://github.com/aws/aws-sdk-cpp/issues) and see if others are also experiencing the issue before opening a new issue. Please include the version of AWS SDK for CPP, Compiler, Compiler Version, CMake version, and OS you’re using. Please also include repro case when appropriate.\n \nThe GitHub issues are intended for bug reports and feature requests. For help and questions with using AWS SDK for C++, please make use of the resources listed in the [Getting Help]( https://github.com/aws/aws-sdk-cpp#getting-help) section. Keeping the list of open issues lean we can respond in a timely manner.\n\n\n### Introducing the AWS SDK for C++ from AWS re:invent 2015\nThe following video explains many of the core features and also high-level SDKs\n\n[![Introducing the AWS SDK for C++](https://img.youtube.com/vi/fm4Aa3Whwos/0.jpg)](https://www.youtube.com/watch?v=fm4Aa3Whwos&list=PLhr1KZpdzuke5pqzTvI2ZxwP8-NwLACuU&index=9 \"Introducing the AWS SDK for C++\")\n\n### Building the SDK:\nUse the information below to build the entire source tree for your platform, run unit tests, and build integration tests.  \n\n#### Minimum Requirements:\n* Visual Studio 2013 or later\n  * Visual Studio 2013 does not provide default move constructors and operators.\n  * Later versions of Visual Studio provide a standards-compliant compiler.\n* OR GNU Compiler Collection (GCC) 4.9 or later\n* OR Clang 3.3 or later\n* 4GB of RAM\n  * 4GB of RAM is required to build some of the larger clients. The SDK build may fail on EC2 instance types t2.micro, t2.small and other small instance types due to insufficient memory.\n\n#### Creating an Out-of-Source Build (Recommended):\nTo create an **out-of-source build**:\n1. Install CMake and the relevant build tools for your platform. Ensure these are available in your executable path.\n2. Create your build directory. Replace BUILD_DIR with your build directory name:\n\n```\ncd BUILD_DIR\ncmake <path-to-root-of-this-source-code>\n```\n\nYou can use the following variations to create your build directory:\n* For Auto Make build systems:\n`make`\n* For Visual Studio:\n`msbuild ALL_BUILD.vcxproj`\n\nTo create a **release build**, do one of the following:\n* For Auto Make build systems:\n```\ncmake -DCMAKE_BUILD_TYPE=Release  <path-to-root-of-this-source-code>\nmake\nsudo make install\n```\nTo uninstall these libraries:\n```\nsudo make uninstall\n```\nYou may define a custom uninstall target when you are using SDK as a sub-project, but make sure it comes before the default definition in `CMakeLists.txt`, and you can uninstall SDK related libraries by:\n```\nsudo make uninstall-awssdk\n```\n\n* For Visual Studio:\n```\ncmake <path-to-root-of-this-source-code> -G \"Visual Studio 12 Win64\"\nmsbuild INSTALL.vcxproj /p:Configuration=Release\n```\n\nYou may also find the following link helpful for including the build in your project:\n\nhttps://aws.amazon.com/blogs/developer/using-cmake-exports-with-the-aws-sdk-for-c/\n\n#### Building for Android\nTo build for Android, add `-DTARGET_ARCH=ANDROID` to your cmake command line.  We've included a cmake toolchain file that should cover what's needed, assuming you have the appropriate environment variables (ANDROID_NDK) set.\nCurrently the latest version of NDK we support is 12b.\n\n##### Android on Windows\nBuilding for Android on Windows requires some additional setup.  In particular, you will need to run cmake from a Visual Studio developer command prompt (2013 or higher).  Additionally, you will need 'git' and 'patch' in your path.  If you have git installed on a Windows system, then patch is likely found in a sibling directory (.../Git/usr/bin/).  Once you've verified these requirements, your cmake command line will change slightly to use nmake:\n\n```\ncmake -G \"NMake Makefiles\" `-DTARGET_ARCH=ANDROID` <other options> ..\n```\n\nNmake builds targets in a serial fashion.  To make things quicker, we recommend installing JOM as an alternative to nmake and then changing the cmake invocation to:\n\n```\ncmake -G \"NMake Makefiles JOM\" `-DTARGET_ARCH=ANDROID` <other options> ..\n```\n\n#### General CMake Variables\n\n##### BUILD_ONLY\nAllows you to only build the clients you want to use. This will resolve low level client dependencies if you set this to a high-level sdk such as aws-cpp-sdk-transfer. This will also build integration and unit tests related to the projects you select if they exist. aws-cpp-sdk-core always builds regardless of the value of this argument. This is a list argument.\nExample:\n```\n-DBUILD_ONLY=\"s3;dynamodb;cognito-identity\"\n```\n\n##### ADD_CUSTOM_CLIENTS\nAllows you to build any arbitrary clients based on the api definition. Simply place your definition in the code-generation/api-definitions folder. Then pass this arg to cmake. The cmake configure step will generate your client and include it as a subdirectory in your build. This is particularly useful if you want to generate a C++ client for using one of your API Gateway services. To use this feature you need to have python 2.7, java, jdk1.8, and maven installed and in your executable path. Example: -DADD_CUSTOM_CLIENTS=\"serviceName=myCustomService, version=2015-12-21;serviceName=someOtherService, version=2015-08-15\"\n\n##### REGENERATE_CLIENTS\nThis argument will wipe out all generated code and generate the client directories from the code-generation/api-definitions folder. To use this argument, you need to have python 2.7, java, jdk1.8, and maven installed in your executable path. Example: -DREGENERATE_CLIENTS=1\n\n##### CUSTOM_MEMORY_MANAGEMENT  \nTo use a custom memory manager, set the value to 1. You can install a custom allocator, and all STL types will use the custom allocation interface. If the value is set to 0, you still might want to use the STL template types to help with DLL safety on Windows.\n\nIf static linking is enabled, custom memory management defaults to off. If dynamic linking is enabled, custom memory management defaults to on and avoids cross-DLL allocation and deallocation.\n\nNote: To prevent linker mismatch errors, you must use the same value (0 or 1) throughout your build system.\n\n##### TARGET_ARCH\nTo cross compile or build for a mobile platform, you must specify the target platform. By default the build detects the host operating system and builds for that operating system.\nOptions: WINDOWS | LINUX | APPLE | ANDROID\n\n##### G\nUse this variable to generate build artifacts, such as Visual Studio solutions and Xcode projects.\n\nWindows example:\n-G \"Visual Studio 12 Win64\"\n\nFor more information, see the CMake documentation for your platform.\n\n#### General CMake Options\nCMake options are variables that can either be ON or OFF, with a controllable default.  You can set an option either with CMake Gui tools or the command line via -D.\n\n##### ENABLE_UNITY_BUILD\n(Defaults to OFF) If enabled, most SDK libraries will be built as a single, generated .cpp file.  This can significantly reduce static library size as well as speed up compilation time.\n\n##### MINIMIZE_SIZE\n(Defaults to OFF) A superset of ENABLE_UNITY_BUILD, if enabled this option turns on ENABLE_UNITY_BUILD as well as some additional binary size reduction settings.  This is a work-in-progress and may change in the future (symbol stripping in particular).\n\n##### BUILD_SHARED_LIBS\n(Defaults to ON) A built-in CMake option, reexposed here for visibility.  If enabled, shared libraries will be built, otherwise static libraries will be built.\n\n##### FORCE_SHARED_CRT\n(Defaults to ON) If enabled, the SDK will link to the C runtime dynamically, otherwise it will use the BUILD_SHARED_LIBS setting (weird but necessary for backwards compatibility with older versions of the SDK)\n\n##### SIMPLE_INSTALL\n(Defaults to ON) If enabled, the install process will not insert platform-specific intermediate directories underneath bin/ and lib/.  Turn OFF if you need to make multi-platform releases under a single install directory.\n\n##### NO_HTTP_CLIENT\n(Defaults to OFF) If enabled, prevents the default platform-specific http client from being built into the library.  Turn this ON if you wish to inject your own http client implementation.\n\n##### NO_ENCRYPTION\n(Defaults to OFF) If enabled, prevents the default platform-specific cryptography implementation from being built into the library.  Turn this ON if you wish to inject your own cryptography implementation.\n\n##### ENABLE_RTTI\n(Defaults to ON) Controls whether or not the SDK is built with RTTI information\n\n##### CPP_STANDARD\n(Defaults to 11) Allows you to specify a custom c++ standard for use with C++ 14 and 17 code-bases\n\n##### ENABLE_TESTING\n(Defaults to ON) Controls whether or not the unit and integration test projects are built\n\n#### Android CMake Variables/Options\n\n##### NDK_DIR\nAn override path for where the build system should find the Android NDK.  By default, the build system will check environment variables (ANDROID_NDK) if this CMake variable is not set.\n\n##### DISABLE_ANDROID_STANDALONE_BUILD\n(Defaults to OFF) By default, Android builds will use a standalone clang-based toolchain constructed via NDK scripts.  If you wish to use your own toolchain, turn this option ON.\n\n##### ANDROID_STL\n(Defaults to libc++\\_shared)  Controls what flavor of the C++ standard library the SDK will use.  Valid values are one of {libc++\\_shared, libc++\\_static, gnustl_shared, gnustl_static}.  There are severe performance problems within the SDK if gnustl is used, so we recommend libc++.\n\n##### ANDROID_ABI\n(Defaults to armeabi-v7a) Controls what abi to output code for.  Not all valid Android ABI values are currently supported, but we intend to provide full coverage in the future.  We welcome patches to our Openssl build wrapper that speed this process up.  Valid values are one of {arm64, armeabi-v7a, x86_64, x86, mips64, mips}.\n\n##### ANDROID_TOOLCHAIN_NAME\n(Defaults to standalone-clang) Controls which compiler is used to build the SDK.  With GCC being deprecated by Android NDK, we recommend using the default (clang).\n\n##### ANDROID_NATIVE_API_LEVEL\n(Default varies by STL choice) Controls what API level the SDK will be built against.  If you use gnustl, you have complete freedom with the choice of API level.  If you use libc++, you must use an API level of at least 21.\n\n\n### Running integration tests:\nSeveral directories are appended with \\*integration-tests. After building your project, you can run these executables to ensure everything works properly.\n\n#### Dependencies:\nTo compile in Linux, you must have the header files for libcurl, libopenssl. The packages are typically available in your package manager.\n\nDebian example:\n   `sudo apt-get install libcurl-dev`\n\n### Using the SDK\nAfter they are constructed, individual service clients are very similar to other SDKs, such as Java and .NET. This section explains how core works, how to use each feature, and how to construct an individual client.\n\nThe aws-cpp-sdk-core is the heart of the system and does the heavy lifting. You can write a client to connect to any AWS service using just the core, and the individual service clients are available to help make the process a little easier.\n\n#### Build Defines\nIf you dynamically link to the SDK you will need to define the USE_IMPORT_EXPORT symbol for all build targets using the SDK.\nIf you wish to install your own memory manager to handle allocations made by the SDK, you will need to pass the CUSTOM_MEMORY_MANAGEMENT cmake parameter (-DCUSTOM_MEMORY_MANAGEMENT) as well as define AWS_CUSTOM_MEMORY_MANAGEMENT in all build targets dependent on the SDK.\n\nNote, if you use our export file, this will be handled automatically for you. We recommend you use our export file to handle this for you:\nhttps://aws.amazon.com/blogs/developer/using-cmake-exports-with-the-aws-sdk-for-c/\n\n#### Initialization and Shutdown\nWe avoid global and static state where ever possible. However, on some platforms, dependencies need to be globally initialized. Also, we have a few global options such as\nlogging, memory management, http factories, and crypto factories. As a result, before using the SDK you MUST call our global initialization function. When you are finished using the SDK you should call our cleanup function.\n\nAll code using the AWS SDK and C++ should have at least the following:\n\n```\n#include <aws/core/Aws.h>\n...\n\n    Aws::SDKOptions options;\n    Aws::InitAPI(options);\n\n    //use the sdk\n\n    Aws::ShutdownAPI(options);\n```\n\nDue to the way memory managers work, many of the configuration options take closures instead of pointers directly in order to ensure that the memory manager\nis installed prior to any memory allocations occuring.\n\nHere are a few recipes:\n\nJust use defaults:\n```\n   Aws::SDKOptions options;\n   Aws::InitAPI(options);\n   .....\n   Aws::ShutdownAPI(options);\n```\n\nTurn logging on using the default logger:\n```\n   Aws::SDKOptions options;\n   options.loggingOptions.logLevel = Aws::Utils::Logging::LogLevel::Info;\n   Aws::InitAPI(options);\n   .....\n   Aws::ShutdownAPI(options);\n```\n\nInstall custom memory manager:\n```\n    MyMemoryManager memoryManager;\n\n    Aws::SDKOptions options;\n    options.memoryManagementOptions.memoryManager = &memoryManager;\n    Aws::InitAPI(options);\n    .....\n    Aws::ShutdownAPI(options);\n```\n\nOverride default http client factory:\n```\n    Aws::SDKOptions options;\n    options.httpOptions.httpClientFactory_create_fn = [](){ return Aws::MakeShared<MyCustomHttpClientFactory>(\"ALLOC_TAG\", arg1); };\n    Aws::InitAPI(options);\n    .....\n    Aws::ShutdownAPI(options);\n```\n\n#### Memory Management\nThe AWS SDK for C++ provides a way to control memory allocation and deallocation in a library.\n\nCustom memory management is available only if you use a version of the library built using the compile-time constant AWS_CUSTOM_MEMORY_MANAGEMENT defined.\n\nIf you use a version of the library built without the compile-time constant, the global memory system functions such as InitializeAWSMemorySystem will not work and the global new and delete functions will be used instead.\n\nFor more information about the compile-time constant, see the STL and AWS Strings and Vectors section in this Readme.\n\nTo allocate or deallocate memory:\n1. Implement the MemorySystemInterface subclass:\n   aws/core/utils/memory/MemorySystemInterface.h\n\nIn the following example, the type signature for AllocateMemory can be changed as needed:\n\n```\nclass MyMemoryManager : public Aws::Utils::Memory::MemorySystemInterface\n{\n  public:\n\n    // ...\n\n    virtual void* AllocateMemory(std::size_t blockSize, std::size_t alignment, const char *allocationTag = nullptr) override;\n    virtual void FreeMemory(void* memoryPtr) override;\n\n};\n```\n\nIn Main:\n\n```\nint main(void)\n{\n  MyMemoryManager sdkMemoryManager;\n  SDKOptions options;\n  options.memoryManagementOptions.memoryManager = &sdkMemoryManager;\n  Aws::InitAPI(options);\n\n  // ... do stuff\n\n  Aws::ShutdownAPI(options);\n\n  return 0;\n}\n```\n\n#### STL and AWS Strings and Vectors\nWhen initialized with a memory manager, the AWS SDK for C++ defers all allocation and deallocation to the memory manager. If a memory manager does not exist, the SDK uses global new and delete.\n\nIf you use custom STL allocators, you must alter the type signatures for all STL objects to match the allocation policy. Because STL is used prominently in the SDK implementation and interface, a single approach in the SDK would inhibit direct passing of default STL objects into the SDK or control of STL allocation. Alternately, a hybrid approach – using custom allocators internally and allowing standard and custom STL objects on the interface – could potentially cause more difficulty when investigating memory issues.\n\nThe solution is to use the memory system’s compile-time constant AWS_CUSTOM_MEMORY_MANAGEMENT to control which STL types the SDK will use.\n\nIf the compile-time constant is enabled (on), the types resolve to STL types with a custom allocator connected to the AWS memory system.\n\nIf the compile-time constant is disabled (off), all Aws::* types resolve to the corresponding default std::* type.\n\nExample code from the AWSAllocator.h file in the SDK:\n\n```\n#ifdef AWS_CUSTOM_MEMORY_MANAGEMENT\n\ntemplate< typename T >\nclass AwsAllocator : public std::allocator< T >\n{\n   ... definition of allocator that uses AWS memory system\n};\n\n#else\n\ntemplate< typename T > using Allocator = std::allocator<T>;\n\n#endif\n```\n\nIn the example code, the AwsAllocator can be either a custom allocator or a default allocator, depending on the compile-time constant.\n\nExample code from the AWSVector.h file in the SDK:\n`template< typename T > using Vector = std::vector< T, Aws::Allocator< T > >;`\n\nIn the example code, we define the Aws::* types.\n\nIf the compile-time constant is enabled (on), the type maps to a vector using custom memory allocation and the AWS memory system.\n\nIf the compile-time constant is disabled (off), the type maps to a regular std::vector with default type parameters.\n\nType aliasing is used for all std:: types in the SDK that perform memory allocation, such as containers, string stream, and string buf. The AWS SDK for C++ uses these types.\n\n##### Remaining Issues\nYou can control memory allocation in the SDK; however, STL types still dominate the public interface through string parameters to the model object initialize and set methods. If you choose not to use STL and use strings and containers instead, you must create a lot of temporaries whenever you want to make a service call.\n\nTo remove most of the temporaries and allocation when service calls are made using non-STL, we have implemented the following:\n* Every Init/Set function that takes a string has an overload that takes the const char*.\n* Every Init/Set function that takes a container (map/vector) has an add variant that takes a single entry.\n* Every Init/Set function that takes binary data has an overload that takes a pointer to the data and a length value.\n* (Optional) Every Init/Set function that takes a string has an overload that takes a non-zero terminated constr char* and a length value.\n\n##### Native SDK Developers and Memory Controls\nFollow these rules in the SDK code:\n* Do not use new and delete; use Aws::New<> and Aws::Delete<>.\n* Do not use new[] and delete []; use Aws::NewArray<> and Aws::DeleteArray<>.\n* Do not use std::make_shared; use Aws::MakeShared.\n* Use Aws::UniquePtr for unique pointers to a single object. Use the Aws::MakeUnique function to create the unique pointer.\n* Use Aws::UniqueArray for unique pointers to an array of objects. Use the Aws::MakeUniqueArray function to create the unique pointer.\n* Do not directly use STL containers; use one of the Aws::typedefs or add a typedef for the desired container. Example: `Aws::Map<Aws::String, Aws::String> m_kvPairs;`\n* Use shared_ptr for any external pointer passed into and managed by the SDK. You must initialize the shared pointer with a destruction policy that matches how the object was allocated. You can use a raw pointer if the SDK is not expected to clean up the pointer.\n\n#### Logging\nThe AWS SDK for C++ includes logging support that you can configure. When initializing the logging system, you can control the filter level and the logging target (file with a name that has a configurable prefix or a stream). The log file generated by the prefix option rolls over once per hour to allow for archiving or deleting log files.\n\nYou can provide your own logger. However, it is incredibly simple to use the default logger we've already provided:\n\nIn your main function:\n\n```\n    SDKOptions options;\n    options.loggingOptions.logLevel = Aws::Utils::Logging::LogLevel::Info;\n    Aws::InitAPI(options);\n    //do SDK stuff;\n    Aws::ShutdownAPI(options);\n```\n#### Client Configuration\nYou can use the client configuration to control most functionality in the AWS SDK for C++.\n\nClientConfiguration declaration:\n\n```\nstruct AWS_CORE_API ClientConfiguration\n{\n    ClientConfiguration();\n\n    Aws::String userAgent;\n    Aws::Http::Scheme scheme;\n    Aws::Region region;\n    bool useDualStack;\n    unsigned maxConnections;\n    long requestTimeoutMs;\n    long connectTimeoutMs;\n    std::shared_ptr<RetryStrategy> retryStrategy;\n    Aws::String endpointOverride;\n    Aws::Http::Scheme proxyScheme;\n    Aws::String proxyHost;\n    unsigned proxyPort;\n    Aws::String proxyUserName;\n    Aws::String proxyPassword;\n    std::shared_ptr<Aws::Utils::Threading::Executor> executor;\n    bool verifySSL;\n    Aws::String caPath;\n    std::shared_ptr<Aws::Utils::RateLimits::RateLimiterInterface> writeRateLimiter;\n    std::shared_ptr<Aws::Utils::RateLimits::RateLimiterInterface> readRateLimiter;\n};\n```\n\n##### User Agent\nThe user agent is built in the constructor and pulls information from your operating system. Do not alter the user agent.\n\n##### Scheme\nThe default value for scheme is HTTPS. You can set this value to HTTP if the information you are passing is not sensitive and the service to which you want to connect supports an HTTP endpoint. AWS Auth protects you from tampering.\n\n##### Region\nThe region specifies where you want the client to communicate. Examples include us-east-1 or us-west-1. You must ensure the service you want to use has an endpoint in the region you configure.\n\n##### UseDualStack\nSets the endpoint calculation to go to a dual stack (ipv6 enabled) endpoint. It is your responsibility to check that the service actually supports ipv6 in the region you specify.\n\n##### Max Connections\nThe default value for the maximum number of allowed connections to a single server for your HTTP communications is 25. You can set this value as high as you can support the bandwidth. We recommend a value around 25.\n\n##### Request Timeout and Connection Timeout\nThis value determines the length of time, in milliseconds, to wait before timing out a request. You can increase this value if you need to transfer large files, such as in Amazon S3 or CloudFront.\n\n##### Retry Strategy\nThe retry strategy defaults to exponential backoff. You can override this default by implementing a subclass of RetryStrategy and passing an instance.\n\n##### Endpoint Override\nDo not alter the endpoint.\n\n##### Proxy Scheme, Host, Port, User Name, and Password\nThese settings allow you to configure a proxy for all communication with AWS. Examples of when this functionality might be useful include debugging in conjunction with the Burp suite, or using a proxy to connect to the internet.\n\n##### Executor\nThe default behavior for the executor is to create and detach a thread for each async call. You can change this behavior by implementing a subclass of Executor and passing an instance. We now provide a thread pooled executor as an option. For more information see this blog post: https://aws.amazon.com/blogs/developer/using-a-thread-pool-with-the-aws-sdk-for-c/\n\n##### Verify SSL\nIf necessary, you can disable SSL certificate verification by setting the verify SSL value to false.\n\n##### CA Path\nYou can tell the http client where to find your certificate trust store ( e.g. a directory prepared with OpenSSL c_rehash utility). This should not be necessary unless you are doing some weird symlink farm stuff for your environment. This has no effect on Windows or OSX.\n\n##### Write Rate Limiter and Read Rate Limiter\nThe write and read rate limiters are used to throttle the bandwidth used by the transport layer. The default for these limiters is open. You can use the default implementation with your desired rates, or you can create your own instance by implementing a subclass of RateLimiterInterface.\n\n#### Credentials Providers\nYou can use the AWSCredentialProvider interface to provide login credentials to AWS Auth. Implement this interface to provide your own method of credentials deployment. We also provide default credential providers.\n\n##### Default Credential Provider Chain\nThe default credential provider chain does the following:\n* Checks your environment variables for AWS Credentials\n* Checks your $HOME/.aws/credentials file for a profile and credentials\n* Contacts the ECS TaskRoleCredentialsProvider service to request credentials if Environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI has been set. Otherwise contacts the EC2MetadataInstanceProfileCredentialsProvider service to request credentials\n\nThe simplest way to communicate with AWS is to ensure we can find your credentials in one of these locations.\n\n##### Other Methods\nWe also support two other methods for providing credentials:\n* Provide your credentials in your client’s constructor.\n* Use Amazon Cognito Identity, which is an identity management solution. You can use the CognitoCaching*CredentialsProviders classes in the identity-management project. For more information, see the *Amazon Cognito Developer Guide*.\n\n#### Using a Service Client\nYou can use the default constructor, or you can use the system interfaces discussed above to construct a service client.\n\nAs an example, the following code creates an Amazon DynamoDB client using a specialized client configuration, default credentials provider chain, and default HTTP client factory:\n\n```\nauto limiter = Aws::MakeShared<Aws::Utils::RateLimits::DefaultRateLimiter<>>(ALLOCATION_TAG, 200000);\n\n// Create a client\nClientConfiguration config;\nconfig.scheme = Scheme::HTTPS;\nconfig.connectTimeoutMs = 30000;\nconfig.requestTimeoutMs = 30000;\nconfig.readRateLimiter = m_limiter;\nconfig.writeRateLimiter = m_limiter;\n\nauto client = Aws::MakeShared<DynamoDBClient>(ALLOCATION_TAG, config);\n```\n\nYou can also do the following to manually pass credentials:\n`auto client = Aws::MakeShared<DynamoDBClient>(ALLOCATION_TAG, AWSCredentials(\"access_key_id\", \"secret_key\"), config);`\n\nOr you can do the following to use a custom credentials provider:\n`auto client = Aws::MakeShared<DynamoDBClient>(ALLOCATION_TAG, Aws::MakeShared<CognitoCachingAnonymousCredentialsProvider>(ALLOCATION_TAG, \"identityPoolId\", \"accountId\"), config);`\n\nNow you can use your Amazon DynamoDB client.\n\n#### Error Handling\nWe did not use exceptions; however, you can use exceptions in your code. Every service client returns an outcome object that includes the result and an error code.\n\nExample of handling error conditions:\n\n```\nbool CreateTableAndWaitForItToBeActive()\n{\n  CreateTableRequest createTableRequest;\n  AttributeDefinition hashKey;\n  hashKey.SetAttributeName(HASH_KEY_NAME);\n  hashKey.SetAttributeType(ScalarAttributeType::S);\n  createTableRequest.AddAttributeDefinitions(hashKey);\n  KeySchemaElement hashKeySchemaElement;\n  hashKeySchemaElement.WithAttributeName(HASH_KEY_NAME).WithKeyType(KeyType::HASH);\n  createTableRequest.AddKeySchema(hashKeySchemaElement);\n  ProvisionedThroughput provisionedThroughput;\n  provisionedThroughput.SetReadCapacityUnits(readCap);\n  provisionedThroughput.SetWriteCapacityUnits(writeCap);\n  createTableRequest.WithProvisionedThroughput(provisionedThroughput);\n  createTableRequest.WithTableName(tableName);\n\n  CreateTableOutcome createTableOutcome = dynamoDbClient->CreateTable(createTableRequest);\n  if (createTableOutcome.IsSuccess())\n  {\n     DescribeTableRequest describeTableRequest;\n     describeTableRequest.SetTableName(tableName);\n     bool shouldContinue = true;\n     DescribeTableOutcome outcome = dynamoDbClient->DescribeTable(describeTableRequest);\n\n     while (shouldContinue)\n     {       \n         if (outcome.GetResult().GetTable().GetTableStatus() == TableStatus::ACTIVE)\n         {\n            break;\n         }\n         else\n         {\n             std::this_thread::sleep_for(std::chrono::seconds(1));\n         }\n     }\n     return true\n  }\n  else if(createTableOutcome.GetError().GetErrorType() == DynamoDBErrors::RESOURCE_IN_USE)\n  {\n     return true;\n  }\n\n  return false;\n}\n```\n\n#### Advanced Topics\nThis section includes the following topics:\n* Overriding Your HTTP Client\n* Provided Utilities\n* Controlling IOStreams Used by the HttpClient and the AWSClient\n\n##### Overriding your Http Client\nThe default HTTP client for Windows is WinHTTP. The default HTTP client for all other platforms is Curl. If needed, you can create a custom HttpClientFactory, add it to the SDKOptions object which you pass to Aws::InitAPI().\n\n##### Provided Utilities\nThe provided utilities include HTTP stack, string utils, hashing utils, JSON parser, and XML parser.\n\n###### HTTP Stack\n/aws/core/http/\n\nThe HTTP client provides connection pooling, is thread safe, and can be reused for your purposes. See the Client Configuration section above.\n\n###### String Utils\n/aws/core/utils/StringUtils.h\n\nThis header file provides core string functions, such as trim, lowercase, and numeric conversions.\n\n###### Hashing Utils\n/aws/core/utils/HashingUtils.h\n\nThis header file provides hashing functions, such as SHA256, MD5, Base64, and SHA256_HMAC.\n\n###### Cryptography\n/aws/core/utils/crypto/Cipher.h\n/aws/core/utils/crypto/Factories.h\n\nThis header file provides access to secure random number generators, AES symmetric ciphers in CBC, CTR, and GCM modes, and the underlying Hash implementations that are used in HashingUtils.\n\n###### JSON Parser\n/aws/core/utils/json/JsonSerializer.h\n\nThis header file provides a fully functioning yet lightweight JSON parser (thin wrapper around JsonCpp).\n\n###### XML Parser\n/aws/core/utils/xml/XmlSerializer.h\n\nThis header file provides a lightweight XML parser (thin wrapper around tinyxml2). RAII pattern has been added to the interface.\n\n##### Controlling IOStreams used by the HttpClient and the AWSClient\nBy default all responses use an input stream backed by a stringbuf. If needed, you can override the default behavior. For example, if you are using Amazon S3 GetObject and do not want to load the entire file into memory, you can use IOStreamFactory in AmazonWebServiceRequest to pass a lambda to create a file stream.\n\nExample file stream request:\n\n```\nGetObjectRequest getObjectRequest;\ngetObjectRequest.SetBucket(fullBucketName);\ngetObjectRequest.SetKey(keyName);\ngetObjectRequest.SetResponseStreamFactory([](){ return Aws::New<Aws::FStream>( ALLOCATION_TAG, DOWNLOADED_FILENAME, std::ios_base::out ); });\n\nauto getObjectOutcome = s3Client->GetObject(getObjectRequest);\n```\n\n### Contributing Back\n\\*Please Do!\n\n##### Guidelines\n* Don't make changes to generated clients directly. Make your changes in the generator. Changes to Core, Scripts, and High-Level interfaces are fine directly in the code.\n* Do not use non-trivial statics anywhere. This will cause custom memory managers to crash in random places.\n* Use 4 spaces for indents and never use tabs.\n* No exceptions.... no exceptions. Use the Outcome pattern for returning data if you need to also return an optional error code.\n* Always think about platform independence. If this is impossible, put a nice abstraction on top of it and use an abstract factory.\n* Use RAII, Aws::New and Aws::Delete should only appear in constructors and destructors.\n* Be sure to follow the rule of 5.\n* Use the C++ 11 standard where possible.\n* Use UpperCamelCase for custom type names and function names. Use m_* for member variables. Don't use statics. If you must, use UpperCammelCase for static variables\n* Always be const correct, and be mindful of when you need to support r-values. We don't trust compilers to optimize this uniformly accross builds so please be explicit.\n* Namespace names should be UpperCammelCase. Never put a using namespace statement in a header file unless it is scoped by a class. It is fine to use a using namespace statement in a cpp file.\n* Use enum class, not enum\n* Prefer `#pragma once` for include guards.\n* Forward declare whenever possible.\n* Use nullptr instead of NULL.\n",
  "versions": [
    {
      "ref": "master",
      "manifest": "targets = [ \"//aws-cpp-sdk-core:aws-cpp-sdk-core\" ]\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/aws-c-event-stream\"\nversion = \"*\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/awslabs-aws-c-common\"\nversion = \"*\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/openssl\"\nversion = \"*\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/pkg-config-curl\"\nversion = \"*\"\n",
      "lockFile": "manifest = \"cb07ebd67ac1ff7a7792e4c99b3be1586203b375d9cb793371b9c87c042bd3a1\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/aws-c-event-stream\"\ntarget = \"//:aws-c-event-stream\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/awslabs-aws-c-common\"\ntarget = \"//:aws-c-common\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/openssl\"\ntarget = \"//:openssl\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/pkg-config-curl\"\ntarget = \"//:curl\"\n\n[[lock]]\nname = \"github.com/buckaroo-pm/aws-c-event-stream\"\nversion = \"branch=master\"\nrevision = \"be696d9d64c376202f3a9209826173409df8790f\"\n\n[[lock]]\nname = \"github.com/buckaroo-pm/awslabs-aws-c-common\"\nversion = \"branch=master\"\nrevision = \"1d755e3287db2a89d6c7ac52f4b818e5205b3026\"\n\n[[lock]]\nname = \"github.com/buckaroo-pm/awslabs-aws-checksums\"\nversion = \"branch=master\"\nrevision = \"7598679075b147468fd83e95d34fddcd541b1efc\"\n\n[[lock]]\nname = \"github.com/buckaroo-pm/openssl\"\nversion = \"tag=1.0.2j\"\nrevision = \"e61671249ee5dfa59b663d135b64dd6fe9efe9d0\"\n\n[[lock]]\nname = \"github.com/buckaroo-pm/pkg-config-curl\"\nversion = \"branch=master\"\nrevision = \"c0eac677dc0066d1c994bf68edd314deebe7cb74\"\n",
      "buck": "",
      "bazel": "",
      "deps": [
        {
          "uri": "github.com/buckaroo-pm/aws-c-event-stream",
          "name": "buckaroo-pm/aws-c-event-stream",
          "version": "*"
        },
        {
          "uri": "github.com/buckaroo-pm/awslabs-aws-c-common",
          "name": "buckaroo-pm/awslabs-aws-c-common",
          "version": "*"
        },
        {
          "uri": "github.com/buckaroo-pm/openssl",
          "name": "buckaroo-pm/openssl",
          "version": "*"
        },
        {
          "uri": "github.com/buckaroo-pm/pkg-config-curl",
          "name": "buckaroo-pm/pkg-config-curl",
          "version": "*"
        }
      ],
      "lock": [
        {
          "uri": "0",
          "name": "0",
          "spec": {
            "name": "github.com/buckaroo-pm/aws-c-event-stream",
            "version": "branch=master",
            "revision": "be696d9d64c376202f3a9209826173409df8790f"
          }
        },
        {
          "uri": "1",
          "name": "1",
          "spec": {
            "name": "github.com/buckaroo-pm/awslabs-aws-c-common",
            "version": "branch=master",
            "revision": "1d755e3287db2a89d6c7ac52f4b818e5205b3026"
          }
        },
        {
          "uri": "2",
          "name": "2",
          "spec": {
            "name": "github.com/buckaroo-pm/awslabs-aws-checksums",
            "version": "branch=master",
            "revision": "7598679075b147468fd83e95d34fddcd541b1efc"
          }
        },
        {
          "uri": "3",
          "name": "3",
          "spec": {
            "name": "github.com/buckaroo-pm/openssl",
            "version": "tag=1.0.2j",
            "revision": "e61671249ee5dfa59b663d135b64dd6fe9efe9d0"
          }
        },
        {
          "uri": "4",
          "name": "4",
          "spec": {
            "name": "github.com/buckaroo-pm/pkg-config-curl",
            "version": "branch=master",
            "revision": "c0eac677dc0066d1c994bf68edd314deebe7cb74"
          }
        }
      ]
    }
  ],
  "updated": "2018-12-04T16:20:18Z",
  "updatedUpstream": "2021-01-13T20:56:24Z",
  "contributors": [
    {
      "login": "aeby",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/46198?v=4"
    },
    {
      "login": "mattgleeson",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/57944?v=4"
    },
    {
      "login": "yhager",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/65973?v=4"
    },
    {
      "login": "ltn100",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/77056?v=4"
    },
    {
      "login": "marcomagdy",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/115965?v=4"
    },
    {
      "login": "kahkeng",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/141746?v=4"
    },
    {
      "login": "supermassive",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/168356?v=4"
    },
    {
      "login": "oliora",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/218676?v=4"
    },
    {
      "login": "KindDragon",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/224272?v=4"
    },
    {
      "login": "chadbrewbaker",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/230310?u=3ea2843f44e2d5f9da4cf5577d95c7504b07ce51&v=4"
    },
    {
      "login": "kromain",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/249705?v=4"
    },
    {
      "login": "bretambrose",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/341314?v=4"
    },
    {
      "login": "hyandell",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/477715?u=981ae536caa2d71790a1ce14ef42a0add7c90896&v=4"
    },
    {
      "login": "dblock",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/542335?u=7e0f1abe8aef4d466a384131d8606156c67f1fd8&v=4"
    },
    {
      "login": "yamashi",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/672982?u=bd38724f20816c90029481fabd7793245d71aaa7&v=4"
    },
    {
      "login": "kiril-kirov",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/675441?v=4"
    },
    {
      "login": "diablodale",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/679350?v=4"
    },
    {
      "login": "ldionne",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/700834?u=3d2dd80d43f96e6fd22219498790622944a25f19&v=4"
    },
    {
      "login": "pcacjr",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/722965?u=7c18f7934ee24a86f478af31c49ec010551da2c9&v=4"
    },
    {
      "login": "yancl",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/822378?v=4"
    },
    {
      "login": "prestomation",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/845970?u=e8134b9ac1006f53805d60b558bbfdef195d2815&v=4"
    },
    {
      "login": "proydakov",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/881359?u=1cf5420e2f5657bf9b1f4f53eb7d0302ed731d1d&v=4"
    },
    {
      "login": "ploki",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/1005355?u=a6d84ff41c61b70a215387bb8830080a107b7bc6&v=4"
    },
    {
      "login": "jt70471",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/1010453?v=4"
    },
    {
      "login": "nicholasbishop",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/1023208?u=41792748d06db3336567fb2bf1d240ffd576733f&v=4"
    }
  ],
  "fundingLinks": [],
  "contactLinks": [],
  "stars": 1167,
  "forks": 661,
  "topics": [
    "cpp",
    "aws",
    "cross-platform"
  ]
}