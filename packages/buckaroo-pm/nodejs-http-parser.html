<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/nodejs-http-parser/logo.png"/></div><div><h1>buckaroo-pm/nodejs-http-parser</h1><div style="max-width:600px">http request/response parser for c</div><br/><div><b>5640</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">nodejs</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">node</span></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><h1>HTTP Parser</h1><p><a href="https://travis-ci.org/nodejs/http-parser"><img src="https://api.travis-ci.org/nodejs/http-parser.svg?branch=master" alt="Build Status"/></a></p><p>This is a parser for HTTP messages written in C. It parses both requests and
responses. The parser is designed to be used in performance HTTP
applications. It does not make any syscalls nor allocations, it does not
buffer data, it can be interrupted at anytime. Depending on your
architecture, it only requires about 40 bytes of data per message
stream (in a web server that is per connection).</p><p>Features:</p><ul><li>No dependencies</li><li>Handles persistent streams (keep-alive).</li><li>Decodes chunked encoding.</li><li>Upgrade support</li><li>Defends against buffer overflow attacks.</li></ul><p>The parser extracts the following information from HTTP messages:</p><ul><li>Header fields and values</li><li>Content-Length</li><li>Request method</li><li>Response status code</li><li>Transfer-Encoding</li><li>HTTP version</li><li>Request URL</li><li>Message body</li></ul><h2>Usage</h2><p>One <code>http_parser</code> object is used per TCP connection. Initialize the struct
using <code>http_parser_init()</code> and set the callbacks. That might look something
like this for a request parser:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>http_parser_settings settings</span><span class="token" style="color:#999">;</span><span>
</span><span>settings</span><span class="token" style="color:#999">.</span><span>on_url </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> my_url_callback</span><span class="token" style="color:#999">;</span><span>
</span><span>settings</span><span class="token" style="color:#999">.</span><span>on_header_field </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> my_header_field_callback</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:slategray">/* ... */</span><span>
</span>
<span>http_parser </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>parser </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">malloc</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">sizeof</span><span class="token" style="color:#999">(</span><span>http_parser</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#DD4A68">http_parser_init</span><span class="token" style="color:#999">(</span><span>parser</span><span class="token" style="color:#999">,</span><span> HTTP_REQUEST</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>parser</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>data </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> my_socket</span><span class="token" style="color:#999">;</span></code></pre><p>When data is received on the socket execute the parser and check for errors.</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#DD4A68">size_t</span><span> len </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#905">80</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#905">1024</span><span class="token" style="color:#999">,</span><span> nparsed</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">char</span><span> buf</span><span class="token" style="color:#999">[</span><span>len</span><span class="token" style="color:#999">]</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#DD4A68">ssize_t</span><span> recved</span><span class="token" style="color:#999">;</span><span>
</span>
<span>recved </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">recv</span><span class="token" style="color:#999">(</span><span>fd</span><span class="token" style="color:#999">,</span><span> buf</span><span class="token" style="color:#999">,</span><span> len</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#905">0</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:#07a">if</span><span> </span><span class="token" style="color:#999">(</span><span>recved </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&lt;</span><span> </span><span class="token" style="color:#905">0</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>  </span><span class="token" style="color:slategray">/* Handle error. */</span><span>
</span><span></span><span class="token" style="color:#999">}</span><span>
</span>
<span></span><span class="token" style="color:slategray">/* Start up / continue the parser.
</span><span class="token" style="color:slategray"> * Note we pass recved==0 to signal that EOF has been received.
</span><span class="token" style="color:slategray"> */</span><span>
</span><span>nparsed </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">http_parser_execute</span><span class="token" style="color:#999">(</span><span>parser</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span>settings</span><span class="token" style="color:#999">,</span><span> buf</span><span class="token" style="color:#999">,</span><span> recved</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span></span><span class="token" style="color:#07a">if</span><span> </span><span class="token" style="color:#999">(</span><span>parser</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>upgrade</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>  </span><span class="token" style="color:slategray">/* handle new protocol */</span><span>
</span><span></span><span class="token" style="color:#999">}</span><span> </span><span class="token" style="color:#07a">else</span><span> </span><span class="token" style="color:#07a">if</span><span> </span><span class="token" style="color:#999">(</span><span>nparsed </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">!=</span><span> recved</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>  </span><span class="token" style="color:slategray">/* Handle error. Usually just close the connection. */</span><span>
</span><span></span><span class="token" style="color:#999">}</span></code></pre><p><code>http_parser</code> needs to know where the end of the stream is. For example, sometimes
servers send responses without Content-Length and expect the client to
consume input (for the body) until EOF. To tell <code>http_parser</code> about EOF, give
<code>0</code> as the fourth parameter to <code>http_parser_execute()</code>. Callbacks and errors
can still be encountered during an EOF, so one must still be prepared
to receive them.</p><p>Scalar valued message information such as <code>status_code</code>, <code>method</code>, and the
HTTP version are stored in the parser structure. This data is only
temporally stored in <code>http_parser</code> and gets reset on each new message. If
this information is needed later, copy it out of the structure during the
<code>headers_complete</code> callback.</p><p>The parser decodes the transfer-encoding for both requests and responses
transparently. That is, a chunked encoding is decoded before being sent to
the on_body callback.</p><h2>The Special Problem of Upgrade</h2><p><code>http_parser</code> supports upgrading the connection to a different protocol. An
increasingly common example of this is the WebSocket protocol which sends
a request like</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>    GET /demo HTTP/1.1
</span>    Upgrade: WebSocket
<!-- -->    Connection: Upgrade
<!-- -->    Host: example.com
<!-- -->    Origin: http://example.com
<!-- -->    WebSocket-Protocol: sample
</code></pre><p>followed by non-HTTP data.</p><p>(See <a href="https://tools.ietf.org/html/rfc6455">RFC6455</a> for more information the
WebSocket protocol.)</p><p>To support this, the parser will treat this as a normal HTTP message without a
body, issuing both on_headers_complete and on_message_complete callbacks. However
http_parser_execute() will stop parsing at the end of the headers and return.</p><p>The user is expected to check if <code>parser-&gt;upgrade</code> has been set to 1 after
<code>http_parser_execute()</code> returns. Non-HTTP data begins at the buffer supplied
offset by the return value of <code>http_parser_execute()</code>.</p><h2>Callbacks</h2><p>During the <code>http_parser_execute()</code> call, the callbacks set in
<code>http_parser_settings</code> will be executed. The parser maintains state and
never looks behind, so buffering the data is not necessary. If you need to
save certain data for later usage, you can do that from the callbacks.</p><p>There are two types of callbacks:</p><ul><li>notification <code>typedef int (*http_cb) (http_parser*);</code>
Callbacks: on_message_begin, on_headers_complete, on_message_complete.</li><li>data <code>typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);</code>
Callbacks: (requests only) on_url,
(common) on_header_field, on_header_value, on_body;</li></ul><p>Callbacks must return 0 on success. Returning a non-zero value indicates
error to the parser, making it exit immediately.</p><p>For cases where it is necessary to pass local information to/from a callback,
the <code>http_parser</code> object&#x27;s <code>data</code> field can be used.
An example of such a case is when using threads to handle a socket connection,
parse a request, and then give a response over that socket. By instantiation
of a thread-local struct containing relevant data (e.g. accepted socket,
allocated memory for callbacks to write into, etc), a parser&#x27;s callbacks are
able to communicate data between the scope of the thread and the scope of the
callback in a threadsafe manner. This allows <code>http_parser</code> to be used in
multi-threaded contexts.</p><p>Example:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span> </span><span class="token" style="color:#07a">typedef</span><span> </span><span class="token" style="color:#07a">struct</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>  </span><span class="token" style="color:#DD4A68">socket_t</span><span> sock</span><span class="token" style="color:#999">;</span><span>
</span><span>  </span><span class="token" style="color:#07a">void</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span> buffer</span><span class="token" style="color:#999">;</span><span>
</span><span>  </span><span class="token" style="color:#07a">int</span><span> buf_len</span><span class="token" style="color:#999">;</span><span>
</span><span> </span><span class="token" style="color:#999">}</span><span> </span><span class="token" style="color:#DD4A68">custom_data_t</span><span class="token" style="color:#999">;</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#07a">int</span><span> </span><span class="token" style="color:#DD4A68">my_url_callback</span><span class="token" style="color:#999">(</span><span>http_parser</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span> parser</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#07a">char</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>at</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#DD4A68">size_t</span><span> length</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>  </span><span class="token" style="color:slategray">/* access to thread local custom_data_t struct.
</span><span class="token" style="color:slategray">  Use this access save parsed data for later use into thread local
</span><span class="token" style="color:slategray">  buffer, or communicate over socket
</span><span class="token" style="color:slategray">  */</span><span>
</span><span>  parser</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>data</span><span class="token" style="color:#999">;</span><span>
</span><span>  </span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span>
</span><span>  </span><span class="token" style="color:#07a">return</span><span> </span><span class="token" style="color:#905">0</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#999">}</span><span>
</span>
<span></span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span>
</span>
<span></span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#DD4A68">http_parser_thread</span><span class="token" style="color:#999">(</span><span class="token" style="color:#DD4A68">socket_t</span><span> sock</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span> </span><span class="token" style="color:#07a">int</span><span> nparsed </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#905">0</span><span class="token" style="color:#999">;</span><span>
</span><span> </span><span class="token" style="color:slategray">/* allocate memory for user data */</span><span>
</span><span> </span><span class="token" style="color:#DD4A68">custom_data_t</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>my_data </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">malloc</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">sizeof</span><span class="token" style="color:#999">(</span><span class="token" style="color:#DD4A68">custom_data_t</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span> </span><span class="token" style="color:slategray">/* some information for use by callbacks.
</span><span class="token" style="color:slategray"> * achieves thread -&gt; callback information flow */</span><span>
</span><span> my_data</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>sock </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> sock</span><span class="token" style="color:#999">;</span><span>
</span>
<span> </span><span class="token" style="color:slategray">/* instantiate a thread-local parser */</span><span>
</span><span> http_parser </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>parser </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">malloc</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">sizeof</span><span class="token" style="color:#999">(</span><span>http_parser</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span> </span><span class="token" style="color:#DD4A68">http_parser_init</span><span class="token" style="color:#999">(</span><span>parser</span><span class="token" style="color:#999">,</span><span> HTTP_REQUEST</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:slategray">/* initialise parser */</span><span>
</span><span> </span><span class="token" style="color:slategray">/* this custom data reference is accessible through the reference to the
</span><span class="token" style="color:slategray"> parser supplied to callback functions */</span><span>
</span><span> parser</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>data </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> my_data</span><span class="token" style="color:#999">;</span><span>
</span>
<span> http_parser_settings settings</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:slategray">/* set up callbacks */</span><span>
</span><span> settings</span><span class="token" style="color:#999">.</span><span>on_url </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> my_url_callback</span><span class="token" style="color:#999">;</span><span>
</span>
<span> </span><span class="token" style="color:slategray">/* execute parser */</span><span>
</span><span> nparsed </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">http_parser_execute</span><span class="token" style="color:#999">(</span><span>parser</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span>settings</span><span class="token" style="color:#999">,</span><span> buf</span><span class="token" style="color:#999">,</span><span> recved</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span>
<span> </span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span>
</span><span> </span><span class="token" style="color:slategray">/* parsed information copied from callback.
</span><span class="token" style="color:slategray"> can now perform action on data copied into thread-local memory from callbacks.
</span><span class="token" style="color:slategray"> achieves callback -&gt; thread information flow */</span><span>
</span><span> my_data</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>buffer</span><span class="token" style="color:#999">;</span><span>
</span><span> </span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span>
</span><span></span><span class="token" style="color:#999">}</span><span>
</span>
</code></pre><p>In case you parse HTTP message in chunks (i.e. <code>read()</code> request line
from socket, parse, read half headers, parse, etc) your data callbacks
may be called more than once. <code>http_parser</code> guarantees that data pointer is only
valid for the lifetime of callback. You can also <code>read()</code> into a heap allocated
buffer to avoid copying memory around if this fits your application.</p><p>Reading headers may be a tricky task if you read/parse headers partially.
Basically, you need to remember whether last header callback was field or value
and apply the following logic:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(on_header_field and on_header_value shortened to on_h_*)
</span> ------------------------ ------------ --------------------------------------------
<!-- -->| State (prev. callback) | Callback   | Description/action                         |
<!-- --> ------------------------ ------------ --------------------------------------------
<!-- -->| nothing (first call)   | on_h_field | Allocate new buffer and copy callback data |
<!-- -->|                        |            | into it                                    |
<!-- --> ------------------------ ------------ --------------------------------------------
<!-- -->| value                  | on_h_field | New header started.                        |
<!-- -->|                        |            | Copy current name,value buffers to headers |
<!-- -->|                        |            | list and allocate new buffer for new name  |
<!-- --> ------------------------ ------------ --------------------------------------------
<!-- -->| field                  | on_h_field | Previous name continues. Reallocate name   |
<!-- -->|                        |            | buffer and append callback data to it      |
<!-- --> ------------------------ ------------ --------------------------------------------
<!-- -->| field                  | on_h_value | Value for current header started. Allocate |
<!-- -->|                        |            | new buffer and copy callback data to it    |
<!-- --> ------------------------ ------------ --------------------------------------------
<!-- -->| value                  | on_h_value | Value continues. Reallocate value buffer   |
<!-- -->|                        |            | and append callback data to it             |
<!-- --> ------------------------ ------------ --------------------------------------------
</code></pre><h2>Parsing URLs</h2><p>A simplistic zero-copy URL parser is provided as <code>http_parser_parse_url()</code>.
Users of this library may wish to use it to parse URLs constructed from
consecutive <code>on_url</code> callbacks.</p><p>See examples of reading in headers:</p><ul><li><a href="http://gist.github.com/155877">partial example</a> in C</li><li><a href="http://github.com/joyent/http-parser/blob/37a0ff8/test.c#L403">from http-parser tests</a> in C</li><li><a href="http://github.com/joyent/node/blob/842eaf4/src/http.js#L284">from Node library</a> in Javascript</li></ul></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/nodejs-http-parser","name":"nodejs/http-parser","licence":"MIT","description":"http request/response parser for c","readme":"HTTP Parser\n===========\n\n[![Build Status](https://api.travis-ci.org/nodejs/http-parser.svg?branch=master)](https://travis-ci.org/nodejs/http-parser)\n\nThis is a parser for HTTP messages written in C. It parses both requests and\nresponses. The parser is designed to be used in performance HTTP\napplications. It does not make any syscalls nor allocations, it does not\nbuffer data, it can be interrupted at anytime. Depending on your\narchitecture, it only requires about 40 bytes of data per message\nstream (in a web server that is per connection).\n\nFeatures:\n\n  * No dependencies\n  * Handles persistent streams (keep-alive).\n  * Decodes chunked encoding.\n  * Upgrade support\n  * Defends against buffer overflow attacks.\n\nThe parser extracts the following information from HTTP messages:\n\n  * Header fields and values\n  * Content-Length\n  * Request method\n  * Response status code\n  * Transfer-Encoding\n  * HTTP version\n  * Request URL\n  * Message body\n\n\nUsage\n-----\n\nOne `http_parser` object is used per TCP connection. Initialize the struct\nusing `http_parser_init()` and set the callbacks. That might look something\nlike this for a request parser:\n```c\nhttp_parser_settings settings;\nsettings.on_url = my_url_callback;\nsettings.on_header_field = my_header_field_callback;\n/* ... */\n\nhttp_parser *parser = malloc(sizeof(http_parser));\nhttp_parser_init(parser, HTTP_REQUEST);\nparser-\u003edata = my_socket;\n```\n\nWhen data is received on the socket execute the parser and check for errors.\n\n```c\nsize_t len = 80*1024, nparsed;\nchar buf[len];\nssize_t recved;\n\nrecved = recv(fd, buf, len, 0);\n\nif (recved \u003c 0) {\n  /* Handle error. */\n}\n\n/* Start up / continue the parser.\n * Note we pass recved==0 to signal that EOF has been received.\n */\nnparsed = http_parser_execute(parser, \u0026settings, buf, recved);\n\nif (parser-\u003eupgrade) {\n  /* handle new protocol */\n} else if (nparsed != recved) {\n  /* Handle error. Usually just close the connection. */\n}\n```\n\n`http_parser` needs to know where the end of the stream is. For example, sometimes\nservers send responses without Content-Length and expect the client to\nconsume input (for the body) until EOF. To tell `http_parser` about EOF, give\n`0` as the fourth parameter to `http_parser_execute()`. Callbacks and errors\ncan still be encountered during an EOF, so one must still be prepared\nto receive them.\n\nScalar valued message information such as `status_code`, `method`, and the\nHTTP version are stored in the parser structure. This data is only\ntemporally stored in `http_parser` and gets reset on each new message. If\nthis information is needed later, copy it out of the structure during the\n`headers_complete` callback.\n\nThe parser decodes the transfer-encoding for both requests and responses\ntransparently. That is, a chunked encoding is decoded before being sent to\nthe on_body callback.\n\n\nThe Special Problem of Upgrade\n------------------------------\n\n`http_parser` supports upgrading the connection to a different protocol. An\nincreasingly common example of this is the WebSocket protocol which sends\na request like\n\n        GET /demo HTTP/1.1\n        Upgrade: WebSocket\n        Connection: Upgrade\n        Host: example.com\n        Origin: http://example.com\n        WebSocket-Protocol: sample\n\nfollowed by non-HTTP data.\n\n(See [RFC6455](https://tools.ietf.org/html/rfc6455) for more information the\nWebSocket protocol.)\n\nTo support this, the parser will treat this as a normal HTTP message without a\nbody, issuing both on_headers_complete and on_message_complete callbacks. However\nhttp_parser_execute() will stop parsing at the end of the headers and return.\n\nThe user is expected to check if `parser-\u003eupgrade` has been set to 1 after\n`http_parser_execute()` returns. Non-HTTP data begins at the buffer supplied\noffset by the return value of `http_parser_execute()`.\n\n\nCallbacks\n---------\n\nDuring the `http_parser_execute()` call, the callbacks set in\n`http_parser_settings` will be executed. The parser maintains state and\nnever looks behind, so buffering the data is not necessary. If you need to\nsave certain data for later usage, you can do that from the callbacks.\n\nThere are two types of callbacks:\n\n* notification `typedef int (*http_cb) (http_parser*);`\n    Callbacks: on_message_begin, on_headers_complete, on_message_complete.\n* data `typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);`\n    Callbacks: (requests only) on_url,\n               (common) on_header_field, on_header_value, on_body;\n\nCallbacks must return 0 on success. Returning a non-zero value indicates\nerror to the parser, making it exit immediately.\n\nFor cases where it is necessary to pass local information to/from a callback,\nthe `http_parser` object's `data` field can be used.\nAn example of such a case is when using threads to handle a socket connection,\nparse a request, and then give a response over that socket. By instantiation\nof a thread-local struct containing relevant data (e.g. accepted socket,\nallocated memory for callbacks to write into, etc), a parser's callbacks are\nable to communicate data between the scope of the thread and the scope of the\ncallback in a threadsafe manner. This allows `http_parser` to be used in\nmulti-threaded contexts.\n\nExample:\n```c\n typedef struct {\n  socket_t sock;\n  void* buffer;\n  int buf_len;\n } custom_data_t;\n\n\nint my_url_callback(http_parser* parser, const char *at, size_t length) {\n  /* access to thread local custom_data_t struct.\n  Use this access save parsed data for later use into thread local\n  buffer, or communicate over socket\n  */\n  parser-\u003edata;\n  ...\n  return 0;\n}\n\n...\n\nvoid http_parser_thread(socket_t sock) {\n int nparsed = 0;\n /* allocate memory for user data */\n custom_data_t *my_data = malloc(sizeof(custom_data_t));\n\n /* some information for use by callbacks.\n * achieves thread -\u003e callback information flow */\n my_data-\u003esock = sock;\n\n /* instantiate a thread-local parser */\n http_parser *parser = malloc(sizeof(http_parser));\n http_parser_init(parser, HTTP_REQUEST); /* initialise parser */\n /* this custom data reference is accessible through the reference to the\n parser supplied to callback functions */\n parser-\u003edata = my_data;\n\n http_parser_settings settings; /* set up callbacks */\n settings.on_url = my_url_callback;\n\n /* execute parser */\n nparsed = http_parser_execute(parser, \u0026settings, buf, recved);\n\n ...\n /* parsed information copied from callback.\n can now perform action on data copied into thread-local memory from callbacks.\n achieves callback -\u003e thread information flow */\n my_data-\u003ebuffer;\n ...\n}\n\n```\n\nIn case you parse HTTP message in chunks (i.e. `read()` request line\nfrom socket, parse, read half headers, parse, etc) your data callbacks\nmay be called more than once. `http_parser` guarantees that data pointer is only\nvalid for the lifetime of callback. You can also `read()` into a heap allocated\nbuffer to avoid copying memory around if this fits your application.\n\nReading headers may be a tricky task if you read/parse headers partially.\nBasically, you need to remember whether last header callback was field or value\nand apply the following logic:\n\n    (on_header_field and on_header_value shortened to on_h_*)\n     ------------------------ ------------ --------------------------------------------\n    | State (prev. callback) | Callback   | Description/action                         |\n     ------------------------ ------------ --------------------------------------------\n    | nothing (first call)   | on_h_field | Allocate new buffer and copy callback data |\n    |                        |            | into it                                    |\n     ------------------------ ------------ --------------------------------------------\n    | value                  | on_h_field | New header started.                        |\n    |                        |            | Copy current name,value buffers to headers |\n    |                        |            | list and allocate new buffer for new name  |\n     ------------------------ ------------ --------------------------------------------\n    | field                  | on_h_field | Previous name continues. Reallocate name   |\n    |                        |            | buffer and append callback data to it      |\n     ------------------------ ------------ --------------------------------------------\n    | field                  | on_h_value | Value for current header started. Allocate |\n    |                        |            | new buffer and copy callback data to it    |\n     ------------------------ ------------ --------------------------------------------\n    | value                  | on_h_value | Value continues. Reallocate value buffer   |\n    |                        |            | and append callback data to it             |\n     ------------------------ ------------ --------------------------------------------\n\n\nParsing URLs\n------------\n\nA simplistic zero-copy URL parser is provided as `http_parser_parse_url()`.\nUsers of this library may wish to use it to parse URLs constructed from\nconsecutive `on_url` callbacks.\n\nSee examples of reading in headers:\n\n* [partial example](http://gist.github.com/155877) in C\n* [from http-parser tests](http://github.com/joyent/http-parser/blob/37a0ff8/test.c#L403) in C\n* [from Node library](http://github.com/joyent/node/blob/842eaf4/src/http.js#L284) in Javascript\n","versions":[{"ref":"master","manifest":"targets = [ \"//:http-parser\" ]\n","lockFile":"manifest = \"d5770c2cf71b6b0985fa3ded68267be1a32930b62a855b2c27cd3d348d736a96\"\n\n","buck":"cxx_library(\n  name = 'http-parser',\n  header_namespace = '',\n  exported_headers = [\n    'http_parser.h'\n  ],\n  srcs = [\n    'http_parser.c',\n  ],\n  licenses = [\n    'LICENSE-MIT',\n  ],\n  visibility = [\n    'PUBLIC',\n  ],\n)\n\ncxx_binary(\n  name = 'bench',\n  srcs = [\n    'bench.c',\n  ],\n  deps = [\n    ':http-parser',\n  ],\n)\n\ncxx_binary(\n  name = 'test',\n  srcs = [\n    'test.c',\n  ],\n  deps = [\n    ':http-parser',\n  ],\n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2019-01-10T12:13:15Z","updatedUpstream":"2021-01-13T12:28:02Z","contributors":[{"login":"ry","avatarUrl":"https://avatars1.githubusercontent.com/u/80?v=4"},{"login":"sgala","avatarUrl":"https://avatars1.githubusercontent.com/u/2065?v=4"},{"login":"fmardini","avatarUrl":"https://avatars3.githubusercontent.com/u/2519?v=4"},{"login":"tmm1","avatarUrl":"https://avatars2.githubusercontent.com/u/2567?v=4"},{"login":"copiousfreetime","avatarUrl":"https://avatars1.githubusercontent.com/u/11256?v=4"},{"login":"felixge","avatarUrl":"https://avatars1.githubusercontent.com/u/15000?u=f9b953343c6ce2e8c88ce31e8fcc45940d098890\u0026v=4"},{"login":"dpw","avatarUrl":"https://avatars1.githubusercontent.com/u/15074?v=4"},{"login":"sam-github","avatarUrl":"https://avatars1.githubusercontent.com/u/17607?u=742e8c56b91f17b08a5ca4d7d7126780b9be020b\u0026v=4"},{"login":"apapirovski","avatarUrl":"https://avatars1.githubusercontent.com/u/20809?u=a6ea6631cd599d9be73d8521d82425161238f1ff\u0026v=4"},{"login":"ice799","avatarUrl":"https://avatars2.githubusercontent.com/u/21102?v=4"},{"login":"temoto","avatarUrl":"https://avatars0.githubusercontent.com/u/27057?u=a2ca3f3d2759ab93a3579a8ba46d0654fdc65d60\u0026v=4"},{"login":"ulikoehler","avatarUrl":"https://avatars2.githubusercontent.com/u/34971?v=4"},{"login":"a2800276","avatarUrl":"https://avatars3.githubusercontent.com/u/35631?v=4"},{"login":"chrisdickinson","avatarUrl":"https://avatars0.githubusercontent.com/u/37303?u=05dae5e735ecb5e198328996db361672bcb15fcf\u0026v=4"},{"login":"gmiroshnykov","avatarUrl":"https://avatars2.githubusercontent.com/u/44974?u=d27c341980f94dc5785bfccc492016293581564d\u0026v=4"},{"login":"ljharb","avatarUrl":"https://avatars0.githubusercontent.com/u/45469?u=6ab74b3b934f9659a90b588062c2c4328e40c6be\u0026v=4"},{"login":"ewencp","avatarUrl":"https://avatars0.githubusercontent.com/u/47366?u=da0eb3f84760ca12c1ba99879aa4ba9b69cf49e9\u0026v=4"},{"login":"misery","avatarUrl":"https://avatars3.githubusercontent.com/u/50925?u=1315ae31859465e66930e478edc60dee6eaebe1c\u0026v=4"},{"login":"mcollina","avatarUrl":"https://avatars1.githubusercontent.com/u/52195?u=08bcafa24337a298e1b874279fde515e2fb8f81d\u0026v=4"},{"login":"mscdex","avatarUrl":"https://avatars2.githubusercontent.com/u/54666?u=24c70ecc9905bb596bd98fa2b3f005f8d44c837e\u0026v=4"},{"login":"TooTallNate","avatarUrl":"https://avatars1.githubusercontent.com/u/71256?u=d6a9598cd7963ae290923ab12afeff947f542f80\u0026v=4"},{"login":"fhinkel","avatarUrl":"https://avatars0.githubusercontent.com/u/101553?u=ba04735186648afde39087bcc13d86e44c232a76\u0026v=4"},{"login":"pquerna","avatarUrl":"https://avatars1.githubusercontent.com/u/110123?v=4"},{"login":"tomika","avatarUrl":"https://avatars3.githubusercontent.com/u/116955?u=92bd373b89a856a6561118794d737f6a188941e2\u0026v=4"},{"login":"dolmen","avatarUrl":"https://avatars1.githubusercontent.com/u/129536?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":5640,"forks":1444,"topics":["nodejs","node"]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"nodejs-http-parser"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>