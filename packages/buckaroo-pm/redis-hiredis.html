<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/redis-hiredis/logo.png"/></div><div><h1>buckaroo-pm/redis-hiredis</h1><div style="max-width:600px">Minimalistic C client for Redis &gt;= 1.2</div><br/><div><b>4715</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">LockFile</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><p><a href="https://travis-ci.org/redis/hiredis"><img src="https://travis-ci.org/redis/hiredis.png" alt="Build Status"/></a></p><p><strong>This Readme reflects the latest changed in the master branch. See <a href="https://github.com/redis/hiredis/tree/v0.13.3">v0.13.3</a> for the Readme and documentation for the latest release.</strong></p><h1>HIREDIS</h1><p>Hiredis is a minimalistic C client library for the <a href="http://redis.io/">Redis</a> database.</p><p>It is minimalistic because it just adds minimal support for the protocol, but
at the same time it uses a high level printf-alike API in order to make it
much higher level than otherwise suggested by its minimal code base and the
lack of explicit bindings for every Redis command.</p><p>Apart from supporting sending commands and receiving replies, it comes with
a reply parser that is decoupled from the I/O layer. It
is a stream parser designed for easy reusability, which can for instance be used
in higher level language bindings for efficient reply parsing.</p><p>Hiredis only supports the binary-safe Redis protocol, so you can use it with any
Redis version &gt;= 1.2.0.</p><p>The library comes with multiple APIs. There is the
<em>synchronous API</em>, the <em>asynchronous API</em> and the <em>reply parsing API</em>.</p><h2>Upgrading to <code>1.0.0</code></h2><p>Version 1.0.0 marks a stable release of hiredis.
It includes some minor breaking changes, mostly to make the exposed API more uniform and self-explanatory.
It also bundles the updated <code>sds</code> library, to sync up with upstream and Redis.
For most applications a recompile against the new hiredis should be enough.
For code changes see the <a href="CHANGELOG.md">Changelog</a>.</p><h2>Upgrading from <code>&lt;0.9.0</code></h2><p>Version 0.9.0 is a major overhaul of hiredis in every aspect. However, upgrading existing
code using hiredis should not be a big pain. The key thing to keep in mind when
upgrading is that hiredis &gt;= 0.9.0 uses a <code>redisContext*</code> to keep state, in contrast to
the stateless 0.0.1 that only has a file descriptor to work with.</p><h2>Synchronous API</h2><p>To consume the synchronous API, there are only a few function calls that need to be introduced:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>redisContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#DD4A68">redisConnect</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#07a">char</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>ip</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">int</span><span> port</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#DD4A68">redisCommand</span><span class="token" style="color:#999">(</span><span>redisContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>c</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#07a">char</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>format</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#DD4A68">freeReplyObject</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>reply</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><h3>Connecting</h3><p>The function <code>redisConnect</code> is used to create a so-called <code>redisContext</code>. The
context is where Hiredis holds state for a connection. The <code>redisContext</code>
struct has an integer <code>err</code> field that is non-zero when the connection is in
an error state. The field <code>errstr</code> will contain a string with a description of
the error. More information on errors can be found in the <strong>Errors</strong> section.
After trying to connect to Redis using <code>redisConnect</code> you should
check the <code>err</code> field to see if establishing the connection was successful:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>redisContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>c </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">redisConnect</span><span class="token" style="color:#999">(</span><span class="token" style="color:#690">&quot;127.0.0.1&quot;</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#905">6379</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">if</span><span> </span><span class="token" style="color:#999">(</span><span>c </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> </span><span class="token" style="color:#905">NULL</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">||</span><span> c</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>err</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>    </span><span class="token" style="color:#07a">if</span><span> </span><span class="token" style="color:#999">(</span><span>c</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>        </span><span class="token" style="color:#DD4A68">printf</span><span class="token" style="color:#999">(</span><span class="token" style="color:#690">&quot;Error: %s\n&quot;</span><span class="token" style="color:#999">,</span><span> c</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>errstr</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>        </span><span class="token" style="color:slategray">// handle error</span><span>
</span><span>    </span><span class="token" style="color:#999">}</span><span> </span><span class="token" style="color:#07a">else</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>        </span><span class="token" style="color:#DD4A68">printf</span><span class="token" style="color:#999">(</span><span class="token" style="color:#690">&quot;Can&#x27;t allocate redis context\n&quot;</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>    </span><span class="token" style="color:#999">}</span><span>
</span><span></span><span class="token" style="color:#999">}</span></code></pre><p><em>Note: A <code>redisContext</code> is not thread-safe.</em></p><h3>Sending commands</h3><p>There are several ways to issue commands to Redis. The first that will be introduced is
<code>redisCommand</code>. This function takes a format similar to printf. In the simplest form,
it is used like this:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>reply </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">redisCommand</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#690">&quot;SET foo bar&quot;</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>The specifier <code>%s</code> interpolates a string in the command, and uses <code>strlen</code> to
determine the length of the string:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>reply </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">redisCommand</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#690">&quot;SET foo %s&quot;</span><span class="token" style="color:#999">,</span><span> value</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>When you need to pass binary safe strings in a command, the <code>%b</code> specifier can be
used. Together with a pointer to the string, it requires a <code>size_t</code> length argument
of the string:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>reply </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">redisCommand</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#690">&quot;SET foo %b&quot;</span><span class="token" style="color:#999">,</span><span> value</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#999">(</span><span class="token" style="color:#DD4A68">size_t</span><span class="token" style="color:#999">)</span><span> valuelen</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>Internally, Hiredis splits the command in different arguments and will
convert it to the protocol used to communicate with Redis.
One or more spaces separates arguments, so you can use the specifiers
anywhere in an argument:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>reply </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">redisCommand</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#690">&quot;SET key:%s %s&quot;</span><span class="token" style="color:#999">,</span><span> myid</span><span class="token" style="color:#999">,</span><span> value</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><h3>Using replies</h3><p>The return value of <code>redisCommand</code> holds a reply when the command was
successfully executed. When an error occurs, the return value is <code>NULL</code> and
the <code>err</code> field in the context will be set (see section on <strong>Errors</strong>).
Once an error is returned the context cannot be reused and you should set up
a new connection.</p><p>The standard replies that <code>redisCommand</code> are of the type <code>redisReply</code>. The
<code>type</code> field in the <code>redisReply</code> should be used to test what kind of reply
was received:</p><ul><li><p><strong><code>REDIS_REPLY_STATUS</code></strong>:</p><ul><li>The command replied with a status reply. The status string can be accessed using <code>reply-&gt;str</code>.
The length of this string can be accessed using <code>reply-&gt;len</code>.</li></ul></li><li><p><strong><code>REDIS_REPLY_ERROR</code></strong>:</p><ul><li>The command replied with an error. The error string can be accessed identical to <code>REDIS_REPLY_STATUS</code>.</li></ul></li><li><p><strong><code>REDIS_REPLY_INTEGER</code></strong>:</p><ul><li>The command replied with an integer. The integer value can be accessed using the
<code>reply-&gt;integer</code> field of type <code>long long</code>.</li></ul></li><li><p><strong><code>REDIS_REPLY_NIL</code></strong>:</p><ul><li>The command replied with a <strong>nil</strong> object. There is no data to access.</li></ul></li><li><p><strong><code>REDIS_REPLY_STRING</code></strong>:</p><ul><li>A bulk (string) reply. The value of the reply can be accessed using <code>reply-&gt;str</code>.
The length of this string can be accessed using <code>reply-&gt;len</code>.</li></ul></li><li><p><strong><code>REDIS_REPLY_ARRAY</code></strong>:</p><ul><li>A multi bulk reply. The number of elements in the multi bulk reply is stored in
<code>reply-&gt;elements</code>. Every element in the multi bulk reply is a <code>redisReply</code> object as well
and can be accessed via <code>reply-&gt;element[..index..]</code>.
Redis may reply with nested arrays but this is fully supported.</li></ul></li></ul><p>Replies should be freed using the <code>freeReplyObject()</code> function.
Note that this function will take care of freeing sub-reply objects
contained in arrays and nested arrays, so there is no need for the user to
free the sub replies (it is actually harmful and will corrupt the memory).</p><p><strong>Important:</strong> the current version of hiredis (0.10.0) frees replies when the
asynchronous API is used. This means you should not call <code>freeReplyObject</code> when
you use this API. The reply is cleaned up by hiredis <em>after</em> the callback
returns. This behavior will probably change in future releases, so make sure to
keep an eye on the changelog when upgrading (see issue #39).</p><h3>Cleaning up</h3><p>To disconnect and free the context the following function can be used:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#DD4A68">redisFree</span><span class="token" style="color:#999">(</span><span>redisContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>c</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>This function immediately closes the socket and then frees the allocations done in
creating the context.</p><h3>Sending commands (cont&#x27;d)</h3><p>Together with <code>redisCommand</code>, the function <code>redisCommandArgv</code> can be used to issue commands.
It has the following prototype:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#DD4A68">redisCommandArgv</span><span class="token" style="color:#999">(</span><span>redisContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>c</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">int</span><span> argc</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#07a">char</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>argv</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#DD4A68">size_t</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>argvlen</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>It takes the number of arguments <code>argc</code>, an array of strings <code>argv</code> and the lengths of the
arguments <code>argvlen</code>. For convenience, <code>argvlen</code> may be set to <code>NULL</code> and the function will
use <code>strlen(3)</code> on every argument to determine its length. Obviously, when any of the arguments
need to be binary safe, the entire array of lengths <code>argvlen</code> should be provided.</p><p>The return value has the same semantic as <code>redisCommand</code>.</p><h3>Pipelining</h3><p>To explain how Hiredis supports pipelining in a blocking connection, there needs to be
understanding of the internal execution flow.</p><p>When any of the functions in the <code>redisCommand</code> family is called, Hiredis first formats the
command according to the Redis protocol. The formatted command is then put in the output buffer
of the context. This output buffer is dynamic, so it can hold any number of commands.
After the command is put in the output buffer, <code>redisGetReply</code> is called. This function has the
following two execution paths:</p><ol><li>The input buffer is non-empty:<ul><li>Try to parse a single reply from the input buffer and return it</li><li>If no reply could be parsed, continue at <em>2</em></li></ul></li><li>The input buffer is empty:<ul><li>Write the <strong>entire</strong> output buffer to the socket</li><li>Read from the socket until a single reply could be parsed</li></ul></li></ol><p>The function <code>redisGetReply</code> is exported as part of the Hiredis API and can be used when a reply
is expected on the socket. To pipeline commands, the only things that needs to be done is
filling up the output buffer. For this cause, two commands can be used that are identical
to the <code>redisCommand</code> family, apart from not returning a reply:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#DD4A68">redisAppendCommand</span><span class="token" style="color:#999">(</span><span>redisContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>c</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#07a">char</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>format</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#DD4A68">redisAppendCommandArgv</span><span class="token" style="color:#999">(</span><span>redisContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>c</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">int</span><span> argc</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#07a">char</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>argv</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#DD4A68">size_t</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>argvlen</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>After calling either function one or more times, <code>redisGetReply</code> can be used to receive the
subsequent replies. The return value for this function is either <code>REDIS_OK</code> or <code>REDIS_ERR</code>, where
the latter means an error occurred while reading a reply. Just as with the other commands,
the <code>err</code> field in the context can be used to find out what the cause of this error is.</p><p>The following examples shows a simple pipeline (resulting in only a single call to <code>write(2)</code> and
a single call to <code>read(2)</code>):</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>redisReply </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>reply</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#DD4A68">redisAppendCommand</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span class="token" style="color:#690">&quot;SET foo bar&quot;</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#DD4A68">redisAppendCommand</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span class="token" style="color:#690">&quot;GET foo&quot;</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#DD4A68">redisGetReply</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span>reply</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:slategray">// reply for SET</span><span>
</span><span></span><span class="token" style="color:#DD4A68">freeReplyObject</span><span class="token" style="color:#999">(</span><span>reply</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#DD4A68">redisGetReply</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span>reply</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span> </span><span class="token" style="color:slategray">// reply for GET</span><span>
</span><span></span><span class="token" style="color:#DD4A68">freeReplyObject</span><span class="token" style="color:#999">(</span><span>reply</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>This API can also be used to implement a blocking subscriber:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>reply </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">redisCommand</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span class="token" style="color:#690">&quot;SUBSCRIBE foo&quot;</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#DD4A68">freeReplyObject</span><span class="token" style="color:#999">(</span><span>reply</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">while</span><span class="token" style="color:#999">(</span><span class="token" style="color:#DD4A68">redisGetReply</span><span class="token" style="color:#999">(</span><span>context</span><span class="token" style="color:#999">,</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">&amp;</span><span>reply</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">==</span><span> REDIS_OK</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>    </span><span class="token" style="color:slategray">// consume message</span><span>
</span><span>    </span><span class="token" style="color:#DD4A68">freeReplyObject</span><span class="token" style="color:#999">(</span><span>reply</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#999">}</span></code></pre><h3>Errors</h3><p>When a function call is not successful, depending on the function either <code>NULL</code> or <code>REDIS_ERR</code> is
returned. The <code>err</code> field inside the context will be non-zero and set to one of the
following constants:</p><ul><li><p><strong><code>REDIS_ERR_IO</code></strong>:
There was an I/O error while creating the connection, trying to write
to the socket or read from the socket. If you included <code>errno.h</code> in your
application, you can use the global <code>errno</code> variable to find out what is
wrong.</p></li><li><p><strong><code>REDIS_ERR_EOF</code></strong>:
The server closed the connection which resulted in an empty read.</p></li><li><p><strong><code>REDIS_ERR_PROTOCOL</code></strong>:
There was an error while parsing the protocol.</p></li><li><p><strong><code>REDIS_ERR_OTHER</code></strong>:
Any other error. Currently, it is only used when a specified hostname to connect
to cannot be resolved.</p></li></ul><p>In every case, the <code>errstr</code> field in the context will be set to hold a string representation
of the error.</p><h2>Asynchronous API</h2><p>Hiredis comes with an asynchronous API that works easily with any event library.
Examples are bundled that show using Hiredis with <a href="http://software.schmorp.de/pkg/libev.html">libev</a>
and <a href="http://monkey.org/~provos/libevent/">libevent</a>.</p><h3>Connecting</h3><p>The function <code>redisAsyncConnect</code> can be used to establish a non-blocking connection to
Redis. It returns a pointer to the newly created <code>redisAsyncContext</code> struct. The <code>err</code> field
should be checked after creation to see if there were errors creating the connection.
Because the connection that will be created is non-blocking, the kernel is not able to
instantly return if the specified host and port is able to accept a connection.</p><p><em>Note: A <code>redisAsyncContext</code> is not thread-safe.</em></p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>redisAsyncContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>c </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#DD4A68">redisAsyncConnect</span><span class="token" style="color:#999">(</span><span class="token" style="color:#690">&quot;127.0.0.1&quot;</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#905">6379</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">if</span><span> </span><span class="token" style="color:#999">(</span><span>c</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>err</span><span class="token" style="color:#999">)</span><span> </span><span class="token" style="color:#999">{</span><span>
</span><span>    </span><span class="token" style="color:#DD4A68">printf</span><span class="token" style="color:#999">(</span><span class="token" style="color:#690">&quot;Error: %s\n&quot;</span><span class="token" style="color:#999">,</span><span> c</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>errstr</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span>    </span><span class="token" style="color:slategray">// handle error</span><span>
</span><span></span><span class="token" style="color:#999">}</span></code></pre><p>The asynchronous context can hold a disconnect callback function that is called when the
connection is disconnected (either because of an error or per user request). This function should
have the following prototype:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">void</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">const</span><span> redisAsyncContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>c</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">int</span><span> status</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>On a disconnect, the <code>status</code> argument is set to <code>REDIS_OK</code> when disconnection was initiated by the
user, or <code>REDIS_ERR</code> when the disconnection was caused by an error. When it is <code>REDIS_ERR</code>, the <code>err</code>
field in the context can be accessed to find out the cause of the error.</p><p>The context object is always freed after the disconnect callback fired. When a reconnect is needed,
the disconnect callback is a good point to do so.</p><p>Setting the disconnect callback can only be done once per context. For subsequent calls it will
return <code>REDIS_ERR</code>. The function to set the disconnect callback has the following prototype:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">int</span><span> </span><span class="token" style="color:#DD4A68">redisAsyncSetDisconnectCallback</span><span class="token" style="color:#999">(</span><span>redisAsyncContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>ac</span><span class="token" style="color:#999">,</span><span> redisDisconnectCallback </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>fn</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><h3>Sending commands and their callbacks</h3><p>In an asynchronous context, commands are automatically pipelined due to the nature of an event loop.
Therefore, unlike the synchronous API, there is only a single way to send commands.
Because commands are sent to Redis asynchronously, issuing a command requires a callback function
that is called when the reply is received. Reply callbacks should have the following prototype:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">void</span><span class="token" style="color:#999">(</span><span>redisAsyncContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>c</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>reply</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>privdata</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>The <code>privdata</code> argument can be used to curry arbitrary data to the callback from the point where
the command is initially queued for execution.</p><p>The functions that can be used to issue commands in an asynchronous context are:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">int</span><span> </span><span class="token" style="color:#DD4A68">redisAsyncCommand</span><span class="token" style="color:#999">(</span><span>
</span><span>  redisAsyncContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>ac</span><span class="token" style="color:#999">,</span><span> redisCallbackFn </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>fn</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>privdata</span><span class="token" style="color:#999">,</span><span>
</span><span>  </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#07a">char</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>format</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">.</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">int</span><span> </span><span class="token" style="color:#DD4A68">redisAsyncCommandArgv</span><span class="token" style="color:#999">(</span><span>
</span><span>  redisAsyncContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>ac</span><span class="token" style="color:#999">,</span><span> redisCallbackFn </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>fn</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>privdata</span><span class="token" style="color:#999">,</span><span>
</span><span>  </span><span class="token" style="color:#07a">int</span><span> argc</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#07a">char</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>argv</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#DD4A68">size_t</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>argvlen</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>Both functions work like their blocking counterparts. The return value is <code>REDIS_OK</code> when the command
was successfully added to the output buffer and <code>REDIS_ERR</code> otherwise. Example: when the connection
is being disconnected per user-request, no new commands may be added to the output buffer and <code>REDIS_ERR</code> is
returned on calls to the <code>redisAsyncCommand</code> family.</p><p>If the reply for a command with a <code>NULL</code> callback is read, it is immediately freed. When the callback
for a command is non-<code>NULL</code>, the memory is freed immediately following the callback: the reply is only
valid for the duration of the callback.</p><p>All pending callbacks are called with a <code>NULL</code> reply when the context encountered an error.</p><h3>Disconnecting</h3><p>An asynchronous connection can be terminated using:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#DD4A68">redisAsyncDisconnect</span><span class="token" style="color:#999">(</span><span>redisAsyncContext </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>ac</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>When this function is called, the connection is <strong>not</strong> immediately terminated. Instead, new
commands are no longer accepted and the connection is only terminated when all pending commands
have been written to the socket, their respective replies have been read and their respective
callbacks have been executed. After this, the disconnection callback is executed with the
<code>REDIS_OK</code> status and the context object is freed.</p><h3>Hooking it up to event library <em>X</em></h3><p>There are a few hooks that need to be set on the context object after it is created.
See the <code>adapters/</code> directory for bindings to <em>libev</em> and <em>libevent</em>.</p><h2>Reply parsing API</h2><p>Hiredis comes with a reply parsing API that makes it easy for writing higher
level language bindings.</p><p>The reply parsing API consists of the following functions:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>redisReader </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#DD4A68">redisReaderCreate</span><span class="token" style="color:#999">(</span><span class="token" style="color:#07a">void</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#DD4A68">redisReaderFree</span><span class="token" style="color:#999">(</span><span>redisReader </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>reader</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">int</span><span> </span><span class="token" style="color:#DD4A68">redisReaderFeed</span><span class="token" style="color:#999">(</span><span>redisReader </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>reader</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">const</span><span> </span><span class="token" style="color:#07a">char</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>buf</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#DD4A68">size_t</span><span> len</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span><span>
</span><span></span><span class="token" style="color:#07a">int</span><span> </span><span class="token" style="color:#DD4A68">redisReaderGetReply</span><span class="token" style="color:#999">(</span><span>redisReader </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>reader</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#07a">void</span><span> </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">*</span><span>reply</span><span class="token" style="color:#999">)</span><span class="token" style="color:#999">;</span></code></pre><p>The same set of functions are used internally by hiredis when creating a
normal Redis context, the above API just exposes it to the user for a direct
usage.</p><h3>Usage</h3><p>The function <code>redisReaderCreate</code> creates a <code>redisReader</code> structure that holds a
buffer with unparsed data and state for the protocol parser.</p><p>Incoming data -- most likely from a socket -- can be placed in the internal
buffer of the <code>redisReader</code> using <code>redisReaderFeed</code>. This function will make a
copy of the buffer pointed to by <code>buf</code> for <code>len</code> bytes. This data is parsed
when <code>redisReaderGetReply</code> is called. This function returns an integer status
and a reply object (as described above) via <code>void **reply</code>. The returned status
can be either <code>REDIS_OK</code> or <code>REDIS_ERR</code>, where the latter means something went
wrong (either a protocol error, or an out of memory error).</p><p>The parser limits the level of nesting for multi bulk payloads to 7. If the
multi bulk nesting level is higher than this, the parser returns an error.</p><h3>Customizing replies</h3><p>The function <code>redisReaderGetReply</code> creates <code>redisReply</code> and makes the function
argument <code>reply</code> point to the created <code>redisReply</code> variable. For instance, if
the response of type <code>REDIS_REPLY_STATUS</code> then the <code>str</code> field of <code>redisReply</code>
will hold the status as a vanilla C string. However, the functions that are
responsible for creating instances of the <code>redisReply</code> can be customized by
setting the <code>fn</code> field on the <code>redisReader</code> struct. This should be done
immediately after creating the <code>redisReader</code>.</p><p>For example, <a href="https://github.com/pietern/hiredis-rb/blob/master/ext/hiredis_ext/reader.c">hiredis-rb</a>
uses customized reply object functions to create Ruby objects.</p><h3>Reader max buffer</h3><p>Both when using the Reader API directly or when using it indirectly via a
normal Redis context, the redisReader structure uses a buffer in order to
accumulate data from the server.
Usually this buffer is destroyed when it is empty and is larger than 16
KiB in order to avoid wasting memory in unused buffers</p><p>However when working with very big payloads destroying the buffer may slow
down performances considerably, so it is possible to modify the max size of
an idle buffer changing the value of the <code>maxbuf</code> field of the reader structure
to the desired value. The special value of 0 means that there is no maximum
value for an idle buffer, so the buffer will never get freed.</p><p>For instance if you have a normal Redis context you can set the maximum idle
buffer to zero (unlimited) just with:</p><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>context</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>reader</span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">-&gt;</span><span>maxbuf </span><span class="token" style="color:#9a6e3a;background:hsla(0, 0%, 100%, .5)">=</span><span> </span><span class="token" style="color:#905">0</span><span class="token" style="color:#999">;</span></code></pre><p>This should be done only in order to maximize performances when working with
large payloads. The context should be set back to <code>REDIS_READER_MAX_BUF</code> again
as soon as possible in order to prevent allocation of useless memory.</p><h2>AUTHORS</h2><p>Hiredis was written by Salvatore Sanfilippo (antirez at gmail) and
Pieter Noordhuis (pcnoordhuis at gmail) and is released under the BSD license.<br/>Hiredis is currently maintained by Matt Stancliff (matt at genges dot com) and
Jan-Erik Rediger (janerik at fnordig dot com)</p></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/redis-hiredis","name":"redis/hiredis","licence":"BSD-3-Clause","description":"Minimalistic C client for Redis \u003e= 1.2","readme":"[![Build Status](https://travis-ci.org/redis/hiredis.png)](https://travis-ci.org/redis/hiredis)\n\n**This Readme reflects the latest changed in the master branch. See [v0.13.3](https://github.com/redis/hiredis/tree/v0.13.3) for the Readme and documentation for the latest release.**\n\n# HIREDIS\n\nHiredis is a minimalistic C client library for the [Redis](http://redis.io/) database.\n\nIt is minimalistic because it just adds minimal support for the protocol, but\nat the same time it uses a high level printf-alike API in order to make it\nmuch higher level than otherwise suggested by its minimal code base and the\nlack of explicit bindings for every Redis command.\n\nApart from supporting sending commands and receiving replies, it comes with\na reply parser that is decoupled from the I/O layer. It\nis a stream parser designed for easy reusability, which can for instance be used\nin higher level language bindings for efficient reply parsing.\n\nHiredis only supports the binary-safe Redis protocol, so you can use it with any\nRedis version \u003e= 1.2.0.\n\nThe library comes with multiple APIs. There is the\n*synchronous API*, the *asynchronous API* and the *reply parsing API*.\n\n## Upgrading to `1.0.0`\n\nVersion 1.0.0 marks a stable release of hiredis.\nIt includes some minor breaking changes, mostly to make the exposed API more uniform and self-explanatory.\nIt also bundles the updated `sds` library, to sync up with upstream and Redis.\nFor most applications a recompile against the new hiredis should be enough.\nFor code changes see the [Changelog](CHANGELOG.md).\n\n## Upgrading from `\u003c0.9.0`\n\nVersion 0.9.0 is a major overhaul of hiredis in every aspect. However, upgrading existing\ncode using hiredis should not be a big pain. The key thing to keep in mind when\nupgrading is that hiredis \u003e= 0.9.0 uses a `redisContext*` to keep state, in contrast to\nthe stateless 0.0.1 that only has a file descriptor to work with.\n\n## Synchronous API\n\nTo consume the synchronous API, there are only a few function calls that need to be introduced:\n\n```c\nredisContext *redisConnect(const char *ip, int port);\nvoid *redisCommand(redisContext *c, const char *format, ...);\nvoid freeReplyObject(void *reply);\n```\n\n### Connecting\n\nThe function `redisConnect` is used to create a so-called `redisContext`. The\ncontext is where Hiredis holds state for a connection. The `redisContext`\nstruct has an integer `err` field that is non-zero when the connection is in\nan error state. The field `errstr` will contain a string with a description of\nthe error. More information on errors can be found in the **Errors** section.\nAfter trying to connect to Redis using `redisConnect` you should\ncheck the `err` field to see if establishing the connection was successful:\n```c\nredisContext *c = redisConnect(\"127.0.0.1\", 6379);\nif (c == NULL || c-\u003eerr) {\n    if (c) {\n        printf(\"Error: %s\\n\", c-\u003eerrstr);\n        // handle error\n    } else {\n        printf(\"Can't allocate redis context\\n\");\n    }\n}\n```\n\n*Note: A `redisContext` is not thread-safe.*\n\n### Sending commands\n\nThere are several ways to issue commands to Redis. The first that will be introduced is\n`redisCommand`. This function takes a format similar to printf. In the simplest form,\nit is used like this:\n```c\nreply = redisCommand(context, \"SET foo bar\");\n```\n\nThe specifier `%s` interpolates a string in the command, and uses `strlen` to\ndetermine the length of the string:\n```c\nreply = redisCommand(context, \"SET foo %s\", value);\n```\nWhen you need to pass binary safe strings in a command, the `%b` specifier can be\nused. Together with a pointer to the string, it requires a `size_t` length argument\nof the string:\n```c\nreply = redisCommand(context, \"SET foo %b\", value, (size_t) valuelen);\n```\nInternally, Hiredis splits the command in different arguments and will\nconvert it to the protocol used to communicate with Redis.\nOne or more spaces separates arguments, so you can use the specifiers\nanywhere in an argument:\n```c\nreply = redisCommand(context, \"SET key:%s %s\", myid, value);\n```\n\n### Using replies\n\nThe return value of `redisCommand` holds a reply when the command was\nsuccessfully executed. When an error occurs, the return value is `NULL` and\nthe `err` field in the context will be set (see section on **Errors**).\nOnce an error is returned the context cannot be reused and you should set up\na new connection.\n\nThe standard replies that `redisCommand` are of the type `redisReply`. The\n`type` field in the `redisReply` should be used to test what kind of reply\nwas received:\n\n* **`REDIS_REPLY_STATUS`**:\n    * The command replied with a status reply. The status string can be accessed using `reply-\u003estr`.\n      The length of this string can be accessed using `reply-\u003elen`.\n\n* **`REDIS_REPLY_ERROR`**:\n    *  The command replied with an error. The error string can be accessed identical to `REDIS_REPLY_STATUS`.\n\n* **`REDIS_REPLY_INTEGER`**:\n    * The command replied with an integer. The integer value can be accessed using the\n      `reply-\u003einteger` field of type `long long`.\n\n* **`REDIS_REPLY_NIL`**:\n    * The command replied with a **nil** object. There is no data to access.\n\n* **`REDIS_REPLY_STRING`**:\n    * A bulk (string) reply. The value of the reply can be accessed using `reply-\u003estr`.\n      The length of this string can be accessed using `reply-\u003elen`.\n\n* **`REDIS_REPLY_ARRAY`**:\n    * A multi bulk reply. The number of elements in the multi bulk reply is stored in\n      `reply-\u003eelements`. Every element in the multi bulk reply is a `redisReply` object as well\n      and can be accessed via `reply-\u003eelement[..index..]`.\n      Redis may reply with nested arrays but this is fully supported.\n\nReplies should be freed using the `freeReplyObject()` function.\nNote that this function will take care of freeing sub-reply objects\ncontained in arrays and nested arrays, so there is no need for the user to\nfree the sub replies (it is actually harmful and will corrupt the memory).\n\n**Important:** the current version of hiredis (0.10.0) frees replies when the\nasynchronous API is used. This means you should not call `freeReplyObject` when\nyou use this API. The reply is cleaned up by hiredis _after_ the callback\nreturns. This behavior will probably change in future releases, so make sure to\nkeep an eye on the changelog when upgrading (see issue #39).\n\n### Cleaning up\n\nTo disconnect and free the context the following function can be used:\n```c\nvoid redisFree(redisContext *c);\n```\nThis function immediately closes the socket and then frees the allocations done in\ncreating the context.\n\n### Sending commands (cont'd)\n\nTogether with `redisCommand`, the function `redisCommandArgv` can be used to issue commands.\nIt has the following prototype:\n```c\nvoid *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);\n```\nIt takes the number of arguments `argc`, an array of strings `argv` and the lengths of the\narguments `argvlen`. For convenience, `argvlen` may be set to `NULL` and the function will\nuse `strlen(3)` on every argument to determine its length. Obviously, when any of the arguments\nneed to be binary safe, the entire array of lengths `argvlen` should be provided.\n\nThe return value has the same semantic as `redisCommand`.\n\n### Pipelining\n\nTo explain how Hiredis supports pipelining in a blocking connection, there needs to be\nunderstanding of the internal execution flow.\n\nWhen any of the functions in the `redisCommand` family is called, Hiredis first formats the\ncommand according to the Redis protocol. The formatted command is then put in the output buffer\nof the context. This output buffer is dynamic, so it can hold any number of commands.\nAfter the command is put in the output buffer, `redisGetReply` is called. This function has the\nfollowing two execution paths:\n\n1. The input buffer is non-empty:\n    * Try to parse a single reply from the input buffer and return it\n    * If no reply could be parsed, continue at *2*\n2. The input buffer is empty:\n    * Write the **entire** output buffer to the socket\n    * Read from the socket until a single reply could be parsed\n\nThe function `redisGetReply` is exported as part of the Hiredis API and can be used when a reply\nis expected on the socket. To pipeline commands, the only things that needs to be done is\nfilling up the output buffer. For this cause, two commands can be used that are identical\nto the `redisCommand` family, apart from not returning a reply:\n```c\nvoid redisAppendCommand(redisContext *c, const char *format, ...);\nvoid redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);\n```\nAfter calling either function one or more times, `redisGetReply` can be used to receive the\nsubsequent replies. The return value for this function is either `REDIS_OK` or `REDIS_ERR`, where\nthe latter means an error occurred while reading a reply. Just as with the other commands,\nthe `err` field in the context can be used to find out what the cause of this error is.\n\nThe following examples shows a simple pipeline (resulting in only a single call to `write(2)` and\na single call to `read(2)`):\n```c\nredisReply *reply;\nredisAppendCommand(context,\"SET foo bar\");\nredisAppendCommand(context,\"GET foo\");\nredisGetReply(context,\u0026reply); // reply for SET\nfreeReplyObject(reply);\nredisGetReply(context,\u0026reply); // reply for GET\nfreeReplyObject(reply);\n```\nThis API can also be used to implement a blocking subscriber:\n```c\nreply = redisCommand(context,\"SUBSCRIBE foo\");\nfreeReplyObject(reply);\nwhile(redisGetReply(context,\u0026reply) == REDIS_OK) {\n    // consume message\n    freeReplyObject(reply);\n}\n```\n### Errors\n\nWhen a function call is not successful, depending on the function either `NULL` or `REDIS_ERR` is\nreturned. The `err` field inside the context will be non-zero and set to one of the\nfollowing constants:\n\n* **`REDIS_ERR_IO`**:\n    There was an I/O error while creating the connection, trying to write\n    to the socket or read from the socket. If you included `errno.h` in your\n    application, you can use the global `errno` variable to find out what is\n    wrong.\n\n* **`REDIS_ERR_EOF`**:\n    The server closed the connection which resulted in an empty read.\n\n* **`REDIS_ERR_PROTOCOL`**:\n    There was an error while parsing the protocol.\n\n* **`REDIS_ERR_OTHER`**:\n    Any other error. Currently, it is only used when a specified hostname to connect\n    to cannot be resolved.\n\nIn every case, the `errstr` field in the context will be set to hold a string representation\nof the error.\n\n## Asynchronous API\n\nHiredis comes with an asynchronous API that works easily with any event library.\nExamples are bundled that show using Hiredis with [libev](http://software.schmorp.de/pkg/libev.html)\nand [libevent](http://monkey.org/~provos/libevent/).\n\n### Connecting\n\nThe function `redisAsyncConnect` can be used to establish a non-blocking connection to\nRedis. It returns a pointer to the newly created `redisAsyncContext` struct. The `err` field\nshould be checked after creation to see if there were errors creating the connection.\nBecause the connection that will be created is non-blocking, the kernel is not able to\ninstantly return if the specified host and port is able to accept a connection.\n\n*Note: A `redisAsyncContext` is not thread-safe.*\n\n```c\nredisAsyncContext *c = redisAsyncConnect(\"127.0.0.1\", 6379);\nif (c-\u003eerr) {\n    printf(\"Error: %s\\n\", c-\u003eerrstr);\n    // handle error\n}\n```\n\nThe asynchronous context can hold a disconnect callback function that is called when the\nconnection is disconnected (either because of an error or per user request). This function should\nhave the following prototype:\n```c\nvoid(const redisAsyncContext *c, int status);\n```\nOn a disconnect, the `status` argument is set to `REDIS_OK` when disconnection was initiated by the\nuser, or `REDIS_ERR` when the disconnection was caused by an error. When it is `REDIS_ERR`, the `err`\nfield in the context can be accessed to find out the cause of the error.\n\nThe context object is always freed after the disconnect callback fired. When a reconnect is needed,\nthe disconnect callback is a good point to do so.\n\nSetting the disconnect callback can only be done once per context. For subsequent calls it will\nreturn `REDIS_ERR`. The function to set the disconnect callback has the following prototype:\n```c\nint redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn);\n```\n### Sending commands and their callbacks\n\nIn an asynchronous context, commands are automatically pipelined due to the nature of an event loop.\nTherefore, unlike the synchronous API, there is only a single way to send commands.\nBecause commands are sent to Redis asynchronously, issuing a command requires a callback function\nthat is called when the reply is received. Reply callbacks should have the following prototype:\n```c\nvoid(redisAsyncContext *c, void *reply, void *privdata);\n```\nThe `privdata` argument can be used to curry arbitrary data to the callback from the point where\nthe command is initially queued for execution.\n\nThe functions that can be used to issue commands in an asynchronous context are:\n```c\nint redisAsyncCommand(\n  redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,\n  const char *format, ...);\nint redisAsyncCommandArgv(\n  redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,\n  int argc, const char **argv, const size_t *argvlen);\n```\nBoth functions work like their blocking counterparts. The return value is `REDIS_OK` when the command\nwas successfully added to the output buffer and `REDIS_ERR` otherwise. Example: when the connection\nis being disconnected per user-request, no new commands may be added to the output buffer and `REDIS_ERR` is\nreturned on calls to the `redisAsyncCommand` family.\n\nIf the reply for a command with a `NULL` callback is read, it is immediately freed. When the callback\nfor a command is non-`NULL`, the memory is freed immediately following the callback: the reply is only\nvalid for the duration of the callback.\n\nAll pending callbacks are called with a `NULL` reply when the context encountered an error.\n\n### Disconnecting\n\nAn asynchronous connection can be terminated using:\n```c\nvoid redisAsyncDisconnect(redisAsyncContext *ac);\n```\nWhen this function is called, the connection is **not** immediately terminated. Instead, new\ncommands are no longer accepted and the connection is only terminated when all pending commands\nhave been written to the socket, their respective replies have been read and their respective\ncallbacks have been executed. After this, the disconnection callback is executed with the\n`REDIS_OK` status and the context object is freed.\n\n### Hooking it up to event library *X*\n\nThere are a few hooks that need to be set on the context object after it is created.\nSee the `adapters/` directory for bindings to *libev* and *libevent*.\n\n## Reply parsing API\n\nHiredis comes with a reply parsing API that makes it easy for writing higher\nlevel language bindings.\n\nThe reply parsing API consists of the following functions:\n```c\nredisReader *redisReaderCreate(void);\nvoid redisReaderFree(redisReader *reader);\nint redisReaderFeed(redisReader *reader, const char *buf, size_t len);\nint redisReaderGetReply(redisReader *reader, void **reply);\n```\nThe same set of functions are used internally by hiredis when creating a\nnormal Redis context, the above API just exposes it to the user for a direct\nusage.\n\n### Usage\n\nThe function `redisReaderCreate` creates a `redisReader` structure that holds a\nbuffer with unparsed data and state for the protocol parser.\n\nIncoming data -- most likely from a socket -- can be placed in the internal\nbuffer of the `redisReader` using `redisReaderFeed`. This function will make a\ncopy of the buffer pointed to by `buf` for `len` bytes. This data is parsed\nwhen `redisReaderGetReply` is called. This function returns an integer status\nand a reply object (as described above) via `void **reply`. The returned status\ncan be either `REDIS_OK` or `REDIS_ERR`, where the latter means something went\nwrong (either a protocol error, or an out of memory error).\n\nThe parser limits the level of nesting for multi bulk payloads to 7. If the\nmulti bulk nesting level is higher than this, the parser returns an error.\n\n### Customizing replies\n\nThe function `redisReaderGetReply` creates `redisReply` and makes the function\nargument `reply` point to the created `redisReply` variable. For instance, if\nthe response of type `REDIS_REPLY_STATUS` then the `str` field of `redisReply`\nwill hold the status as a vanilla C string. However, the functions that are\nresponsible for creating instances of the `redisReply` can be customized by\nsetting the `fn` field on the `redisReader` struct. This should be done\nimmediately after creating the `redisReader`.\n\nFor example, [hiredis-rb](https://github.com/pietern/hiredis-rb/blob/master/ext/hiredis_ext/reader.c)\nuses customized reply object functions to create Ruby objects.\n\n### Reader max buffer\n\nBoth when using the Reader API directly or when using it indirectly via a\nnormal Redis context, the redisReader structure uses a buffer in order to\naccumulate data from the server.\nUsually this buffer is destroyed when it is empty and is larger than 16\nKiB in order to avoid wasting memory in unused buffers\n\nHowever when working with very big payloads destroying the buffer may slow\ndown performances considerably, so it is possible to modify the max size of\nan idle buffer changing the value of the `maxbuf` field of the reader structure\nto the desired value. The special value of 0 means that there is no maximum\nvalue for an idle buffer, so the buffer will never get freed.\n\nFor instance if you have a normal Redis context you can set the maximum idle\nbuffer to zero (unlimited) just with:\n```c\ncontext-\u003ereader-\u003emaxbuf = 0;\n```\nThis should be done only in order to maximize performances when working with\nlarge payloads. The context should be set back to `REDIS_READER_MAX_BUF` again\nas soon as possible in order to prevent allocation of useless memory.\n\n## AUTHORS\n\nHiredis was written by Salvatore Sanfilippo (antirez at gmail) and\nPieter Noordhuis (pcnoordhuis at gmail) and is released under the BSD license.  \nHiredis is currently maintained by Matt Stancliff (matt at genges dot com) and\nJan-Erik Rediger (janerik at fnordig dot com)\n","versions":[{"ref":"master","manifest":"targets = [ \"//:hiredis\" ]\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/host-core-foundation\"\nversion = \"branch=master\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/libuv\"\nversion = \"branch=v1.x\"\n","lockFile":"manifest = \"874266e7feaed3c9f86719e61bc0d2927fc5280a16cfad8ba446fdb228a80e3a\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/host-core-foundation\"\ntarget = \"//:core-foundation\"\n\n[[dependency]]\npackage = \"github.com/buckaroo-pm/libuv\"\ntarget = \"//:uv\"\n\n[lock.\"github.com/buckaroo-pm/host-core-foundation\"]\nversions = [ \"branch=master\" ]\nrevision = \"fd7081ffe1244afb86c41c2d41d3603f851feae8\"\n\n[lock.\"github.com/buckaroo-pm/libuv\"]\nversions = [ \"branch=v1.x\" ]\nrevision = \"fc3570b7a90c0daa9a091f982a75d6b54f83cf19\"\n","buck":"load('//:buckaroo_macros.bzl', 'buckaroo_deps_from_package')\n\nlibuv = buckaroo_deps_from_package('github.com/buckaroo-pm/libuv')\n\ncore_foundation = buckaroo_deps_from_package('github.com/buckaroo-pm/libuv')\n\ncxx_library(\n  name = 'hiredis',\n  header_namespace = 'hiredis',\n  exported_headers = glob([\n    'adapters/*.h',\n    '*.h',\n  ]),\n  srcs = glob([\n    '*.c',\n  ], exclude = [\n    'test.c',\n  ]),\n  platform_deps = [\n    ('linux.*', libuv),\n    ('macos.*', core_foundation),\n  ],\n  visibility = [\n    'PUBLIC',\n  ],\n)\n\ncxx_binary(\n  name = 'test',\n  srcs = [\n    'test.c',\n  ],\n  deps = [\n    ':hiredis',\n  ],\n)\n","bazel":"","deps":[{"uri":"github.com/buckaroo-pm/host-core-foundation","name":"buckaroo-pm/host-core-foundation","version":"branch=master"},{"uri":"github.com/buckaroo-pm/libuv","name":"buckaroo-pm/libuv","version":"branch=v1.x"}],"lock":[{"uri":"github.com/buckaroo-pm/host-core-foundation","name":"buckaroo-pm/host-core-foundation","spec":{"versions":["branch=master"],"revision":"fd7081ffe1244afb86c41c2d41d3603f851feae8"}},{"uri":"github.com/buckaroo-pm/libuv","name":"buckaroo-pm/libuv","spec":{"versions":["branch=v1.x"],"revision":"fc3570b7a90c0daa9a091f982a75d6b54f83cf19"}}]}],"updated":"2019-01-23T15:05:15Z","updatedUpstream":"2021-01-13T19:29:02Z","contributors":[{"login":"soveran","avatarUrl":"https://avatars3.githubusercontent.com/u/951?u=87f58114fbbfecd860ca0e9259a13e219cfb6c26\u0026v=4"},{"login":"abedra","avatarUrl":"https://avatars0.githubusercontent.com/u/2090?v=4"},{"login":"badboy","avatarUrl":"https://avatars2.githubusercontent.com/u/2129?v=4"},{"login":"djanowski","avatarUrl":"https://avatars2.githubusercontent.com/u/2268?u=f9d1ea5139c539f88a0e993b80e9d25972c3ab7f\u0026v=4"},{"login":"geoffgarside","avatarUrl":"https://avatars2.githubusercontent.com/u/2704?v=4"},{"login":"mrb","avatarUrl":"https://avatars2.githubusercontent.com/u/2878?u=3758ce762cf5988a8c62dd1c8c619cb9d5410846\u0026v=4"},{"login":"EdwardBetts","avatarUrl":"https://avatars1.githubusercontent.com/u/3818?v=4"},{"login":"amir","avatarUrl":"https://avatars2.githubusercontent.com/u/4293?u=faf1ac0070df8cea283e75cefb6081fc19b68a82\u0026v=4"},{"login":"deweerdt","avatarUrl":"https://avatars1.githubusercontent.com/u/5094?v=4"},{"login":"nicolasff","avatarUrl":"https://avatars1.githubusercontent.com/u/7276?v=4"},{"login":"pietern","avatarUrl":"https://avatars3.githubusercontent.com/u/9845?v=4"},{"login":"mattsta","avatarUrl":"https://avatars1.githubusercontent.com/u/15594?u=49ad471aa5b212c6d0508e05ce4204381545a03e\u0026v=4"},{"login":"algernon","avatarUrl":"https://avatars2.githubusercontent.com/u/17243?u=45eeefb9eb7d064598d41010d5885b7a6f100bef\u0026v=4"},{"login":"rtecco","avatarUrl":"https://avatars3.githubusercontent.com/u/21998?u=21064ee339872594db8a9069a5973b6fb5482998\u0026v=4"},{"login":"paulinohuerta","avatarUrl":"https://avatars3.githubusercontent.com/u/22158?v=4"},{"login":"nessence","avatarUrl":"https://avatars2.githubusercontent.com/u/22902?v=4"},{"login":"chergert","avatarUrl":"https://avatars2.githubusercontent.com/u/25676?v=4"},{"login":"rtyler","avatarUrl":"https://avatars0.githubusercontent.com/u/26594?v=4"},{"login":"hyjin","avatarUrl":"https://avatars3.githubusercontent.com/u/39717?v=4"},{"login":"jinq0123","avatarUrl":"https://avatars2.githubusercontent.com/u/63832?v=4"},{"login":"antirez","avatarUrl":"https://avatars0.githubusercontent.com/u/65632?v=4"},{"login":"priteau","avatarUrl":"https://avatars3.githubusercontent.com/u/68227?v=4"},{"login":"clongeau","avatarUrl":"https://avatars0.githubusercontent.com/u/68932?v=4"},{"login":"ardsrk","avatarUrl":"https://avatars1.githubusercontent.com/u/72782?v=4"},{"login":"justinbrewer","avatarUrl":"https://avatars1.githubusercontent.com/u/89644?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":4715,"forks":1532,"topics":[]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"redis-hiredis"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>