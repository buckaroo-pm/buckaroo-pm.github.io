<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a0584ae5515792e72ab5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0584ae5515792e72ab5.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ae3781fe50e43492a499.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9b549cceddc4472f1953.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" as="script"/><link rel="preload" href="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" as="script"/></head><body><div id="__next"><div class="site"><div class="navigation"><div class="view row space-between"><div class="links"><a class="buckaroo" href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="/blog">Blog</a></div><div class="search"><input placeholder="search for a module..." value=""/><button class="fa fa-search fa-large"></button></div><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></div></div><div></div><div class="banner"><div style="display:flex"><div class="package"><img src="/packages/buckaroo-pm/martinmoene-expected-lite/logo.png"/></div><div><h1>buckaroo-pm/martinmoene-expected-lite</h1><div style="max-width:600px">Expected objects for C++11 and later (and later perhaps C++98)</div><br/><div><b>155</b></div></div></div><div style="display:inline-flex;flex-flow:row wrap"><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">cpp11</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">header-only</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">single-file</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">no-dependencies</span><span class="tag" style="border-radius:5px;padding:10px;background:white;color:black;font-size:0.7em;margin:5px">expected-implementations</span></div></div><div style="display:flex;width:100%;justify-content:center;margin-top:-2.7em"><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:white;color:black;border:solid 1px #fff">ReadMe</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Buck</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Manifest</div><div class="tab-control" style="padding:0.5em;border-radius:0.2em;font-size:1.5em;background:none;color:white;border:solid 1px #fff">Dependencies</div></div><div class="banner white"><div class="view column"><h2>ReadMe</h2><h1>expected lite - expected objects for C++11 and later</h1><p><a href="https://isocpp.org/"><img src="https://img.shields.io/badge/language-C++-blue.svg" alt="Language"/></a>  <a href="https://en.wikipedia.org/wiki/C%2B%2B#Standardization"><img src="https://img.shields.io/badge/c%2B%2B-11-blue.svg" alt="Standard"/></a> <a href="https://opensource.org/licenses/BSL-1.0"><img src="https://img.shields.io/badge/license-BSL-blue.svg" alt="License"/></a> <a href="https://travis-ci.org/martinmoene/expected-lite"><img src="https://travis-ci.org/martinmoene/expected-lite.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/martinmoene/expected-lite"><img src="https://ci.appveyor.com/api/projects/status/sle31w7obrm8lhe1?svg=true" alt="Build status"/></a> <a href="https://github.com/martinmoene/expected-lite/releases"><img src="https://badge.fury.io/gh/martinmoene%2Fexpected-lite.svg" alt="Version"/></a> <a href="https://raw.githubusercontent.com/martinmoene/expected-lite/master/include/nonstd/expected.hpp"><img src="https://img.shields.io/badge/latest%20version%20%20-download-blue.svg" alt="download"/></a> <a href="https://bintray.com/martinmoene/nonstd-lite/expected-lite%3Anonstd-lite/_latestVersion"><img src="https://img.shields.io/badge/conan-download-blue.svg" alt="Conan"/></a> <a href="https://wandbox.org/permlink/bUsuVeJsKRr5Cw10"><img src="https://img.shields.io/badge/try%20it-online-blue.svg" alt="Try it online"/></a></p><p><em>expected lite</em> is a single-file header-only library for objects that either represent a valid value or an error that you can pass by value. It is intended for use with C++11 and later. The library is based on the <a href="https://github.com/viboes/std-make/blob/master/doc/proposal/expected/DXXXXR0_expected.pdf">std::expected</a> proposal [1] .</p><p><strong>Contents</strong></p><ul><li><a href="#example-usage">Example usage</a></li><li><a href="#in-a-nutshell">In a nutshell</a></li><li><a href="#license">License</a></li><li><a href="#dependencies">Dependencies</a></li><li><a href="#installation">Installation</a></li><li><a href="#synopsis">Synopsis</a></li><li><a href="#comparison">Comparison with like types</a></li><li><a href="#reported-to-work-with">Reported to work with</a></li><li><a href="#implementation-notes">Implementation notes</a></li><li><a href="#other-implementations-of-expected">Other implementations of expected</a></li><li><a href="#notes-and-references">Notes and references</a></li><li><a href="#appendix">Appendix</a></li></ul><h2>Example usage</h2><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-C++" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>#include &quot;expected.hpp&quot;
</span>
<!-- -->#include &lt;cstdlib&gt;
<!-- -->#include &lt;iostream&gt;
<!-- -->#include &lt;string&gt;
<!-- -->
<!-- -->using namespace nonstd;
<!-- -->using namespace std::literals;
<!-- -->
<!-- -->auto to_int( char const * const text ) -&gt; expected&lt;int, std::string&gt; 
<!-- -->{
<!-- -->    char * pos = nullptr;
<!-- -->    auto value = strtol( text, &amp;pos, 0 );
<!-- -->
<!-- -->    if ( pos != text ) return value;
<!-- -->    else               return make_unexpected( &quot;&#x27;&quot;s + text + &quot;&#x27; isn&#x27;t a number&quot; );
<!-- -->}
<!-- -->
<!-- -->int main( int argc, char * argv[] )
<!-- -->{
<!-- -->    auto text = argc &gt; 1 ? argv[1] : &quot;42&quot;;
<!-- -->
<!-- -->    auto ei = to_int( text );
<!-- -->
<!-- -->    if ( ei ) std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; text &lt;&lt; &quot;&#x27; is &quot; &lt;&lt; *ei &lt;&lt; &quot;, &quot;;
<!-- -->    else      std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; ei.error();
<!-- -->}
</code></pre><h3>Compile and run</h3><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>prompt&gt; g++ -std=c++14 -Wall -I../include/nonstd -o 01-basic.exe 01-basic.cpp &amp;&amp; 01-basic.exe 123 &amp;&amp; 01-basic.exe abc
</span>&#x27;123&#x27; is 123, Error: &#x27;abc&#x27; isn&#x27;t a number
</code></pre><h2>In a nutshell</h2><p><strong>expected lite</strong> is a single-file header-only library to represent value objects that either contain a valid value or an error. The library is a partly implementation of the  proposal for <a href="http://wg21.link/p0323">std::expected</a> [1,2,3] for use with C++11 and later.</p><p><strong>Some Features and properties of expected lite</strong> are ease of installation (single header), default and explicit construction of an expected, construction and assignment from a value that is convertible to the underlying type, copy- and move-construction and copy- and move-assignment from another expected of the same type, testing for the presence of a value, operators for unchecked access to the value or the error (pointer or reference), value() and value_or() for checked access to the value, relational operators, swap() and various factory functions.</p><p><em>expected lite</em> shares the approach to in-place tags with <a href="https://github.com/martinmoene/any-lite">any-lite</a>, <a href="https://github.com/martinmoene/optional-lite">optional-lite</a> and with <a href="https://github.com/martinmoene/variant-lite">variant-lite</a> and these libraries can be used together.</p><p><strong>Not provided</strong> are reference-type expecteds. <em>expected lite</em> doesn&#x27;t handle overloaded <em>address of</em> operators.</p><p>For more examples, see [1].</p><h2>License</h2><p><em>expected lite</em> is distributed under the <a href="https://github.com/martinmoene/XXXX-lite/blob/master/LICENSE.txt">Boost Software License</a>.</p><h2>Dependencies</h2><p><em>expected lite</em> has no other dependencies than the <a href="http://en.cppreference.com/w/cpp/header">C++ standard library</a>.</p><h2>Installation</h2><p><em>expected lite</em> is a single-file header-only library. Put <code>expected.hpp</code> directly into the project source tree or somewhere reachable from your project.</p><h2>Synopsis</h2><p><strong>Contents</strong></p><ul><li><a href="#configuration-macros">Configuration macros</a></li><li><a href="#types-in-namespace-nonstd">Types in namespace nonstd</a></li><li><a href="#interface-of-expected">Interface of expected</a></li><li><a href="#algorithms-for-expected">Algorithms for expected</a></li><li><a href="#interface-of-unexpected_type">Interface of unexpected_type</a></li><li><a href="#algorithms-for-unexpected_type">Algorithms for unexpected_type</a></li></ul><h3>Configuration macros</h3><p>-D<!-- -->&lt;b&gt;<!-- -->nsel_CONFIG_CONFIRMS_COMPILATION_ERRORS<!-- -->&lt;/b&gt;<!-- -->=0<br/>Define this macro to 1 to experience the by-design compile-time errors of the library in the test suite. Default is 0.</p><h3>Types in namespace nonstd</h3><table><thead><tr><th>Purpose</th><th>Type</th><th>Object</th></tr></thead><tbody><tr><td>To be, or not</td><td>template&lt; typename T, typename E = std::exception_ptr &gt;<!-- -->&lt;br&gt;<!-- -->class <strong>expected</strong>;</td><td> </td></tr><tr><td>Error type</td><td>template&lt; typename E &gt;<!-- -->&lt;br&gt;<!-- -->class <strong>unexpected_type</strong>;</td><td> </td></tr><tr><td>Traits</td><td>template&lt; typename E &gt;<!-- -->&lt;br&gt;<!-- -->struct <strong>is_unexpected</strong>;</td><td> </td></tr><tr><td>In-place value construction</td><td>struct <strong>in_place_t</strong>;</td><td>in_place_t in_place{};</td></tr><tr><td>In-place error construction</td><td>struct <strong>in_place_unexpected_t</strong>;</td><td>in_place_unexpected_t<!-- -->&lt;br&gt;<!-- -->unexpect{};</td></tr><tr><td>In-place error construction</td><td>struct <strong>in_place_unexpected_t</strong>;</td><td>in_place_unexpected_t<!-- -->&lt;br&gt;<!-- -->in_place_unexpected{};</td></tr><tr><td>Error reporting</td><td>class <strong>bad_expected_access</strong>;</td><td> </td></tr></tbody></table><h3>Interface of expected</h3><table><thead><tr><th>Kind</th><th>Method</th><th>Result</th></tr></thead><tbody><tr><td>Construction</td><td>[constexpr] <strong>expected</strong>() noexcept(...)</td><td>an object with default value</td></tr><tr><td> </td><td>[constexpr] <strong>expected</strong>( expected const &amp; other )</td><td>initialize to contents of other</td></tr><tr><td> </td><td>[constexpr] <strong>expected</strong>( expected &amp;&amp; other )</td><td>move contents from other</td></tr><tr><td> </td><td>[constexpr] <strong>expected</strong>( value_type const &amp; value )</td><td>initialize to value</td></tr><tr><td> </td><td>[constexpr] <strong>expected</strong>( value_type &amp;&amp; value ) noexcept(...)</td><td>move from value</td></tr><tr><td> </td><td>[constexpr] explicit <strong>expected</strong>( in_place_t, Args&amp;&amp;... args )</td><td>construct value in-place from args</td></tr><tr><td> </td><td>[constexpr] explicit <strong>expected</strong>( in_place_t,<!-- -->&lt;br&gt;<!-- --> std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args )</td><td>construct value in-place from args</td></tr><tr><td> </td><td>[constexpr] <strong>expected</strong>( unexpected_type<!-- -->&lt;E&gt;<!-- --> const &amp; error )</td><td>initialize to error</td></tr><tr><td> </td><td>[constexpr] <strong>expected</strong>( unexpected_type<!-- -->&lt;E&gt;<!-- --> &amp;&amp; error )</td><td>move from error</td></tr><tr><td> </td><td>[constexpr] explicit <strong>expected</strong>( in_place_unexpected_t,<!-- -->&lt;br&gt;<!-- --> Args&amp;&amp;... args )</td><td>construct error in-place from args</td></tr><tr><td> </td><td>[constexpr] explicit <strong>expected</strong>( in_place_unexpected_t,<!-- -->&lt;br&gt;<!-- --> std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args )</td><td>construct error in-place from args</td></tr><tr><td>Destruction</td><td>~<strong>expected</strong>()</td><td>destruct current content</td></tr><tr><td>Assignment</td><td>expected <strong>operator=</strong>( expected const &amp; other )</td><td>assign contents of other;<!-- -->&lt;br&gt;<!-- -->destruct current content, if any</td></tr><tr><td> </td><td>expected &amp; <strong>operator=</strong>( expected &amp;&amp; other ) noexcept(...)</td><td>move contents of other</td></tr><tr><td> </td><td>expected &amp; <strong>operator=</strong>( U &amp;&amp; v )</td><td>move value from v</td></tr><tr><td> </td><td>expected &amp; <strong>operator=</strong>( unexpected_type<!-- -->&lt;E&gt;<!-- --> const &amp; u )</td><td>initialize to unexpected</td></tr><tr><td> </td><td>expected &amp; <strong>operator=</strong>( unexpected_type<!-- -->&lt;E&gt;<!-- --> &amp;&amp; u )</td><td>move from unexpected</td></tr><tr><td> </td><td>template&lt; typename... Args &gt;<!-- -->&lt;br&gt;<!-- -->void <strong>emplace</strong>( Args &amp;&amp;... args )</td><td>emplace from args</td></tr><tr><td> </td><td>template&lt; typename U, typename... Args &gt;<!-- -->&lt;br&gt;<!-- -->void <strong>emplace</strong>( std::initializer_list&lt;U&gt; il, Args &amp;&amp;... args )</td><td>emplace from args</td></tr><tr><td>Swap</td><td>void <strong>swap</strong>( expected &amp; other ) noexcept</td><td>swap with other</td></tr><tr><td>Observers</td><td>constexpr value_type const * <strong>operator-&gt;</strong>() const</td><td>pointer to current content (const);<!-- -->&lt;br&gt;<!-- -->must contain value</td></tr><tr><td> </td><td>value_type * <strong>operator-&gt;</strong>()</td><td>pointer to current content (non-const);<!-- -->&lt;br&gt;<!-- -->must contain value</td></tr><tr><td> </td><td>constexpr value_type const &amp; <strong>operator *</strong>() const &amp;</td><td>the current content (const ref);<!-- -->&lt;br&gt;<!-- -->must contain value</td></tr><tr><td> </td><td>constexpr value_type &amp;&amp; <strong>operator *</strong>() &amp;&amp;</td><td>the current content (non-const ref);<!-- -->&lt;br&gt;<!-- -->must contain value</td></tr><tr><td> </td><td>constexpr explicit operator <strong>bool</strong>() const noexcept</td><td>true if contains value</td></tr><tr><td> </td><td>constexpr <strong>has_value</strong>() const noexcept</td><td>true if contains value</td></tr><tr><td> </td><td>constexpr value_type const &amp; <strong>value</strong>() const &amp;</td><td>current content (const ref);<!-- -->&lt;br&gt;<!-- -->see <a href="#note1">note 1</a></td></tr><tr><td> </td><td>value_type &amp; <strong>value</strong>() &amp;</td><td>current content (non-const ref);<!-- -->&lt;br&gt;<!-- -->see <a href="#note1">note 1</a></td></tr><tr><td> </td><td>constexpr value_type &amp;&amp; <strong>value</strong>() &amp;&amp;</td><td>move from current content;<!-- -->&lt;br&gt;<!-- -->see <a href="#note1">note 1</a></td></tr><tr><td> </td><td>constexpr error_type const &amp; <strong>error</strong>() const &amp;</td><td>current error (const ref);<!-- -->&lt;br&gt;<!-- -->must contain error</td></tr><tr><td> </td><td>error_type &amp; <strong>error</strong>() &amp;</td><td>current error (non-const ref);<!-- -->&lt;br&gt;<!-- -->must contain error</td></tr><tr><td> </td><td>constexpr error_type &amp;&amp; <strong>error</strong>() &amp;&amp;</td><td>move from current error;<!-- -->&lt;br&gt;<!-- -->must contain error</td></tr><tr><td> </td><td>constexpr unexpected_type<!-- -->&lt;E&gt;<!-- --> <strong>get_unexpected</strong>() const</td><td>the error as unexpected&lt;&gt;;<!-- -->&lt;br&gt;<!-- -->must contain error</td></tr><tr><td> </td><td>template&lt; typename Ex &gt;<!-- -->&lt;br&gt;<!-- -->bool <strong>has_exception</strong>() const</td><td>true of contains exception (as base)</td></tr><tr><td> </td><td>value_type <strong>value_or</strong>( U &amp;&amp; v ) const &amp;</td><td>value or move from v</td></tr><tr><td> </td><td>value_type <strong>value_or</strong>( U &amp;&amp; v ) &amp;&amp;</td><td>move from value or move from v</td></tr><tr><td> </td><td>...</td><td> </td></tr></tbody></table><p>&lt;a id=&quot;note1&quot;&gt;<!-- -->&lt;/a&gt;<!-- -->Note 1: checked access: if no content, for std::exception_ptr rethrows error(), otherwise throws bad_expected_access(error()).</p><h3>Algorithms for expected</h3><table><thead><tr><th>Kind</th><th>Function</th></tr></thead><tbody><tr><td>Relational operators</td><td> </td><td></td></tr><tr><td>== != &lt; &gt; &lt;= &gt;=</td><td>template&lt; typename T, typename E &gt;<!-- -->&lt;br&gt;<!-- -->constexpr bool operator <em><strong>op</strong></em>(<!-- -->&lt;br&gt;<!-- --> expected&lt;T,E&gt; const &amp; x,<!-- -->&lt;br&gt;<!-- --> expected&lt;T,E&gt; const &amp; y )</td></tr><tr><td>Comparison with unexpected_type</td><td> </td><td></td></tr><tr><td>== != &lt; &gt; &lt;= &gt;=</td><td>template&lt; typename T, typename E &gt;<!-- -->&lt;br&gt;<!-- -->constexpr bool operator <em><strong>op</strong></em>(<!-- -->&lt;br&gt;<!-- --> expected&lt;T,E&gt; const &amp; x,<!-- -->&lt;br&gt;<!-- --> unexpected_type&lt;E&gt; const &amp; u )</td><td></td></tr><tr><td> </td><td>template&lt; typename T, typename E &gt;<!-- -->&lt;br&gt;<!-- -->constexpr bool operator <em><strong>op</strong></em>(<!-- -->&lt;br&gt;<!-- --> unexpected_type&lt;E&gt; const &amp; u,<!-- -->&lt;br&gt;<!-- --> expected&lt;T,E&gt; const &amp; x )</td><td></td></tr><tr><td>Comparison with T</td><td> </td><td></td></tr><tr><td>== != &lt; &gt; &lt;= &gt;=</td><td>template&lt; typename T, typename E &gt;<!-- -->&lt;br&gt;<!-- -->constexpr bool operator <em><strong>op</strong></em>(<!-- -->&lt;br&gt;<!-- --> expected&lt;T,E&gt; const &amp; x,<!-- -->&lt;br&gt;<!-- --> T const &amp; v )</td><td></td></tr><tr><td> </td><td>template&lt; typename T, typename E &gt;<!-- -->&lt;br&gt;<!-- -->constexpr bool operator <em><strong>op</strong></em>(<!-- -->&lt;br&gt;<!-- --> T const &amp; v,<!-- -->&lt;br&gt;<!-- --> expected&lt;T,E&gt; const &amp; x )</td><td></td></tr><tr><td>Specialized algorithms</td><td> </td><td></td></tr><tr><td>Swap</td><td>template&lt; typename T, typename E &gt;<!-- -->&lt;br&gt;<!-- -->void <strong>swap</strong>(<!-- -->&lt;br&gt;<!-- --> expected&lt;T,E&gt; &amp; x,<!-- -->&lt;br&gt;<!-- --> expected&lt;T,E&gt; &amp; y ) noexcept( noexcept( x.swap(y) ) )</td><td></td></tr><tr><td>Make expected from</td><td> </td><td></td></tr><tr><td> Value</td><td>template&lt; typename T&gt;<!-- -->&lt;br&gt;<!-- -->constexpr auto <strong>make_expected</strong>( T &amp;&amp; v ) -&gt;<!-- -->&lt;br&gt;<!-- --> expected&lt; typename std::decay&lt;T&gt;::type &gt;</td><td></td></tr><tr><td> Nothing</td><td>auto <strong>make_expected</strong>() -&gt; expected&lt;void&gt;</td><td></td></tr><tr><td> Current exception</td><td>template&lt; typename T&gt;<!-- -->&lt;br&gt;<!-- -->constexpr auto <strong>make_expected_from_current_exception</strong>() -&gt; expected&lt;T&gt;</td><td></td></tr><tr><td> Exception</td><td>template&lt; typename T&gt;<!-- -->&lt;br&gt;<!-- -->auto <strong>make_expected_from_exception</strong>( std::exception_ptr v ) -&gt; expected&lt;T&gt;</td><td></td></tr><tr><td> Error</td><td>template&lt; typename T, typename E &gt;<!-- -->&lt;br&gt;<!-- -->constexpr auto <strong>make_expected_from_error</strong>( E e ) -&gt;<!-- -->&lt;br&gt;<!-- --> expected&lt;T, typename std::decay&lt;E&gt;::type&gt;</td><td></td></tr><tr><td> Call</td><td>template&lt; typename F &gt;<!-- -->&lt;br&gt;<!-- -->auto <strong>make_expected_from_call</strong>( F f ) -&gt;<!-- -->&lt;br&gt;<!-- --> expected&lt; typename std::result_of&lt;F()&gt;::type &gt;</td><td></td></tr><tr><td> Call, void specialization</td><td>template&lt; typename F &gt;<!-- -->&lt;br&gt;<!-- -->auto <strong>make_expected_from_call</strong>( F f ) -&gt; expected&lt;void&gt;</td><td></td></tr></tbody></table><h3>Interface of unexpected_type</h3><table><thead><tr><th>Kind</th><th>Method</th><th>Result</th></tr></thead><tbody><tr><td>Construction</td><td><strong>unexpected_type</strong>() = delete;</td><td>no default construction</td></tr><tr><td> </td><td>constexpr explicit <strong>unexpected_type</strong>( E const &amp; error )</td><td>copy-constructed from an E</td></tr><tr><td> </td><td>constexpr explicit <strong>unexpected_type</strong>( E &amp;&amp; error )</td><td>move-constructed from an E</td></tr><tr><td>Observers</td><td>constexpr error_type const &amp; <strong>value</strong>() const</td><td>can observe contained error</td></tr><tr><td> </td><td>error_type &amp; <strong>value</strong>()</td><td>can modify contained error</td></tr></tbody></table><h3>Algorithms for unexpected_type</h3><table><thead><tr><th>Kind</th><th>Function</th></tr></thead><tbody><tr><td>Relational operators</td><td> </td><td></td></tr><tr><td>== != &lt; &gt; &lt;= &gt;=</td><td>template&lt; typename E &gt;<!-- -->&lt;br&gt;<!-- -->constexpr bool operator <em><strong>op</strong></em>(<!-- -->&lt;br&gt;<!-- --> unexpected_type&lt;E&gt; const &amp; x,<!-- -->&lt;br&gt;<!-- --> unexpected_type&lt;E&gt; const &amp; y )</td></tr><tr><td>== != &lt; &gt; &lt;= &gt;=</td><td>constexpr bool operator <em><strong>op</strong></em>(<!-- -->&lt;br&gt;<!-- --> unexpected_type&lt;std::exception_ptr&gt; const &amp; x,<!-- -->&lt;br&gt;<!-- --> unexpected_type&lt;std::exception_ptr&gt; const &amp; y )</td></tr><tr><td>Specialized algorithms</td><td> </td><td></td></tr><tr><td>Make unexpected from</td><td> </td><td></td></tr><tr><td> Current exception</td><td>[constexpr] auto <strong>make_unexpected_from_current_exception</strong>() -&gt;<!-- -->&lt;br&gt;<!-- --> unexpected_type&lt; std::exception_ptr &gt;</td><td></td></tr><tr><td> Error</td><td>template&lt; typename E&gt;<!-- -->&lt;br&gt;<!-- -->[constexpr] auto <strong>make_unexpected</strong>( E &amp;&amp; v) -&gt;<!-- -->&lt;br&gt;<!-- --> unexpected_type&lt; typename std::decay&lt;E&gt;::type &gt;</td><td></td></tr></tbody></table><h2>&lt;a id=&quot;comparison&quot;&gt;<!-- -->&lt;/a&gt;<!-- -->
Comparison with like types</h2><table><thead><tr><th>Feature</th><th>&lt;br&gt;<!-- -->std::pair</th><th>std:: optional</th><th>std:: expected</th><th>nonstd:: expected</th><th>Boost. Expected</th><th>Nonco expected</th><th>Andrei Expected</th><th>Hagan required</th></tr></thead><tbody><tr><td>More information</td><td>see [14]</td><td>see [5]</td><td>see [1]</td><td>this work</td><td>see [4]</td><td>see [7]</td><td>see [8]</td><td>see [13]</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>C++03</td><td>yes</td><td>no</td><td>no</td><td>no/not yet</td><td>no (union)</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>C++11</td><td>yes</td><td>no</td><td>no</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>C++14</td><td>yes</td><td>no</td><td>no</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>C++17</td><td>yes</td><td>yes</td><td>no</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>DefaultConstructible</td><td>T param</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>In-place construction</td><td>no</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>Literal type</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Disengaged information</td><td>possible</td><td>no</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>Vary disengaged type</td><td>yes</td><td>no</td><td>yes</td><td>yes</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>Engaged nonuse throws</td><td>no</td><td>no</td><td>no</td><td>no</td><td>error_traits</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>Disengaged use throws</td><td>no</td><td>yes, value()</td><td>yes, value()</td><td>yes, value()</td><td>yes,<!-- -->&lt;br&gt;<!-- -->value()</td><td>yes,<!-- -->&lt;br&gt;<!-- -->get()</td><td>yes,<!-- -->&lt;br&gt;<!-- -->get()</td><td>n/a</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Proxy (rel.ops)</td><td>no</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>References</td><td>no</td><td>yes</td><td>no/not yet</td><td>no/not yet</td><td>no/not yet</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>Chained visitor(s)</td><td>no</td><td>no</td><td>yes</td><td>maybe</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr></tbody></table><p>Note 1: std::<em>experimental</em>::expected</p><p>Note 2: sources for <a href="https://github.com/martinmoene/spike-expected/tree/master/nonco">Nonco expected</a>, <a href="https://github.com/martinmoene/spike-expected/tree/master/alexandrescu">Andrei Expected</a> and <a href="https://github.com/martinmoene/spike-expected/tree/master/hagan">Hagan required</a> can befound in the <a href="https://github.com/martinmoene/spike-expected">spike-expected</a> repository.</p><h2>Reported to work with</h2><h2>Implementation notes</h2><h2>Other implementations of expected</h2><ul><li>Simon Brand. <a href="https://github.com/TartanLlama/expected">C++11/14/17 std::expected with functional-style extensions</a>. Single-header.</li><li>Isabella Muerte. <a href="https://github.com/mnmlstc/core">MNMLSTC Core</a> (C++11).</li><li>Vicente J. Botet Escriba. <a href="https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/expected">stdmake&#x27;s expected</a> (C++17).</li><li>Facebook. <a href="https://github.com/facebook/folly/blob/master/folly/Expected.h"> Folly&#x27;s Expected.h</a> (C++14).</li></ul><h2>Notes and references</h2><p>[1] Vicente J. Botet Escriba. <a href="http://wg21.link/p0323">p0323 - A proposal to add a utility class to represent expected object (latest)</a> (HTML). (<a href="http://wg21.link/p0323r6">r6</a>, <a href="http://wg21.link/p0323r5">r5</a>, <a href="http://wg21.link/p0323r4">r4</a>, <a href="http://wg21.link/p0323r3">r3</a>, <a href="http://wg21.link/p0323r2">r2</a>, <a href="http://wg21.link/n4109">r1</a>, <a href="http://wg21.link/n4015">r0</a>, <a href="https://github.com/viboes/std-make/blob/master/doc/proposal/expected/DXXXXR0_expected.pdf">draft</a>).</p><p>[2] Vicente J. Botet Escriba. <a href="https://github.com/viboes/std-make">JASEL: Just a simple experimental library for C++</a>. Reference implementation of <a href="https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/expected">expected</a>.</p><p>[3] Vicente J. Botet Escriba. <a href="https://www.youtube.com/watch?v=Zdlt1rgYdMQ">Expected - An exception-friendly Error Monad</a>. C++Now 2014. 24 September 2014.</p><p>[4] Pierre Talbot. <a href="http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/trademark/25002">Boost.Expected. Unofficial Boost candidate</a>. 5 May 2013. <a href="https://github.com/TrademarkPewPew/Boost.Expected">GitHub</a>, <a href="http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/trademark/25002">GSoC 2013 Proposal</a>, <a href="http://permalink.gmane.org/gmane.comp.lib.boost.devel/240056">boost@lists.boost.org</a>.</p><p>[5] Fernando Cacciola and Andrzej Krzemieński. <a href="http://isocpp.org/files/papers/N3672.html">A proposal to add a utility class to represent optional objects (Revision 4)</a>. ISO/IEC JTC1 SC22 WG21 N3672 2013-04-19.</p><p>[6] Andrzej Krzemieński, <a href="https://github.com/akrzemi1/Optional/">Optional library implementation in C++11</a>.</p><p>[7] Anto Nonco. <a href="http://anto-nonco.blogspot.nl/2013/03/extending-expected-to-deal-with.html">Extending expected<!-- -->&lt;T&gt;<!-- --> to deal with references</a>. 27 May 2013.</p><p>[8] Andrei Alexandrescu. Systematic Error Handling in C++. Prepared for The C++and Beyond Seminar 2012. <a href="http://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2012-Andrei-Alexandrescu-Systematic-Error-Handling-in-C">Video</a>. <a href="http://sdrv.ms/RXjNPR">Slides</a>.</p><p>[9] Andrei Alexandrescu. <a href="http://accu.org/content/conf2007/Alexandrescu-Choose_Your_Poison.pdf">Choose your Poison: Exceptions or Error Codes? (PDF)</a>. ACCU Conference 2007.</p><p>[10] Andrei Alexandrescu. <a href="http://nwcpp.org/static/talks/2006/The_Power_of_None.ppt">The Power of None (PPT)</a>. Northwest C++ Users&#x27; Group. <a href="http://nwcpp.org/may-2006.html">May 17th, 2006</a>.</p><p>[11] Jon Jagger. <a href="http://accu.org/var/uploads/journals/overload53-FINAL.pdf#page=18">A Return Type That Doesn&#x27;t Like Being Ignored</a>. Overload issue 53, February 2003.</p><p>[12] Andrei Alexandrescu. <a href="http://accu.org/index.php/conferences/2002/speakers2002">Error Handling in C++: Are we inching towards a total solution?</a>. ACCU Conference 2002.</p><p>[13] Ken Hagan et al. <a href="https://groups.google.com/d/msg/comp.lang.c++.moderated/BkZqPfoq3ys/H_PMR8Sat4oJ">Exploding return codes</a>. comp.lang.c++.moderated. 11 February 2000.</p><p>[14] <a href="http://en.cppreference.com/w/cpp/utility/pair">std::pair</a>. cppreference.com</p><p>[15] Niall Douglas. <a href="https://ned14.github.io/outcome/">Outcome</a>. Very lightweight outcome&lt;T&gt; and result&lt;T&gt; (non-Boost edition).</p><h2>Appendix</h2><h3>A.1 expected lite test specification</h3><pre style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>unexpected_type&lt;&gt;: Disallows default construction
</span>unexpected_type&lt;&gt;: Disallows default construction, std::exception_ptr specialization
<!-- -->unexpected_type&lt;&gt;: Allows to copy-construct from error_type
<!-- -->unexpected_type&lt;&gt;: Allows to copy-construct from error_type, std::exception_ptr specialization
<!-- -->unexpected_type&lt;&gt;: Allows to move-construct from error_type
<!-- -->unexpected_type&lt;&gt;: Allows to move-construct from error_type, std::exception_ptr specialization
<!-- -->unexpected_type&lt;&gt;: Allows to copy-construct from an exception, std::exception_ptr specialization
<!-- -->unexpected_type&lt;&gt;: Allows to observe its value
<!-- -->unexpected_type&lt;&gt;: Allows to observe its value, std::exception_ptr specialization
<!-- -->unexpected_type&lt;&gt;: Allows to modify its value
<!-- -->unexpected_type&lt;&gt;: Allows to modify its value, std::exception_ptr specialization
<!-- -->unexpected_type&lt;&gt;: Provides relational operators
<!-- -->unexpected_type&lt;&gt;: Provides relational operators, std::exception_ptr specialization
<!-- -->make_unexpected(): Allows to create an unexpected_type&lt;E&gt; from an E
<!-- -->unexpected&lt;&gt;: C++17 and later provide unexpected_type as unexpected
<!-- -->bad_expected_access&lt;&gt;: Disallows default construction
<!-- -->bad_expected_access&lt;&gt;: Allows construction from error_type
<!-- -->bad_expected_access&lt;&gt;: Allows to observe its error
<!-- -->bad_expected_access&lt;&gt;: Allows to change its error
<!-- -->expected&lt;&gt;: Allows default construction
<!-- -->expected&lt;&gt;: Allows to copy-construct from value_type
<!-- -->expected&lt;&gt;: Allows to move-construct from value_type
<!-- -->expected&lt;&gt;: Allows to copy-construct from expected&lt;&gt;
<!-- -->expected&lt;&gt;: Allows to move-construct from expected&lt;&gt;
<!-- -->expected&lt;&gt;: Allows to in-place-construct value_type
<!-- -->expected&lt;&gt;: Allows to copy-construct from unexpected_type&lt;&gt;
<!-- -->expected&lt;&gt;: Allows to move-construct from unexpected_type&lt;&gt;
<!-- -->expected&lt;&gt;: Allows to in-place-construct unexpected_type&lt;&gt;
<!-- -->expected&lt;&gt;: Allows to copy-assign from expected&lt;&gt;
<!-- -->expected&lt;&gt;: Allows to move-assign from expected&lt;&gt;
<!-- -->expected&lt;&gt;: Allows to copy-assign from type convertible to value_type
<!-- -->expected&lt;&gt;: Allows to move-assign from type convertible to value_type
<!-- -->expected&lt;&gt;: Allows to be swapped
<!-- -->expected&lt;&gt;: Allows to observe its value via a pointer
<!-- -->expected&lt;&gt;: Allows to observe its value via a pointer to constant
<!-- -->expected&lt;&gt;: Allows to modify its value via a pointer
<!-- -->expected&lt;&gt;: Allows to observe its value via a reference
<!-- -->expected&lt;&gt;: Allows to observe its value via a r-value reference
<!-- -->expected&lt;&gt;: Allows to modify its value via a reference
<!-- -->expected&lt;&gt;: Allows to observe if it contains a value (or error)
<!-- -->expected&lt;&gt;: Allows to observe its value
<!-- -->expected&lt;&gt;: Allows to modify its value
<!-- -->expected&lt;&gt;: Allows to move its value
<!-- -->expected&lt;&gt;: Allows to observe its error
<!-- -->expected&lt;&gt;: Allows to modify its error
<!-- -->expected&lt;&gt;: Allows to move its error
<!-- -->expected&lt;&gt;: Allows to observe its error as unexpected&lt;&gt;
<!-- -->expected&lt;&gt;: Allows to observe its value if available, or obtain a specified value otherwise
<!-- -->expected&lt;&gt;: Allows to move its value if available, or obtain a specified value otherwise
<!-- -->expected&lt;void&gt;: Allows to default-construct
<!-- -->expected&lt;void&gt;: Allows to copy-construct from expected&lt;void&gt;
<!-- -->expected&lt;void&gt;: Allows to move-construct from expected&lt;void&gt;
<!-- -->expected&lt;void&gt;: Allows to in-place-construct
<!-- -->expected&lt;void&gt;: Allows to copy-construct from unexpected_type&lt;&gt;
<!-- -->expected&lt;void&gt;: Allows to move-construct from unexpected_type&lt;&gt;
<!-- -->expected&lt;void&gt;: Allows to in-place-construct unexpected_type&lt;&gt;
<!-- -->expected&lt;void&gt;: Allows to copy-assign from expected&lt;&gt;
<!-- -->expected&lt;void&gt;: Allows to move-assign from expected&lt;&gt;
<!-- -->expected&lt;void&gt;: Allows to be swapped
<!-- -->expected&lt;void&gt;: Allows to observe if it contains a value (or error)
<!-- -->expected&lt;void&gt;: Allows to observe its error
<!-- -->expected&lt;void&gt;: Allows to modify its error
<!-- -->expected&lt;void&gt;: Allows to move its error
<!-- -->expected&lt;void&gt;: Allows to observe its error as unexpected&lt;&gt;
<!-- -->operator op: Provides relational operators
</code></pre></div></div><div class="banner footer"><div class="view column"><div class="actions"><div class="links"><a href="/">Buckaroo</a><a href="https://github.com/LoopPerfect/buckaroo/wiki" target="_blank">Docs</a><a href="https://github.com/LoopPerfect/buckaroo" target="_blank">GitHub</a></div><div class="signup"><h1 class="action">Sign up for our Newsletter</h1><div class="info">Get the latest updates about new packages and Buckaroo releases.</div><button>Sign Up</button></div></div><div class="powered"><img src="/LoopPerfectInvertSmall.png"/><span>Powered by LoopPerfect</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"packageName":"buckaroo-pm/martinmoene-expected-lite","name":"martinmoene/expected-lite","licence":"BSL-1.0","description":"Expected objects for C++11 and later (and later perhaps C++98)","readme":"expected lite - expected objects for C++11 and later\n====================================================\n[![Language](https://img.shields.io/badge/language-C++-blue.svg)](https://isocpp.org/)  [![Standard](https://img.shields.io/badge/c%2B%2B-11-blue.svg)](https://en.wikipedia.org/wiki/C%2B%2B#Standardization) [![License](https://img.shields.io/badge/license-BSL-blue.svg)](https://opensource.org/licenses/BSL-1.0) [![Build Status](https://travis-ci.org/martinmoene/expected-lite.svg?branch=master)](https://travis-ci.org/martinmoene/expected-lite) [![Build status](https://ci.appveyor.com/api/projects/status/sle31w7obrm8lhe1?svg=true)](https://ci.appveyor.com/project/martinmoene/expected-lite) [![Version](https://badge.fury.io/gh/martinmoene%2Fexpected-lite.svg)](https://github.com/martinmoene/expected-lite/releases) [![download](https://img.shields.io/badge/latest%20version%20%20-download-blue.svg)](https://raw.githubusercontent.com/martinmoene/expected-lite/master/include/nonstd/expected.hpp) [![Conan](https://img.shields.io/badge/conan-download-blue.svg)](https://bintray.com/martinmoene/nonstd-lite/expected-lite%3Anonstd-lite/_latestVersion) [![Try it online](https://img.shields.io/badge/try%20it-online-blue.svg)](https://wandbox.org/permlink/bUsuVeJsKRr5Cw10)\n\n*expected lite* is a single-file header-only library for objects that either represent a valid value or an error that you can pass by value. It is intended for use with C++11 and later. The library is based on the [std:\u0026#58;expected](https://github.com/viboes/std-make/blob/master/doc/proposal/expected/DXXXXR0_expected.pdf) proposal [1] .\n\n**Contents**  \n- [Example usage](#example-usage)\n- [In a nutshell](#in-a-nutshell)\n- [License](#license)\n- [Dependencies](#dependencies)\n- [Installation](#installation)\n- [Synopsis](#synopsis)\n- [Comparison with like types](#comparison)\n- [Reported to work with](#reported-to-work-with)\n- [Implementation notes](#implementation-notes)\n- [Other implementations of expected](#other-implementations-of-expected)\n- [Notes and references](#notes-and-references)\n- [Appendix](#appendix)\n\n\nExample usage\n-------------\n```C++\n#include \"expected.hpp\"\n\n#include \u003ccstdlib\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nusing namespace nonstd;\nusing namespace std::literals;\n\nauto to_int( char const * const text ) -\u003e expected\u003cint, std::string\u003e \n{\n    char * pos = nullptr;\n    auto value = strtol( text, \u0026pos, 0 );\n\n    if ( pos != text ) return value;\n    else               return make_unexpected( \"'\"s + text + \"' isn't a number\" );\n}\n\nint main( int argc, char * argv[] )\n{\n    auto text = argc \u003e 1 ? argv[1] : \"42\";\n\n    auto ei = to_int( text );\n\n    if ( ei ) std::cout \u003c\u003c \"'\" \u003c\u003c text \u003c\u003c \"' is \" \u003c\u003c *ei \u003c\u003c \", \";\n    else      std::cout \u003c\u003c \"Error: \" \u003c\u003c ei.error();\n}\n```\n### Compile and run\n```\nprompt\u003e g++ -std=c++14 -Wall -I../include/nonstd -o 01-basic.exe 01-basic.cpp \u0026\u0026 01-basic.exe 123 \u0026\u0026 01-basic.exe abc\n'123' is 123, Error: 'abc' isn't a number\n```\n\nIn a nutshell\n-------------\n**expected lite** is a single-file header-only library to represent value objects that either contain a valid value or an error. The library is a partly implementation of the  proposal for [std:\u0026#58;expected](http://wg21.link/p0323) [1,2,3] for use with C++11 and later.\n\n**Some Features and properties of expected lite** are ease of installation (single header), default and explicit construction of an expected, construction and assignment from a value that is convertible to the underlying type, copy- and move-construction and copy- and move-assignment from another expected of the same type, testing for the presence of a value, operators for unchecked access to the value or the error (pointer or reference), value() and value_or() for checked access to the value, relational operators, swap() and various factory functions.\n\n*expected lite* shares the approach to in-place tags with [any-lite](https://github.com/martinmoene/any-lite), [optional-lite](https://github.com/martinmoene/optional-lite) and with [variant-lite](https://github.com/martinmoene/variant-lite) and these libraries can be used together.\n\n**Not provided** are reference-type expecteds. *expected lite* doesn't handle overloaded *address of* operators.\n\nFor more examples, see [1].\n\n\nLicense\n-------\n*expected lite* is distributed under the [Boost Software License](https://github.com/martinmoene/XXXX-lite/blob/master/LICENSE.txt).\n\n\nDependencies\n------------\n*expected lite* has no other dependencies than the [C++ standard library](http://en.cppreference.com/w/cpp/header).\n\n\nInstallation\n------------\n\n*expected lite* is a single-file header-only library. Put `expected.hpp` directly into the project source tree or somewhere reachable from your project.\n\n\nSynopsis\n--------\n\n**Contents**  \n- [Configuration macros](#configuration-macros)\n- [Types in namespace nonstd](#types-in-namespace-nonstd)  \n- [Interface of expected](#interface-of-expected)  \n- [Algorithms for expected](#algorithms-for-expected)  \n- [Interface of unexpected_type](#interface-of-unexpected_type)  \n- [Algorithms for unexpected_type](#algorithms-for-unexpected_type)  \n\n### Configuration macros\n\n\\-D\u003cb\u003ensel\\_CONFIG\\_CONFIRMS\\_COMPILATION\\_ERRORS\u003c/b\u003e=0  \nDefine this macro to 1 to experience the by-design compile-time errors of the library in the test suite. Default is 0.\n\n### Types in namespace nonstd\n\n| Purpose         | Type | Object |\n|-----------------|------|--------|\n| To be, or not   | template\u003c typename T, typename E = std::exception_ptr \u003e\u003cbr\u003eclass **expected**; |\u0026nbsp;|\n| Error type      | template\u003c typename E \u003e\u003cbr\u003eclass **unexpected_type**; | \u0026nbsp; |\n| Traits          | template\u003c typename E \u003e\u003cbr\u003estruct **is_unexpected**;  | \u0026nbsp; |\n| In-place value construction | struct **in_place_t**;            | in_place_t in_place{}; |\n| In-place error construction | struct **in_place_unexpected_t**; | in_place_unexpected_t\u003cbr\u003eunexpect{}; |\n| In-place error construction | struct **in_place_unexpected_t**; | in_place_unexpected_t\u003cbr\u003ein_place_unexpected{}; |\n| Error reporting             | class **bad_expected_access**;    |\u0026nbsp; |\n\n### Interface of expected\n\n| Kind         | Method                                                              | Result |\n|--------------|---------------------------------------------------------------------|--------|\n| Construction | [constexpr] **expected**() noexcept(...)                                | an object with default value |\n| \u0026nbsp;       | [constexpr] **expected**( expected const \u0026 other )                      | initialize to contents of other |\n| \u0026nbsp;       | [constexpr] **expected**( expected \u0026\u0026 other )                           | move contents from other |\n| \u0026nbsp;       | [constexpr] **expected**( value_type const \u0026 value )                    | initialize to value |\n| \u0026nbsp;       | [constexpr] **expected**( value_type \u0026\u0026 value ) noexcept(...)           | move from value |\n| \u0026nbsp;       | [constexpr] explicit **expected**( in_place_t, Args\u0026\u0026... args )         | construct value in-place from args |\n| \u0026nbsp;       | [constexpr] explicit **expected**( in_place_t,\u003cbr\u003e\u0026emsp;std::initializer_list\u0026lt;U\u003e il, Args\u0026\u0026... args ) | construct value in-place from args |\n| \u0026nbsp;       | [constexpr] **expected**( unexpected_type\u003cE\u003e const \u0026 error )            | initialize to error |\n| \u0026nbsp;       | [constexpr] **expected**( unexpected_type\u003cE\u003e \u0026\u0026 error )                 | move from error |\n| \u0026nbsp;       | [constexpr] explicit **expected**( in_place_unexpected_t,\u003cbr\u003e\u0026emsp;Args\u0026\u0026... args ) | construct error in-place from args |\n| \u0026nbsp;       | [constexpr] explicit **expected**( in_place_unexpected_t,\u003cbr\u003e\u0026emsp;std::initializer_list\u0026lt;U\u003e il, Args\u0026\u0026... args )| construct error in-place from args |\n| Destruction  | ~**expected**()                                                         | destruct current content |\n| Assignment   | expected **operator=**( expected const \u0026 other )                        | assign contents of other;\u003cbr\u003edestruct current content, if any |\n| \u0026nbsp;       | expected \u0026 **operator=**( expected \u0026\u0026 other ) noexcept(...)             | move contents of other |\n| \u0026nbsp;       | expected \u0026 **operator=**( U \u0026\u0026 v )                                      | move value from v |\n| \u0026nbsp;       | expected \u0026 **operator=**( unexpected_type\u003cE\u003e const \u0026 u )                | initialize to unexpected |\n| \u0026nbsp;       | expected \u0026 **operator=**( unexpected_type\u003cE\u003e \u0026\u0026 u )                     | move from unexpected |\n| \u0026nbsp;       | template\u003c typename... Args \u003e\u003cbr\u003evoid **emplace**( Args \u0026\u0026... args )     | emplace from args |\n| \u0026nbsp;       | template\u003c typename U, typename... Args \u003e\u003cbr\u003evoid **emplace**( std::initializer_list\u0026lt;U\u003e il, Args \u0026\u0026... args )  | emplace from args |\n| Swap         | void **swap**( expected \u0026 other ) noexcept                              | swap with other  |\n| Observers    | constexpr value_type const \\* **operator-\u003e**() const                    | pointer to current content (const);\u003cbr\u003emust contain value |\n| \u0026nbsp;       | value_type \\* **operator-\u003e**()                                          | pointer to current content (non-const);\u003cbr\u003emust contain value |\n| \u0026nbsp;       | constexpr value_type const \u0026 **operator \\***() const \u0026                   | the current content (const ref);\u003cbr\u003emust contain value |\n| \u0026nbsp;       | constexpr value_type \u0026\u0026 **operator \\***() \u0026\u0026                             | the current content (non-const ref);\u003cbr\u003emust contain value |\n| \u0026nbsp;       | constexpr explicit operator **bool**() const noexcept                   | true if contains value |\n| \u0026nbsp;       | constexpr **has_value**() const noexcept                                | true if contains value |\n| \u0026nbsp;       | constexpr value_type const \u0026 **value**() const \u0026                        | current content (const ref);\u003cbr\u003esee [note 1](#note1) |\n| \u0026nbsp;       | value_type \u0026 **value**() \u0026                                              | current content (non-const ref);\u003cbr\u003esee [note 1](#note1) |\n| \u0026nbsp;       | constexpr value_type \u0026\u0026 **value**() \u0026\u0026                                  | move from current content;\u003cbr\u003esee [note 1](#note1) |\n| \u0026nbsp;       | constexpr error_type const \u0026 **error**() const \u0026                        | current error (const ref);\u003cbr\u003emust contain error |\n| \u0026nbsp;       | error_type \u0026 **error**() \u0026                                              | current error (non-const ref);\u003cbr\u003emust contain error |\n| \u0026nbsp;       | constexpr error_type \u0026\u0026 **error**() \u0026\u0026                                  | move from current error;\u003cbr\u003emust contain error |\n| \u0026nbsp;       | constexpr unexpected_type\u003cE\u003e **get_unexpected**() const                 | the error as unexpected\u0026lt;\u003e;\u003cbr\u003emust contain error |\n| \u0026nbsp;       | template\u003c typename Ex \u003e\u003cbr\u003ebool **has_exception**() const               | true of contains exception (as base) |\n| \u0026nbsp;       | value_type **value_or**( U \u0026\u0026 v ) const \u0026                               | value or move from v |\n| \u0026nbsp;       | value_type **value_or**( U \u0026\u0026 v ) \u0026\u0026                                    | move from value or move from v |\n| \u0026nbsp;       | ... | \u0026nbsp; |\n\n\u003ca id=\"note1\"\u003e\u003c/a\u003eNote 1: checked access: if no content, for std::exception_ptr rethrows error(), otherwise throws bad_expected_access(error()).\n\n### Algorithms for expected\n\n| Kind                   | Function |\n|------------------------|----------|\n| Relational operators   | \u0026nbsp;   | \n| ==\u0026ensp;!=\u0026ensp;\u003c\u0026ensp;\u003e\u0026ensp;\u003c=\u0026ensp;\u003e= | template\u003c typename T, typename E \u003e\u003cbr\u003econstexpr bool operator ***op***(\u003cbr\u003e\u0026emsp;expected\u0026lt;T,E\u003e const \u0026 x,\u003cbr\u003e\u0026emsp;expected\u0026lt;T,E\u003e const \u0026 y ) |\n| Comparison with unexpected_type | \u0026nbsp; | \n| ==\u0026ensp;!=\u0026ensp;\u003c\u0026ensp;\u003e\u0026ensp;\u003c=\u0026ensp;\u003e= | template\u003c typename T, typename E \u003e\u003cbr\u003econstexpr bool operator ***op***(\u003cbr\u003e\u0026emsp;expected\u0026lt;T,E\u003e const \u0026 x,\u003cbr\u003e\u0026emsp;unexpected_type\u0026lt;E\u003e const \u0026 u ) | \n| \u0026nbsp;                                   | template\u003c typename T, typename E \u003e\u003cbr\u003econstexpr bool operator ***op***(\u003cbr\u003e\u0026emsp;unexpected_type\u0026lt;E\u003e const \u0026 u,\u003cbr\u003e\u0026emsp;expected\u0026lt;T,E\u003e const \u0026 x ) | \n| Comparison with T                        | \u0026nbsp;   | \n| ==\u0026ensp;!=\u0026ensp;\u003c\u0026ensp;\u003e\u0026ensp;\u003c=\u0026ensp;\u003e= | template\u003c typename T, typename E \u003e\u003cbr\u003econstexpr bool operator ***op***(\u003cbr\u003e\u0026emsp;expected\u0026lt;T,E\u003e const \u0026 x,\u003cbr\u003e\u0026emsp;T const \u0026 v ) | \n| \u0026nbsp;                                   | template\u003c typename T, typename E \u003e\u003cbr\u003econstexpr bool operator ***op***(\u003cbr\u003e\u0026emsp;T const \u0026 v,\u003cbr\u003e\u0026emsp;expected\u0026lt;T,E\u003e const \u0026 x ) | \n| Specialized algorithms | \u0026nbsp;   | \n| Swap                   | template\u003c typename T, typename E \u003e\u003cbr\u003evoid **swap**(\u003cbr\u003e\u0026emsp;expected\u0026lt;T,E\u003e \u0026 x,\u003cbr\u003e\u0026emsp;expected\u0026lt;T,E\u003e \u0026 y )\u0026emsp;noexcept( noexcept( x.swap(y) ) ) | \n| Make expected from     | \u0026nbsp;   | \n| \u0026emsp;Value            | template\u003c typename T\u003e\u003cbr\u003econstexpr auto **make_expected**( T \u0026\u0026 v ) -\u003e\u003cbr\u003e\u0026emsp;expected\u003c typename std::decay\u0026lt;T\u003e::type \u003e | \n| \u0026emsp;Nothing          | auto **make_expected**() -\u003e expected\u0026lt;void\u003e | \n| \u0026emsp;Current exception| template\u003c typename T\u003e\u003cbr\u003econstexpr auto **make_expected_from_current_exception**() -\u003e expected\u0026lt;T\u003e | \n| \u0026emsp;Exception        | template\u003c typename T\u003e\u003cbr\u003eauto **make_expected_from_exception**( std::exception_ptr v ) -\u003e expected\u0026lt;T\u003e| \n| \u0026emsp;Error            | template\u003c typename T, typename E \u003e\u003cbr\u003econstexpr auto **make_expected_from_error**( E e ) -\u003e\u003cbr\u003e\u0026emsp;expected\u0026lt;T, typename std::decay\u0026lt;E\u003e::type\u003e | \n| \u0026emsp;Call             | template\u003c typename F \u003e\u003cbr\u003eauto **make_expected_from_call**( F f ) -\u003e\u003cbr\u003e\u0026emsp;expected\u003c typename std::result_of\u0026lt;F()\u003e::type \u003e| \n| \u0026emsp;Call, void specialization | template\u003c typename F \u003e\u003cbr\u003eauto **make_expected_from_call**( F f ) -\u003e expected\u0026lt;void\u003e | \n\n### Interface of unexpected_type\n\n| Kind         | Method                                                    | Result |\n|--------------|-----------------------------------------------------------|--------|\n| Construction | **unexpected_type**() = delete;                           | no default construction |\n| \u0026nbsp;       | constexpr explicit **unexpected_type**( E const \u0026 error ) | copy-constructed from an E |\n| \u0026nbsp;       | constexpr explicit **unexpected_type**( E \u0026\u0026 error )      | move-constructed from an E |\n| Observers    | constexpr error_type const \u0026 **value**() const            | can observe contained error |\n| \u0026nbsp;       | error_type \u0026 **value**()                                  | can modify contained error |\n\n### Algorithms for unexpected_type\n\n| Kind                   | Function |\n|------------------------|----------|\n| Relational operators   | \u0026nbsp;   | \n| ==\u0026ensp;!=\u0026ensp;\u003c\u0026ensp;\u003e\u0026ensp;\u003c=\u0026ensp;\u003e= | template\u003c typename E \u003e\u003cbr\u003econstexpr bool operator ***op***(\u003cbr\u003e\u0026emsp;unexpected_type\u0026lt;E\u003e const \u0026 x,\u003cbr\u003e\u0026emsp;unexpected_type\u0026lt;E\u003e const \u0026 y ) |\n| ==\u0026ensp;!=\u0026ensp;\u003c\u0026ensp;\u003e\u0026ensp;\u003c=\u0026ensp;\u003e= | constexpr bool operator ***op***(\u003cbr\u003e\u0026emsp;unexpected_type\u0026lt;std::exception_ptr\u003e const \u0026 x,\u003cbr\u003e\u0026emsp;unexpected_type\u0026lt;std::exception_ptr\u003e const \u0026 y ) |\n| Specialized algorithms | \u0026nbsp;   | \n| Make unexpected from   | \u0026nbsp;   | \n| \u0026emsp;Current exception| [constexpr] auto **make_unexpected_from_current_exception**() -\u003e\u003cbr\u003e\u0026emsp;unexpected_type\u003c std::exception_ptr \u003e| \n| \u0026emsp;Error            | template\u003c typename E\u003e\u003cbr\u003e[constexpr] auto **make_unexpected**( E \u0026\u0026 v) -\u003e\u003cbr\u003e\u0026emsp;unexpected_type\u003c typename std::decay\u0026lt;E\u003e::type \u003e| \n\n\n\u003ca id=\"comparison\"\u003e\u003c/a\u003e\nComparison with like types\n--------------------------\n\n|Feature               |\u003cbr\u003estd::pair|std:: optional |std:: expected |nonstd:: expected |Boost. Expected |Nonco expected |Andrei Expected |Hagan required |\n|----------------------|-------------|---------------|---------------|------------------|----------------|---------------|----------------|---------------|\n|More information      | see [14]    | see [5]       | see [1]       | this work        | see [4]        | see [7]       | see [8]        | see [13]      |\n|                      |             |               |               |                  |                |               |                |               |\n| C++03                | yes         | no            | no            | no/not yet       | no (union)     | no            | no             | yes           |\n| C++11                | yes         | no            | no            | yes              | yes            | yes           | yes            | yes           |\n| C++14                | yes         | no            | no            | yes              | yes            | yes           | yes            | yes           |\n| C++17                | yes         | yes           | no            | yes              | yes            | yes           | yes            | yes           |\n|                      |             |               |               |                  |                |               |                |               |\n|DefaultConstructible  | T param     | yes           | yes           | yes              | yes            | no            | no             | no            |\n|In-place construction | no          | yes           | yes           | yes              | yes            | yes           | no             | no            |\n|Literal type          | yes         | yes           | yes           | yes              | yes            | no            | no             | no            |\n|                      |             |               |               |                  |                |               |                |               |\n|Disengaged information| possible    | no            | yes           | yes              | yes            | yes           | yes            | no            |\n|Vary disengaged type  | yes         | no            | yes           | yes              | yes            | no            | no             | no            |\n|Engaged nonuse throws | no          | no            | no            | no               | error_traits   | no            | no             | yes           |\n|Disengaged use throws | no          | yes, value()  | yes, value()  | yes, value()     | yes,\u003cbr\u003evalue()| yes,\u003cbr\u003eget() | yes,\u003cbr\u003eget()  | n/a           |\n|                      |             |               |               |                  |                |               |                |               |\n|Proxy (rel.ops)       | no          | yes           | yes           | yes              | yes            | no            | no             | no            |\n|References            | no          | yes           | no/not yet    | no/not yet       | no/not yet     | yes           | no             | no            |\n|Chained visitor(s)    | no          | no            | yes           | maybe            | yes            | no            | no             | no            |\n\nNote 1: std:\u0026#58;*experimental*:\u0026#58;expected\n\nNote 2: sources for [Nonco expected](https://github.com/martinmoene/spike-expected/tree/master/nonco), [Andrei Expected](https://github.com/martinmoene/spike-expected/tree/master/alexandrescu) and [Hagan required](https://github.com/martinmoene/spike-expected/tree/master/hagan) can befound in the [spike-expected](https://github.com/martinmoene/spike-expected) repository.\n\n\nReported to work with\n---------------------\n\n\nImplementation notes\n--------------------\n\n\nOther implementations of expected\n---------------------------------\n- Simon Brand. [C++11/14/17 std::expected with functional-style extensions](https://github.com/TartanLlama/expected). Single-header.\n- Isabella Muerte. [MNMLSTC Core](https://github.com/mnmlstc/core) (C++11).\n- Vicente J. Botet Escriba. [stdmake's expected](https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/expected) (C++17).\n- Facebook. [ Folly's Expected.h](https://github.com/facebook/folly/blob/master/folly/Expected.h) (C++14).\n\n\nNotes and references\n--------------------\n[1] Vicente J. Botet Escriba. [p0323 - A proposal to add a utility class to represent expected object (latest)](http://wg21.link/p0323) (HTML). ([r6](http://wg21.link/p0323r6), [r5](http://wg21.link/p0323r5), [r4](http://wg21.link/p0323r4), [r3](http://wg21.link/p0323r3), [r2](http://wg21.link/p0323r2), [r1](http://wg21.link/n4109), [r0](http://wg21.link/n4015), [draft](https://github.com/viboes/std-make/blob/master/doc/proposal/expected/DXXXXR0_expected.pdf)).\n\n[2] Vicente J. Botet Escriba. [JASEL: Just a simple experimental library for C++](https://github.com/viboes/std-make). Reference implementation of [expected](https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/expected).\n\n[3] Vicente J. Botet Escriba. [Expected - An exception-friendly Error Monad](https://www.youtube.com/watch?v=Zdlt1rgYdMQ). C++Now 2014. 24 September 2014.  \n\n[4] Pierre Talbot. [Boost.Expected. Unofficial Boost candidate](http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/trademark/25002). 5 May 2013. [GitHub](https://github.com/TrademarkPewPew/Boost.Expected), [GSoC 2013 Proposal](http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/trademark/25002), [boost@lists.boost.org](http://permalink.gmane.org/gmane.comp.lib.boost.devel/240056 ).  \n\n[5] Fernando Cacciola and Andrzej Krzemieński. [A proposal to add a utility class to represent optional objects (Revision 4)](http://isocpp.org/files/papers/N3672.html). ISO/IEC JTC1 SC22 WG21 N3672 2013-04-19.  \n\n[6] Andrzej Krzemieński, [Optional library implementation in C++11](https://github.com/akrzemi1/Optional/).  \n\n[7] Anto Nonco. [Extending expected\u003cT\u003e to deal with references](http://anto-nonco.blogspot.nl/2013/03/extending-expected-to-deal-with.html). 27 May 2013.  \n\n[8] Andrei Alexandrescu. Systematic Error Handling in C++. Prepared for The C++and Beyond Seminar 2012. [Video](http://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2012-Andrei-Alexandrescu-Systematic-Error-Handling-in-C). [Slides](http://sdrv.ms/RXjNPR).  \n\n[9] Andrei Alexandrescu. [Choose your Poison: Exceptions or Error Codes? (PDF)](http://accu.org/content/conf2007/Alexandrescu-Choose_Your_Poison.pdf). ACCU Conference 2007.  \n\n[10] Andrei Alexandrescu. [The Power of None (PPT)](http://nwcpp.org/static/talks/2006/The_Power_of_None.ppt). Northwest C++ Users' Group. [May 17th, 2006](http://nwcpp.org/may-2006.html).  \n\n[11] Jon Jagger. [A Return Type That Doesn't Like Being Ignored](http://accu.org/var/uploads/journals/overload53-FINAL.pdf#page=18). Overload issue 53, February 2003.  \n\n[12] Andrei Alexandrescu. [Error Handling in C++: Are we inching towards a total solution?](http://accu.org/index.php/conferences/2002/speakers2002). ACCU Conference 2002.  \n\n[13] Ken Hagan et al. [Exploding return codes](https://groups.google.com/d/msg/comp.lang.c++.moderated/BkZqPfoq3ys/H_PMR8Sat4oJ). comp.lang.c++.moderated. 11 February 2000.  \n\n[14] [std::pair](http://en.cppreference.com/w/cpp/utility/pair). cppreference.com\n\n[15] Niall Douglas. [Outcome](https://ned14.github.io/outcome/). Very lightweight outcome\u0026lt;T\u003e and result\u0026lt;T\u003e (non-Boost edition). \n\nAppendix\n--------\n### A.1 expected lite test specification\n\n```\nunexpected_type\u003c\u003e: Disallows default construction\nunexpected_type\u003c\u003e: Disallows default construction, std::exception_ptr specialization\nunexpected_type\u003c\u003e: Allows to copy-construct from error_type\nunexpected_type\u003c\u003e: Allows to copy-construct from error_type, std::exception_ptr specialization\nunexpected_type\u003c\u003e: Allows to move-construct from error_type\nunexpected_type\u003c\u003e: Allows to move-construct from error_type, std::exception_ptr specialization\nunexpected_type\u003c\u003e: Allows to copy-construct from an exception, std::exception_ptr specialization\nunexpected_type\u003c\u003e: Allows to observe its value\nunexpected_type\u003c\u003e: Allows to observe its value, std::exception_ptr specialization\nunexpected_type\u003c\u003e: Allows to modify its value\nunexpected_type\u003c\u003e: Allows to modify its value, std::exception_ptr specialization\nunexpected_type\u003c\u003e: Provides relational operators\nunexpected_type\u003c\u003e: Provides relational operators, std::exception_ptr specialization\nmake_unexpected(): Allows to create an unexpected_type\u003cE\u003e from an E\nunexpected\u003c\u003e: C++17 and later provide unexpected_type as unexpected\nbad_expected_access\u003c\u003e: Disallows default construction\nbad_expected_access\u003c\u003e: Allows construction from error_type\nbad_expected_access\u003c\u003e: Allows to observe its error\nbad_expected_access\u003c\u003e: Allows to change its error\nexpected\u003c\u003e: Allows default construction\nexpected\u003c\u003e: Allows to copy-construct from value_type\nexpected\u003c\u003e: Allows to move-construct from value_type\nexpected\u003c\u003e: Allows to copy-construct from expected\u003c\u003e\nexpected\u003c\u003e: Allows to move-construct from expected\u003c\u003e\nexpected\u003c\u003e: Allows to in-place-construct value_type\nexpected\u003c\u003e: Allows to copy-construct from unexpected_type\u003c\u003e\nexpected\u003c\u003e: Allows to move-construct from unexpected_type\u003c\u003e\nexpected\u003c\u003e: Allows to in-place-construct unexpected_type\u003c\u003e\nexpected\u003c\u003e: Allows to copy-assign from expected\u003c\u003e\nexpected\u003c\u003e: Allows to move-assign from expected\u003c\u003e\nexpected\u003c\u003e: Allows to copy-assign from type convertible to value_type\nexpected\u003c\u003e: Allows to move-assign from type convertible to value_type\nexpected\u003c\u003e: Allows to be swapped\nexpected\u003c\u003e: Allows to observe its value via a pointer\nexpected\u003c\u003e: Allows to observe its value via a pointer to constant\nexpected\u003c\u003e: Allows to modify its value via a pointer\nexpected\u003c\u003e: Allows to observe its value via a reference\nexpected\u003c\u003e: Allows to observe its value via a r-value reference\nexpected\u003c\u003e: Allows to modify its value via a reference\nexpected\u003c\u003e: Allows to observe if it contains a value (or error)\nexpected\u003c\u003e: Allows to observe its value\nexpected\u003c\u003e: Allows to modify its value\nexpected\u003c\u003e: Allows to move its value\nexpected\u003c\u003e: Allows to observe its error\nexpected\u003c\u003e: Allows to modify its error\nexpected\u003c\u003e: Allows to move its error\nexpected\u003c\u003e: Allows to observe its error as unexpected\u003c\u003e\nexpected\u003c\u003e: Allows to observe its value if available, or obtain a specified value otherwise\nexpected\u003c\u003e: Allows to move its value if available, or obtain a specified value otherwise\nexpected\u003cvoid\u003e: Allows to default-construct\nexpected\u003cvoid\u003e: Allows to copy-construct from expected\u003cvoid\u003e\nexpected\u003cvoid\u003e: Allows to move-construct from expected\u003cvoid\u003e\nexpected\u003cvoid\u003e: Allows to in-place-construct\nexpected\u003cvoid\u003e: Allows to copy-construct from unexpected_type\u003c\u003e\nexpected\u003cvoid\u003e: Allows to move-construct from unexpected_type\u003c\u003e\nexpected\u003cvoid\u003e: Allows to in-place-construct unexpected_type\u003c\u003e\nexpected\u003cvoid\u003e: Allows to copy-assign from expected\u003c\u003e\nexpected\u003cvoid\u003e: Allows to move-assign from expected\u003c\u003e\nexpected\u003cvoid\u003e: Allows to be swapped\nexpected\u003cvoid\u003e: Allows to observe if it contains a value (or error)\nexpected\u003cvoid\u003e: Allows to observe its error\nexpected\u003cvoid\u003e: Allows to modify its error\nexpected\u003cvoid\u003e: Allows to move its error\nexpected\u003cvoid\u003e: Allows to observe its error as unexpected\u003c\u003e\noperator op: Provides relational operators\n```\n","versions":[{"ref":"master","manifest":"targets = [ \"//:expected-lite\" ]\n","lockFile":"","buck":"prebuilt_cxx_library(\n  name = 'expected-lite', \n  header_namespace = '', \n  header_only = True, \n  exported_headers = subdir_glob([\n    ('include/nonstd', '**/*.hpp'), \n  ]), \n  visibility = [\n    'PUBLIC', \n  ], \n)\n","bazel":"","deps":[],"lock":[]}],"updated":"2018-11-21T14:35:45Z","updatedUpstream":"2020-12-30T02:47:26Z","contributors":[{"login":"mabraham","avatarUrl":"https://avatars2.githubusercontent.com/u/112395?v=4"},{"login":"1082008","avatarUrl":"https://avatars0.githubusercontent.com/u/1082008?u=62e24ecf545e49d64ec9e433a08a072f8aca58a3\u0026v=4"},{"login":"rnburn","avatarUrl":"https://avatars3.githubusercontent.com/u/1923871?u=4c5a77f977cc624eaec0e6593ddc5d113f56b57e\u0026v=4"},{"login":"martinmoene","avatarUrl":"https://avatars0.githubusercontent.com/u/1999290?v=4"},{"login":"spease","avatarUrl":"https://avatars1.githubusercontent.com/u/2825204?v=4"},{"login":"lethe555","avatarUrl":"https://avatars3.githubusercontent.com/u/8001254?u=6768c6d06d041669bffc9ef675d3832c463fee63\u0026v=4"},{"login":"hubslave","avatarUrl":"https://avatars1.githubusercontent.com/u/29800872?v=4"},{"login":"kelvinyangis","avatarUrl":"https://avatars2.githubusercontent.com/u/35412753?u=f09f4ea565de4899a6b171851a2b132338ac68d6\u0026v=4"},{"login":"fbdtemme","avatarUrl":"https://avatars3.githubusercontent.com/u/69114541?v=4"}],"fundingLinks":[],"contactLinks":[],"stars":155,"forks":12,"topics":["cpp11","header-only","single-file","no-dependencies","expected-implementations"]}},"__N_SSG":true},"page":"/packages/[owner]/[name]","query":{"owner":"buckaroo-pm","name":"martinmoene-expected-lite"},"buildId":"XEnVUsOG7VkTdg59Wro6f","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-617a3a2c770be2525c7f.js"></script><script src="/_next/static/chunks/main-7d1613afc8c8f43cb50f.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.ae3781fe50e43492a499.js" async=""></script><script src="/_next/static/chunks/commons.9b549cceddc4472f1953.js" async=""></script><script src="/_next/static/chunks/pages/_app-3e4ffec4bbf3a45ef50f.js" async=""></script><script src="/_next/static/chunks/c18d713dde5d8f274a9340ae8a63196292880c5e.7af0c42e7b17c91d2be5.js" async=""></script><script src="/_next/static/chunks/pages/packages/%5Bowner%5D/%5Bname%5D-bc25a6cf0982fd349b0a.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_buildManifest.js" async=""></script><script src="/_next/static/XEnVUsOG7VkTdg59Wro6f/_ssgManifest.js" async=""></script></body></html>