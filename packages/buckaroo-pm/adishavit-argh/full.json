{
  "packageName": "buckaroo-pm/adishavit-argh",
  "name": "adishavit/argh",
  "licence": "NOASSERTION",
  "description": "Argh! A minimalist argument handler.",
  "readme": "![logo](assets/argh_logo_small.png)\n\n> *Frustration-free command line processing*\n\n[![Language](https://img.shields.io/badge/language-C++-blue.svg)](https://isocpp.org/)\n[![Standard](https://img.shields.io/badge/C%2B%2B-11-blue.svg)](https://en.wikipedia.org/wiki/C%2B%2B#Standardization)\n[![License](https://img.shields.io/badge/license-BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause)\n[![Try it online](https://img.shields.io/badge/try%20it-online-orange.svg)](http://melpon.org/wandbox/permlink/ralxPN49F7cUY2yw)\n[![Build Status](https://travis-ci.org/adishavit/argh.svg?branch=master)](https://travis-ci.org/adishavit/argh)\n\nSo many different command line processing libraries out there and none of them just work!  \nSome bring their whole extended family of related and unrelated external dependencies (*yes, I'm looking at you Boost*).  \nSome require quirky syntax and/or very verbose setups that sacrifice simplicity for the generation of a cute usage message and validation. Many come to dominate your `main()` file and yet others do not build on multiple plaforms - for some even their own tests and trivial usage cause crashes on some systems. *Argh!*\n\nIf you're writing a highly-sophisticated command line tool, then `Boost.Program_options` and its kind might give you many advanced options. However, if you need to get up and running quickly, effectively and with minimal fuss, give the single header-file `argh` a try.\n\n## TL;DR\nIt doesn't get much simpler than this:\n```cpp\n#include \"argh.h\"\n\nint main(int, char* argv[])\n{\n    argh::parser cmdl(argv);\n\n    if (cmdl[{ \"-v\", \"--verbose\" }])\n        std::cout << \"Verbose, I am.\\n\";\n\n    return EXIT_SUCCESS;\n}\n```\n## Philosophy\n\nContrary to many alternatives, `argh` takes a minimalist *laissez-faire* approach, very suitable for fuss-less prototyping with the following rules:\n\nThe API is:\n - Minimalistic but expressive:\n    - No getters nor binders\n    - Just the `[]` and `()` operators\n    - Easy iteration (range-`for` too)\n - You don't pay for what you don't use\n - Conversion to typed variables happens (via `std::istream >>`) on the user side *after* the parsing phase\n - No exceptions thrown for failures\n - Liberal BSD license\n - Single header file\n - No non-`std` dependencies\n\n`argh` does **not** care about:\n\n - How many '`-`' preceded your option\n - Which flags and options you support - that is your responsibility\n - Syntax validation: *any* command line is a valid (*not necessarily unique*) combination of positional *parameters*, *flags* and *options*\n - Automatically producing a usage message\n\n## Tutorial\n\nCreate parser:\n\n```cpp\nauto cmdl = argh::parser(argc, argv);\n```\nIn fact, you can even drop `argc`. This will also work:  \n```cpp\nargh::parser cmdl(argv);\n```\n\nPositional argument access by (integer) index with `[<size_t>]`:\n```cpp\ncout << \"Exe name is: \" << cmdl[0] << '\\n';\n                               ^^^\nassert(cmdl[10000].empty()); // out-of-bound index returns empty string\n            ^^^^^\n```\nBoolean flag argument access by (string) name with `[<std::string>]`:\n```cpp\ncout << \"Verbose mode is \" << ( cmdl[\"verbose\"] ? \"ON\" : \"OFF\" ) << '\\n';\n                                    ^^^^^^^^^^^\n```\nAny dashes are trimmed so are not required.  \n\nYour flag can have several alternatives, just list them with `[{ \"<name-1>\", \"<name-2>\", ... }]`:\n```cpp\ncout << \"Verbose mode is \" << ( cmdl[{ \"-v\", \"--verbose\" }] ? \"ON\" : \"OFF\" ) << '\\n';\n                                    ^^^^^^^^^^^^^^^^^^^^^^^\n```\nBeyond `bool` and `std::string` access with `[]`, as shown above, we can also access the argument values as an `std::istream`. This is very useful for type conversions.\n\n`std::istream` positional argument access by (integer) index with `(<size_t>)`:\n```cpp\nstd::string my_app_name;\ncmdl(0) >> my_app_name; // streaming into a string\n    ^^^\ncout << \"Exe name is: \" << my_app_name << '\\n';\n```\nWe can also check if a particular positional arg was given or not (this is like using `[<std::string>]` above):\n```cpp\nif (!cmdl(10))\n  cerr << \"Must provide at least 10 arguments!\" << '\\n';\nelse if (cmdl(11))\n  cout << \"11th argument  is: \" << cmdl[11] << '\\n';\n```\nBut we can also set default values for positional arguments. These are passed as the second argument:\n```cpp\nfloat scale_factor;\ncmdl(2, 1.0f) >> scale_factor;\n     ^^^^^^^\n```\nIf the position argument was not given or the streaming conversion failed, the default value will be used.  \n\nSimilarly, parameters can be accessed by name(s) (i.e. by string or list of string literals) with:  \n`(<std::string> [, <default value>])` or   `({ \"<name-1>\", \"<name-2>\", ... } [, <default value>])`:  \n```cpp\nfloat scale_factor;\ncmdl(\"scale\", 1.0f) >> scale_factor; // Use 1.0f as default value\n     ^^^^^^^^^^^^^\n\nfloat threshold;\nif (!(cmdl({ \"-t\", \"--threshold\"}) >> threshold)) // Check for missing param and/or bad (inconvertible) param value\n  cerr << \"Must provide a valid threshold value! Got '\" << cmdl(\"threshold\").str() << \"'\" << endl;\nelse                                                                        ^^^^^^\n  cout << \"Threshold set to: \" << threshold << '\\n';\n```\nAs shown above, use `std::istream::str()` to get the param value as a `std:string` or just stream the value into a variable of a suitable type. Standard stream state indicates failure, including when the argument was not given.  \nWhen using multiple names, the first value found will be returned.\n\nPositional arguments can be iterated upon directly using *range-for*:\n```cpp\ncout << \"Positional args:\\n\";\nfor (auto& pos_arg : cmdl)\n  cout << '\\t' << pos_arg << '\\n';\n```\nSimilarly, `cmdl.size()` will return the count of *positional* arguments. \n\nPositional arguments, flags *and* parameters are accessible as \"ranges\":\n```cpp\ncout << \"Positional args:\\n\";\nfor (auto& pos_arg : cmdl.pos_args())\n  cout << '\\t' << pos_arg << '\\n';\n\ncout << \"\\nFlags:\\n\";\nfor (auto& flag : cmdl.flags())\n  cout << '\\t' << flag << '\\n';\n\ncout << \"\\nParameters:\\n\";\nfor (auto& param : cmdl.params())\n  cout << '\\t' << param.first << \" : \" << param.second << '\\n';\n```\n\n\nBy default, options are assumed to be boolean flags. \nWhen this is not what you want, there are several ways to specify when an option is a parameter with an associated value.  \n\nSpecify **`PREFER_PARAM_FOR_UNREG_OPTION`** mode to interpret *any* `<option> <non-option>` as `<parameter-name> <parameter-value>`:\n```cpp\nusing namespace argh;\nauto cmdl = parser(argc, argv, parser::PREFER_PARAM_FOR_UNREG_OPTION);\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\ncout << cmdl(\"--threshold\").str() << '\\n';\n```\nPre-register an expected parameter name with `add_param()` (before calling `parse()`):\n```cpp\nargh::parser cmdl;\ncmdl.add_param(\"threshold\"); // pre-register \"threshold\" as a param: name + value\ncmdl.parse(argc, argv);\ncout << cmdl(\"threshold\").str() << '\\n';\n```\nYou can also *batch* pre-register multiple options as parameters with `add_params({ ... })`:\n```cpp\nargh::parser cmdl;\ncmdl.add_params({ \"-t\", \"--threshold\", \"-s\", \"--scale\" }); // batch pre-register multiple params: name + value\ncmdl.parse(argc, argv);\ncout << cmdl(\"threshold\").str() << '\\n';\n```\nSince pre-registration has to be done *before* parsing, we might as well just use the ctor:\n```cpp\nargh::parser cmdl({ \"-t\", \"--threshold\", \"-s\", \"--scale\" }); // batch pre-register multiple params: name + value\ncmdl.parse(argc, argv);\ncout << cmdl(\"threshold\").str() << '\\n';\n```\nUse a `=` (with no spaces around it) within the option when *calling* the app:\n```cpp\n>> my_app --threshold=42\n42\n```\n\n### Tips\n- By default, arguments of the form `--<name>=<value>` (with no spaces, one or more dashes), e.g. `--answer=42`, will be parsed as `<parameter-name> <parameter-value>`.\nTo disable this specify the **`NO_SPLIT_ON_EQUALSIGN`** mode.\n- Specifying the **`SINGLE_DASH_IS_MULTIFLAG`** mode will split a single-hyphen argument into multiple single-character flags (as is common in various POSIX tools).\n- When using **`SINGLE_DASH_IS_MULTIFLAG`**, you can still pre-register the last character as a param with the value, such that if we pre-register `f` as a param, `>> myapp -xvf 42` will be parsed with two boolean flags `x` and `v` and a one param `f`=`42`.\n- When parsing parameter values as strings that may contain spaces (e.g. `--config=\"C:\\Folder\\With Space\\Config.ini\"`), prefer using `.str()` instead of `>>` to avoid the default automatic whitespace input stream tokenization:  \n`cout << cmdl({ \"-c\", \"--config\" }).str()`.\n\n## Terminology\nAny command line is composed of **2** types of *Args*:\n\n1. ***Positional Args***:  \n    Free standing, in-order, values  \n    e.g. `config.json`  \n2. ***Options***:  \n    Args beginning with `-` (and that are not negative numbers).  \n    We identify ***2*** kinds of *Options*:  \n    1. ***Flags***:  \n       Boolean options =>  (appear ? true : false)  \n       e.g. `-v`, `--verbose`  \n    2. ***Parameters***:  \n       A named value followed by a *non*-option value  \n       e.g. `--gamma 2.2`  \n\nThus, any command line can always be broken into some combination of *(1) positional args* *(2) flags* and *(3) parameters*.  \n\n## API Summary\n### Parsing\nParse the command line using either\n- The `parse()` method: `parser::parse([argc,] argv [, mode])`; or\n- The shorter form using the ctor directly:\n  `argh::parser([argc,] argv [, mode]);`\n- The shortest form does not even require `argc`, so in default `mode` just use:   \n  `parser(argv);`\n\n### Special Parsing Modes\nExtra flexibility can be added be specifying parsing modes:\n- **`NO_SPLIT_ON_EQUALSIGN`**:\n   By default, an option of the form `--pi=22/7` will be parsed as a *parameter* `pi` with an associated value `\"22/7\"`.\n   By setting this mode, it will be not be broken at the `=`.\n- **`PREFER_FLAG_FOR_UNREG_OPTION`**:\n  Split `<option> <non-option>` into `<flag>` and `<pos_arg>`.\n  e.g. `myapp -v config.json` will have `v` as a lit flag and `config.json` as a positional arg.\n  *This is the default mode.*\n- **`PREFER_PARAM_FOR_UNREG_OPTION`**:\n  Interpret `<option> <non-option>` as `<parameter-name> <parameter-value>`.\n  e.g. `myapp --gamma 2.2` will have `gamma` as a parameter with the value \"2.2\".\n- **`SINGLE_DASH_IS_MULTIFLAG`**:\n  Splits an option with a *single* dash into separate boolean flags, one for each letter.\n  e.g. in this mode, `-xvf` will be parsed as 3 separate flags: `x`, `v`, `f`.\n\n### Argument Access\n- Use *bracket operators* to access *flags* and *positional* args:\n    - Use `operator[index]` to access *position* arg strings by *index*:\n        - e.g. `assert(cmdl[0] == argv[0])`, the app name.\n    - Use `operator[string]` to access boolean *flags* by *name*:\n        - e.g. `if (cmdl[\"v\"]) make_verbose();`\n    - Use `operator[{...}]` to access boolean *flags* by *multiple names*:\n        - e.g. `if (cmdl[{ \"v\", \"verbose\" }]) make_verbose();`\n  \n- Use the *parenthesis operators* to get an `std::istream` to stream values from *parameters* and *positional* args:\n    - Use `operator(index)` to access position arg `istream` by index:\n        - e.g. `cmdl(0) >> my_app_name`.\n    - Use `operator(string)` to access *parameter* values by *name*:\n        - e.g. `cmdl(\"scale\") >> scale_factor;`\n    - Use `operator({...})` to access *parameter* values by *multiple names*:\n        - e.g. `cmdl({ \"-s\", \"--scale\" }) >> scale_factor;`        \n    - Use `operator(index, <default>)` and `operator(string/{list}, <default>)` to stream a default value if the arg did not appear on the command line:\n        - e.g. `cmdl(\"scale\", 1.0f) >> scale_factor;`\n\nThe streaming happens at the user's side, so conversion failure can be checked there:\ne.g\n\n```cpp\nif (!(cmdl(\"scale\") >> scale_factor))\n  cerr << \"Must provide valid scale factor!\" << '\\n';\n```\n\nUse the `.str()` method to get the parameter value as a string: e.g. `cmdl(\"name\").str();`\n\n### More Methods\n\n- Use `parser::add_param()`, `parser::add_params()` or the `parser({...})` constructor to *optionally* pre-register a parameter name when in `PREFER_FLAG_FOR_UNREG_OPTION` mode.\n- Use `parser`, `parser::pos_args()`, `parser::flags()` and `parser::params()` to access and iterate over the Arg containers directly.\n\n## Finding Argh!\n\n* copy `argh.h` somewhere into your projects directories\n* **or** include the repository as a *submodule*\n* **or** use *CMake*!\n\n#### Finding Argh! - CMake\n\nThe provided `CMakeLists.txt` generates targets for tests, a demo application and an install target to install `argh` system-wide and make it known to CMake.  *You can control generation of* test *and* example *targets using the options `BUILD_TESTS` and `BUILD_EXAMPLES`. Only `argh` alongside its license and readme will be installed - not tests and demo!*\n\n\nAdd `argh` to your CMake-project by using\n```cmake\nfind_package(argh)\n```\nThe package exports `argh` *INTERFACE* library target and `argh_INCLUDE_DIR` variable. Make `argh.h` known to your compiler by using one of the following methods; both will make the location of `argh.h` known to the compiler, not link in a precompiled library - even when using `target_link_libraries()`.\n```cmake\ntarget_include_directories(${MY_TARGET_NAME} PRIVATE \"${argh_INCLUDE_DIR}\")\n#OR\ntarget_link_libraries(${MY_TARGET_NAME} argh)\n\n```\n\n## Colophon\n\nI ❤ your feedback. If you found Argh! useful - do Tweet about it to let [me](https://twitter.com/AdiShavit) know. If you found it lacking, please post an [issue](https://github.com/adishavit/argh/issues).\n",
  "versions": [],
  "updated": "2018-11-07T22:47:33Z",
  "updatedUpstream": "2021-01-12T19:20:11Z",
  "contributors": [
    {
      "login": "jhh",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/14412?v=4"
    },
    {
      "login": "juev",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/114635?v=4"
    },
    {
      "login": "marcomagdy",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/115965?v=4"
    },
    {
      "login": "sehe",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/324097?v=4"
    },
    {
      "login": "abigagli",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/589164?v=4"
    },
    {
      "login": "bitmeal",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/1504749?v=4"
    },
    {
      "login": "BillyONeal",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/1544943?v=4"
    },
    {
      "login": "Manu343726",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/1561197?u=5d082afa9051086ec20f428908a542e5870d7511&v=4"
    },
    {
      "login": "njlr",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/1577531?u=b805a63f8054b62169749f2c9d2e89eb53af57d7&v=4"
    },
    {
      "login": "adishavit",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/1814800?u=fbcbb3f0ad360973bad81654c947af2c4adc90b8&v=4"
    },
    {
      "login": "woodruffw",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/3059210?u=13c2756bc8374f05ac6244e0ced8a3573b038b73&v=4"
    },
    {
      "login": "ufoq",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/3118864?u=ca673818bf56333b7226514693d2e8442a18041b&v=4"
    },
    {
      "login": "jpyllman",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/4538937?u=aaec151ec49035d3166b6d68920bdf4b2fb33f0a&v=4"
    },
    {
      "login": "0x1F9F1",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/6098371?u=68c34883883c1486ad039e79354e9d7c7786736d&v=4"
    },
    {
      "login": "a4z",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/6172295?u=4e5b68bbdf89a06697ac71bdc790f4750feb3471&v=4"
    },
    {
      "login": "Symbitic",
      "avatarUrl": "https://avatars0.githubusercontent.com/u/9487468?u=b0692603716f9c94026ef225f58aac6b947baa5e&v=4"
    },
    {
      "login": "ChaosCabbage",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/10758904?u=b5be5d26a5197eecbfdc1586bfeebe2b1b2f00b4&v=4"
    },
    {
      "login": "danimtb",
      "avatarUrl": "https://avatars1.githubusercontent.com/u/10808592?u=d76be0dda1bc37efbeca79975a5c723616781dc2&v=4"
    },
    {
      "login": "memsharded",
      "avatarUrl": "https://avatars2.githubusercontent.com/u/15367152?v=4"
    },
    {
      "login": "GrishaKirilin",
      "avatarUrl": "https://avatars3.githubusercontent.com/u/16137846?v=4"
    }
  ],
  "fundingLinks": [],
  "contactLinks": [],
  "stars": 721,
  "forks": 54,
  "topics": [
    "command-line",
    "cpp11",
    "cli-args",
    "getopt",
    "getopts",
    "header-only",
    "single-file",
    "argument-parser",
    "cli",
    "command-line-parser"
  ]
}