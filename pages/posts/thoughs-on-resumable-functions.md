---
title: Thoughts on Resumable Functions
author: Gaetano Checinski
---
# Thoughts on Resumable Functions

In N4453 has been designed to have implicit virality making every function that uses resumable functions a coroutine.
The goal of N4453 strives to establish a simpler model and increase code reuse at the same time.

N4453 does not require to write any types to define a coroutine.
This makes resumable functions very simple to use.
Compared to N4775 the coroutine type is generated by the compiler and offers no customisation points to the user.

Suspend-up in the proposed model won’t be feasible without heap allocations.

<Quote>
  Suspend-up in the proposed model won’t be feasible without heap allocations.
</Quote>

# The Challange with Suspend-Up

First of all lets consider the following example:

```c++
template<class F>
void foo(F action) {
  //doSth
  /*await*/ action();
  //doMore
}
```

Awaiting an awaitable implies **inversion of control** and **inversion of ownership**. As a result foo implementation is dependent whether action is a resumable function.


## What Impact Does Inversion of Control Have on Code Generation?

Inversion of Control occurs by definition in the suspend-up model as the awaiter needs to give control of the execution flow to the callee.
The callee then decides when to execute the remaining function.

This can be implemented in couple ways.
In any case, conceptually the callee / awaitable receives a callback that the callee may call when he wishes to continue(resume) the computation.

This can be achieved by transforming the coroutine into a state machine or by creating a callback containing the code below the suspension point.


## What Impact Does Inversion of Ownership Have on Code Generation?

As the callee decides when (if at all) to continue(resume) the execution of the caller, the lifetime of the callers variables(stack) is unknown.

This means the ownership of those variables needs to be transferred to the callee.
In garbage collected languages this is not problematic as lifetime and memory is managed by a global instance - the Garbage Collector.

N4775 is hiding this problem by allocating the promise_type - including the coroutine_frame - on the heap.
As a result the coroutine is not movable because everything becomes dependent on the particular address the coroutine_frame is expected to be found.
This proposal don’t seem to provide a solution to this challenge.

## Conclusion: Suspend Up must not be implicit

Due the impact of suspend-up to the control flow and ownership, it is benefitial to encode this into the typesystem.
This will enable the compiler to enfore correctness and will provide valuable information to the user of the coroutine.

The resumable function proposal makes this - in the pursue of maximizing code reuse - challanging. 

# Proposal 1 - State-Machines

We only implement Suspend Down using a source transformation to state-machines.
This is a stripped down version of the resumable function proposal.

## Idea:

- A keyword of choice marks a suspension point eg. `yield` 
- A function that uses eg. yield is transformed into a state-machine.
- An appropriate type is generated by the compiler to represent the state machine.
- If the function is called that contains the yield keyword, the compiler generated statemachine type is instantiated and returned.
- If the function specifies a return-type, then the returned object is implicitly converted to that type(if possible)


### Example: 

```c++
auto fib() {
  int a=0;
  int b=1;
  while(1) {
    yield a;
    b = a + b;
    a = b - a;
  }
}
```

Which then in turn would generate the following type:

```c++
struct __fib_coro {
 int a=0;
 int b=1;
 int current_value = 0;
 int __goto__ = 0;
 
 __fib_coro() = default;
 __fib_coro(__fib_coro const&) = default;
 __fib_coro(__fib_coro&&) = default;
 bool done() { return __goto__ != -1; }
 
 int advance() {
   switch(__goto__) {
     //...
   }
 }
 
 int value() {
   return current_value;
 }
};
```

This approach is just syntactic sugar, comparable to lambdas with captures.
Furthermore the returned object can be allocated on the caller’s stack and a custom type can be used to type-erase the compiler-provided type.

This approach provides a zero cost abstraction for lazy sequences and alike.
This is the simplest possible implementation as it could be implemented as a pure AST-Transformation.


## Notes

- This proposal may also be extended to customize the behaviour of throw which would make the [try-expressions proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf) redundant and make std::optional and std::expected more usable.

- Async/Await can be implemented by yielding thennables that are consumed by an executor that resumes. (more details will follow)


# Proposal 2: Implement Computation Expressions for C++ as a Pure Code Transformation

## Idea:

```
auto oneAndTwo(int a, int b) {
    return Lazy<int>([=] {
        yield a;
        yield b;
    });
}
```

should transform to:

```
auto oneAndTwo() {
  return Lazy<int>{}.Yield(1, [=](auto m) {
    return m.Yield(2, [=](auto m) {
      return m.Done();
    });
  });
}
```

Where `Lazy<T>` would implement:

```c++

template<class T>
struct Lazy {

template<class Continuation>
auto Yield(T value, Continuation c);

// Not needed for generators
// template<class E, class Continuation>
// auto Await(E expr, Continuation c);

template<class Cond, class Body, class Else>
auto While(Cond, Body, Else);

template<class Next, class Body, class Else>
auto ForRange(Next, Body, Else);

auto Done();
};
```

This Code transformation can be used for implementing suspend up and suspend down. Async computation would look very simmilar:

```c++
return Async([]{
  auto x <- fetch(url); // <- <expr> means: = await <expr> 
  return x;
});
```

Furthermore it is also suitable for several other use cases, like Event Emitters and Optionals.
It is better to avoid the await keyword as it is misleading in a context different than async.


This idea is inspired by F#'s [Computation Expressions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions).

A less powerful version is Haskell's [Do-Notation](https://en.wikibooks.org/wiki/Haskell/do_notation)

## Notes

- The associated builder type could look like [this](https://godbolt.org/z/ZTCaTE)

- F# API for computation expressions is simpler as alot of the complexity is hidden in the .Net runtime. In C++ the implementor needs to wire up the continuations manually and in order to decide how the ownership model.

- F# has `let! x = fetch(url)` instead of `let x = await fetch(url)`. Considering the underlying code-transformation this is easier to implement and closer to the generated code. C++ could implement `auto! x = fetch(url)` or `auto await x = fetch(url)`.

- Would work well with Executors and Net.ts especially if we standardize on having the callback as the last argument.


# Random Nitpicks

## Re: 4.2

> Even though N4286’s up-and-out resumable functions require new keywords, the **overall control flow is still the same imperative approach found elsewhere in the language**.

Although the code **reads** like sequencial and imperative code, it is not.
The actual control flow is decided by the implementation of the coroutine.

# Re: Bugs caused by forgetting to await


> For example, when composing asynchronous operations it is no longer necessary to mark asynchronous call with the keyword await


> Conversely, whenever we make a call to a resumable function we must remember to annotate the call with an await keyword.


This does not happen as often in practise as often forgetting the await keyword often leads to a type-mismatch.

It is only problematic with coroutines that cause a sideeffect but don't return a value (eg. sendAnalyticsEvent(msg)).
Those Bugs can be mitigated by using ```[[nodiscard]]```.

Futhermore there are at least 3 cases where you don't want to await:

1) you want to collect awaitables and await those later. Example is `when_all` or `when_any`. 
2) you might want to wait on an awaitable conditionally.
3) you want to run an awaitable on a seperate worker pool.


Furthermore, the implementation might not even require to await the awaitable at all. In N4775 it is possible to implement "fire-and-forget" coroutines that self-destruct(ugly) or store themselfs in a global or provided context. 


## Re: resumable tcp_reader

Equivalent using resumable expressions
```
resumable void tcp_reader(int total)
{
  char  buf[64 * 1024];
  auto  conn  =
  Tcp::Connect("127.0.0.1”, 1337);
  do
  {
    auto bytesRead =
      conn.read(buf, sizeof(buf));
      total -= bytesRead;
  }
  while	(total > 0);
}
```

How would a async generator work in this proposal?

### Re: interop with algorithms

```c++
std::future<void> tcp_sender(std::vector<std:string> msgs)
{
  auto conn = await Tcp::Connect("127.0.0.1”, 1337);
  std::for_each(msgs.begin(), msgs.end(),
    [&conn](const std::string& msg) // missing -> Awaitable_Coro_Type<void> ?
    {
      await conn.write(msg.data(), msg.size());
    });
}
```

Nitpick: It is bad practise to run side-effects in a for_each.
Better: use for-range-loop or use std::transform (or similar) and explicitly use deal with the awaitables using `when_all` or similar.
