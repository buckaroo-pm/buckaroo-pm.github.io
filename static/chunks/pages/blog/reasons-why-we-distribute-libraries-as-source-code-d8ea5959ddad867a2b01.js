_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[30],{Ijnw:function(e,t,o){"use strict";o.r(t),o.d(t,"frontMatter",(function(){return u})),o.d(t,"default",(function(){return p}));var r=o("rePB"),a=o("Ff2n"),i=(o("q1tI"),o("7ljp")),s=o("ZDfL");function n(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,r)}return o}function c(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?n(Object(o),!0).forEach((function(t){Object(r.a)(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}var u={title:" 6 Reasons Why We Distribute C++ Libraries as Source-Code",banner:"/posts/reason-why-we-distribute.jpeg",author:"Team Buckaroo",created:"2017-07-25T11:00:00.000Z",attribution:"It\u2019s JavaScript\u2026 which is distributed as source-code! (Photo by Markus Spiske on Unsplash)",__resourcePath:"blog/reasons-why-we-distribute-libraries-as-source-code.md",__scans:{},layout:"index"},l={frontMatter:u},b=s.a;function p(e){var t=e.components,o=Object(a.a)(e,["components"]);return Object(i.a)(b,c(c(c({},l),o),{},{components:t,mdxType:"MDXLayout"}),Object(i.a)("p",null,"6 Reasons Why We Distribute C++ Libraries as Source-Code"),Object(i.a)("p",null,"When writing C++ applications, you will inevitably make use of external libraries. This is a good thing! Code re-use makes us more productive and let\u2019s us build bigger and better products. With ",Object(i.a)("a",c({parentName:"p"},{href:"http://buckaroo.pm"}),"Buckaroo.pm")," we are trying to make this even easier, with a source-only package manager for C++."),Object(i.a)("p",null,"Source-only? Yes, and here\u2019s why:"),Object(i.a)("h2",null,"1. It\u2019s Cross Platform"),Object(i.a)("p",null,"Assuming the C++ code properly abstracts away any system libraries used, the C++ source-code is fully portable. Once it is compiled however, this property is lost since a binary must target a particular instruction set."),Object(i.a)("h2",null,"2. The Debugging Experience is Better"),Object(i.a)("p",null,"When debugging a project, it\u2019s nice to be able to dig into the implementation of the library functions that you use. This is made particularly easy when you are building from source, since the exact code that you depend on is already on your machine!"),Object(i.a)("h2",null,"3. No ABI Compatibility Issues"),Object(i.a)("p",null,"Users of GCC will be aware of the std::string ABI changes from 4.9 to 5.0. Whilst this change was necessary to switch to C++ 11, it ",Object(i.a)("a",c({parentName:"p"},{href:"https://stackoverflow.com/questions/34571583/understanding-gcc-5s-glibcxx-use-cxx11-abi-or-the-new-abi"}),"caused lots of confusion")," in the community. If you\u2019re already building your project from source, then upgrading is an easy task. \ud83d\ude0c"),Object(i.a)("h2",null,"4. Source-code is Smaller"),Object(i.a)("p",null,"Due to its code-generation features, this is particularly true of C++: the source-code of a library is often far smaller than its corresponding binary. In fact, with reproducible builds, source-code is an excellent form of compression!"),Object(i.a)("h2",null,"5. Compiler Flags Can Be Properly Supported"),Object(i.a)("p",null,"A library with 1 compiler switch has 2 possible compiled binaries. A library with 2 compiler switches has 4 possible binaries. A library with 3 compiler switches has 8 possible binaries. A library with 4 compiler switches has 16 possible binaries. Now throw cross-compilation into the mix... You get the idea. Not all of these combinations are significant, but the complexity is enormous. When distributing from source, we can support all possible compiler flag settings by allowing the user to control the process."),Object(i.a)("h2",null,"6. Better Optimization"),Object(i.a)("p",null,"C++ is all about building towers of abstraction that the compiler can tear down into efficient machine code. These abstractions are lost after compilation, and with it important information that might be used to optimize your code. When using binary libraries, you lose the opportunity to perform many cross-library optimizations. Building from source can yield faster code."),Object(i.a)("h2",null,"But What About Compilation Times?"),Object(i.a)("p",null,"This is where a good build system is crucial. We chose ",Object(i.a)("a",c({parentName:"p"},{href:"https://buckbuild.com"}),"Buck build"),", a reproducible build system developed and used by Facebook. Because Buck is reproducible, it becomes possible to cache intermediary build artifacts and share them across your team!"),Object(i.a)("p",null,"Read ",Object(i.a)("a",c({parentName:"p"},{href:"https://hackernoon.com/7-reasons-to-use-buck-build-5b44d7413585"}),"7 Reasons to Use Buck Build"),"."),Object(i.a)("h2",null,"Ready to Try Buckaroo?"),Object(i.a)("p",null,Object(i.a)("a",c({parentName:"p"},{href:"http://buckaroo.pm"}),"Buckaroo")," is a source-only C++ package manager. To get started, head over to ",Object(i.a)("a",c({parentName:"p"},{href:"https://buckaroo.readthedocs.io/en/latest/"}),"the documentation"),". You can browse the existing packages on ",Object(i.a)("a",c({parentName:"p"},{href:"http://buckaroo.pm"}),"Buckaroo.pm")," or request more over on ",Object(i.a)("a",c({parentName:"p"},{href:"https://github.com/LoopPerfect/buckaroo-wishlist"}),"the wishlist"),"."))}p.isMDXComponent=!0},WNHg:function(e,t,o){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/reasons-why-we-distribute-libraries-as-source-code",function(){return o("Ijnw")}])}},[["WNHg",0,2,1,3,4]]]);