<!DOCTYPE html>
    <html>
      <head>
        <title>Buckaroo - The C++ Package Manager value_ptr‚Ää‚Äî‚ÄäThe Missing C++ Smart-pointer</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="/styles/normalize.min.css"/>
        <link rel="stylesheet" type="text/css" href="/styles.css"/>

        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
        <script type="text/javascript">
          window.rootUrl = ""
        </script>
      </head>
      <body>
        <div id="react-root">
        <header id="header"><div class="content"><a id="logo" href="/">Buckaroo</a><nav><ul><li><a href="/blog">Blog</a></li><li><a href="https://github.com/LoopPerfect/buckaroo/wiki">Docs</a></li><li><a href="https://github.com/LoopPerfect/buckaroo">Code</a></li><li><iframe id="star-button" src="https://ghbtns.com/github-btn.html?user=LoopPerfect&amp;repo=buckaroo&amp;type=star&amp;count=true&amp;size=large" frameBorder="0" scrolling="0" width="160px" height="30px"></iframe></li></ul></nav></div></header><div class="page mt-4 ph-1"><div class="content"><h1>value_ptr‚Ää‚Äî‚ÄäThe Missing C++ Smart-pointer</h1><p>üìù¬†<!-- -->Team Buckaroo<!-- -->, <!-- -->21/02/2019<!-- --> <br/>üí¨¬†<a href="https://news.ycombinator.com/submitlink?u=https%3A%2F%2Fbuckaroo.pm%2Fposts%2Fvalue-ptr-the-missing-smart-ptr&amp;t=value_ptr%E2%80%8A%E2%80%94%E2%80%8AThe%20Missing%20C%2B%2B%20Smart-pointer">Discuss on Hacker News</a></p><hr/><div class="post-container"><div><h2 id="TL;DR">TL;DR</h2><p>Use the <span class="inline-code">value_ptr</span> smart-pointer to get value semantics on a heap resource. At the cost of some extra copying, your code will be simpler and easier to reason about.</p><p>Choose which smart-pointer to use with this cheat-sheet.</p><table><thead><tr><th>Name</th><th>Ownership</th><th>Copyable</th><th>Movable</th><th>Sharing</th><th>Lifetime</th><th>Semantics</th></tr></thead><tbody><tr><td><span class="inline-code">unique_ptr</span></td><td>Unique</td><td>‚ùå</td><td>‚úÖ</td><td>‚ùå</td><td>Lexical</td><td>Reference</td></tr><tr><td><span class="inline-code">shared_ptr</span></td><td>Shared</td><td>‚úÖ</td><td>‚úÖ</td><td>Reference</td><td>Reference-counted</td><td>Reference</td></tr><tr><td><span class="inline-code">weak_ptr</span></td><td>‚ùå</td><td>‚úÖ</td><td>‚úÖ</td><td>‚ùå</td><td>Non-extending</td><td>Optional-reference</td></tr><tr><td><span class="inline-code">value_ptr</span></td><td>Unique</td><td>‚úÖ</td><td>‚úÖ</td><td>Value</td><td>Lexical</td><td>Value</td></tr></tbody></table><p>An implementation of <span class="inline-code">value_ptr</span> can be <a href="https://github.com/LoopPerfect/valuable">found on GitHub</a>.</p><h2 id="Introduction">Introduction</h2><p>Language features like templates, lambdas and lexically-scoped destructors empower C++ programmers to write higher-order containers to handle an object‚Äôs lifetime and side-effects, documenting them in an understandable way in the type-system.</p><p>With smart-pointers, encoding ownership semantics and managing resources has never been easier. We can find smart-pointers in the standard library for the most common use-cases, however none of these smart-pointers provides value semantics. This article will introduce the <span class="inline-code">value_ptr</span>, alongside some motivating examples.</p><p>But first, let‚Äôs take a look at the functionality that the C++ 11 standard library already offers:</p><h3 id="(Dumb)-Raw-Pointers">(Dumb) Raw Pointers</h3><p>Yes, raw pointers can be still used, but you should avoid them if a smart-pointer is applicable. This is because raw pointers do not convey any information about a resource‚Äôs ownership model.</p><p>Furthermore, allocation and deallocation must be managed by the programmer, which may lead to bugs like double-delete or memory-leaks.</p><p>Take a look at this code:</p><pre><pre lang="cpp" class="code" style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span style="color:#c678dd">void</span>* x = createInstance();
<span style="color:#c678dd">int</span>* y = <span style="color:#c678dd">new</span> <span style="color:#c678dd">int</span>();
foo.bar(y);</code></pre></pre><p>From just three lines, there are so many unanswered questions:</p><ul><li>Can <span class="inline-code">x</span> be <span class="inline-code">nullptr</span> and do I have to check?</li><li>Is <span class="inline-code">x</span> managed? Can I delete <span class="inline-code">x</span>? <em>Must</em> I delete <span class="inline-code">x</span>?</li><li>If I delete <span class="inline-code">y</span> before <span class="inline-code">foo</span>, is <span class="inline-code">foo</span> still valid?</li><li>If <span class="inline-code">foo</span> gets destroyed, will <span class="inline-code">y</span> be deleted?</li></ul><p>Used correctly, a smart-pointer makes these clear.</p><h3 id="unique_ptr">unique_ptr</h3><p><span class="inline-code">unique_ptr</span> manages the lifetime of an resource by taking sole ownership of it and binding that to its lexical scope. While copying is not possible, the ownership can be transferred via <span class="inline-code">std::move</span>.</p><p>Use <span class="inline-code">unique_ptr</span> when:</p><ul><li>You want to tie the lifetime of a heap resource to a lexical scope</li><li>You want to enforce that the resource only has one owner at a time</li></ul><h4 id="Example">Example</h4><pre><pre lang="cpp" class="code" style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span class="hljs-class"><span style="color:#c678dd">struct</span> <span style="color:#61aeee">Widget</span> {</span>
  Widget() { <span style="color:#e6c07b">cout</span> &lt;&lt; <span style="color:#98c379">&quot;Widget created&quot;</span> &lt;&lt; <span style="color:#e6c07b">endl</span>; }
  ~Widget() { <span style="color:#e6c07b">cout</span> &lt;&lt; <span style="color:#98c379">&quot;Widget destroyed&quot;</span> &lt;&lt; <span style="color:#e6c07b">endl</span>; }
};

<span style="color:#e6c07b">unique_ptr</span>&lt;Widget&gt; createWindow() {
  <span style="color:#c678dd">return</span> make_unique&lt;Widget&gt;();
}

<span class="hljs-function"><span style="color:#c678dd">int</span> <span style="color:#61aeee">main</span><span class="hljs-params">()</span> </span>{
  <span style="color:#c678dd">auto</span> w = createWindow();
  ASSERT(w);
  <span style="color:#5c6370;font-style:italic">// auto w2 = widget; // error: unique_ptr has no copy-constructor</span>
  <span style="color:#c678dd">auto</span> w3 = move(widget); <span style="color:#5c6370;font-style:italic">// w3 owns now the widget, w is empty</span>
  ASSERT(w3 &amp;&amp; !w);
  <span style="color:#5c6370;font-style:italic">// w3 calls destructor of widget; only one object at a time owns the Widget</span>
  <span style="color:#c678dd">return</span> <span style="color:#d19a66">0</span>;
}</code></pre></pre><h3 id="shared_ptr">shared_ptr</h3><p><span class="inline-code">shared_ptr</span> allows for multiple resource owners by counting the number of references under management. The container‚Äôs copy-constructor increments the counter and decrements it on destruction. If the counter hits zero, then the resource will be disposed.</p><p>Use <span class="inline-code">shared_ptr</span> when:</p><ul><li>You want to share ownership between multiple references</li><li>You want to dispose of a resource automatically when it is no longer used</li><li>You don‚Äôt have cyclic dependencies</li><li>The overhead of reference counting is acceptable</li></ul><h4 id="Example-2">Example</h4><pre><pre lang="cpp" class="code" style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span class="hljs-class"><span style="color:#c678dd">struct</span> <span style="color:#61aeee">Texture</span> {</span>
  Texture(<span style="color:#e6c07b">string</span> <span style="color:#c678dd">const</span>&amp; path) {
    <span style="color:#e6c07b">cout</span> &lt;&lt; <span style="color:#98c379">&quot;Texture loaded from &quot;</span> &lt;&lt; path &lt;&lt; <span style="color:#e6c07b">endl</span>;
  }

  ~Texture() {
    <span style="color:#e6c07b">cout</span> &lt;&lt; <span style="color:#98c379">&quot;Texture destroyed&quot;</span> &lt;&lt; <span style="color:#e6c07b">endl</span>;
  }

  <span style="color:#c678dd">static</span> <span style="color:#e6c07b">shared_ptr</span>&lt;Texture&gt; load(<span style="color:#e6c07b">string</span> <span style="color:#c678dd">const</span>&amp; path) {
    <span style="color:#c678dd">return</span> make_shared&lt;Texture&gt;(path);
  }
};

<span style="color:#5c6370;font-style:italic">// These functions will take a copy and increment the counter</span>
<span style="color:#5c6370;font-style:italic">// Using const&amp; would not increment the ref-counter</span>
<span class="hljs-function"><span style="color:#c678dd">int</span> <span style="color:#61aeee">doSomethingWithTexture</span><span class="hljs-params">(<span style="color:#e6c07b">shared_ptr</span>&lt;Texture&gt; <span style="color:#c678dd">const</span> tex)</span></span>;

<span class="hljs-function"><span style="color:#c678dd">int</span> <span style="color:#61aeee">doSomethingElseWithTexture</span><span class="hljs-params">(<span style="color:#e6c07b">shared_ptr</span>&lt;Texture&gt; <span style="color:#c678dd">const</span> tex)</span></span>;

<span class="hljs-function"><span style="color:#c678dd">void</span> <span style="color:#61aeee">foo</span><span class="hljs-params">()</span> </span>{
  <span style="color:#e6c07b">shared_ptr</span>&lt;Texture&gt; tex = Texture::load(<span style="color:#98c379">&quot;textures/my_texture.png&quot;</span>);

  thread(doSthWithTexture, tex).detach();
  thread(doSthMoreWithTexture, tex).detach();
}</code></pre></pre><h3 id="weak_ptr">weak_ptr</h3><p>We saw that we can use <span class="inline-code">shared_ptr</span> with multiple owners, but what happens if we have cycles in the ownership graph? In this case, we would leak memory as the reference counter would never hit zero! The owners in the cycle would keep each-other alive.</p><p>This is where <span class="inline-code">weak_ptr</span> comes into play. <span class="inline-code">weak_ptr</span> is like <span class="inline-code">shared_ptr</span> but it does not increment the reference counter. If you replace the cycle-branch in your ownership graph with a <span class="inline-code">weak_ptr</span>, then reference counting will work correctly.</p><h4 id="Example-3">Example</h4><pre><pre lang="cpp" class="code" style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span class="hljs-class"><span style="color:#c678dd">struct</span> <span style="color:#61aeee">Node</span> {</span>
  <span style="color:#e6c07b">string</span> name;
  weak_ptr&lt;Node&gt; parent;
  <span style="color:#e6c07b">vector</span>&lt;<span style="color:#e6c07b">shared_ptr</span>&lt;Node&gt;&gt; children;

  <span class="hljs-function"><span style="color:#c678dd">bool</span> <span style="color:#61aeee">hasParent</span><span class="hljs-params">()</span> </span>{
    <span style="color:#c678dd">return</span> parent.expired();
  }

  <span style="color:#e6c07b">shared_ptr</span>&lt;Node&gt; getParent() {
    <span style="color:#c678dd">return</span> parent.lock();
    <span style="color:#5c6370;font-style:italic">// If hasParent() then return shared_ptr from parent else nullptr</span>
  }

  <span class="hljs-function">Node&amp; <span style="color:#61aeee">addChild</span><span class="hljs-params">(<span style="color:#e6c07b">shared_ptr</span>&lt;Node&gt; node)</span> </span>{
    <span style="color:#c678dd">if</span>(node.hasParent()) {
      <span style="color:#c678dd">throw</span> <span style="color:#98c379">&quot;node already belongs to a parent&quot;</span>;
    }
    children.emplace_back(node);
    node-&gt;parent = <span style="color:#c678dd">this</span>;
    <span style="color:#c678dd">return</span> *<span style="color:#c678dd">this</span>;
  }

  <span class="hljs-function">Node&amp; <span style="color:#61aeee">removeChild</span><span class="hljs-params">(<span style="color:#c678dd">unsigned</span> i)</span> </span>{
    children[i].parent.reset(); <span style="color:#5c6370;font-style:italic">// Remove parent;</span>
    children.erase(&amp;children[i]);
    <span style="color:#c678dd">return</span> *<span style="color:#c678dd">this</span>;
  }

  <span style="color:#c678dd">static</span> <span style="color:#e6c07b">shared_ptr</span>&lt;Node&gt; create(<span style="color:#e6c07b">string</span> <span style="color:#c678dd">const</span>&amp; name) {
    <span style="color:#c678dd">return</span> make_shared&lt;Node&gt;(name);
  }
};

<span style="color:#e6c07b">shared_ptr</span>&lt;Node&gt; createTree() {
  <span style="color:#e6c07b">shared_ptr</span>&lt;Node&gt; root = Node::create(<span style="color:#98c379">&quot;root&quot;</span>);
  <span style="color:#e6c07b">shared_ptr</span>&lt;Node&gt; foo = Node::create(<span style="color:#98c379">&quot;foo&quot;</span>);
  <span style="color:#e6c07b">shared_ptr</span>&lt;Node&gt; bar = Node::create(<span style="color:#98c379">&quot;bar&quot;</span>);
  <span style="color:#e6c07b">shared_ptr</span>&lt;Node&gt; baz = Node::create(<span style="color:#98c379">&quot;baz&quot;</span>);

  root
    -&gt;addChild(foo)
    -&gt;addChild(bar);

  bar-&gt;addChild(baz);

  <span style="color:#c678dd">return</span> root;
}

<span class="hljs-function"><span style="color:#c678dd">int</span> <span style="color:#61aeee">main</span><span class="hljs-params">()</span> </span>{
  <span style="color:#c678dd">auto</span> tree = createTree();
  <span style="color:#c678dd">auto</span> baz = tree-&gt;children[<span style="color:#d19a66">1</span>]-&gt;children[<span style="color:#d19a66">0</span>];
  tree-&gt;removeChild(<span style="color:#d19a66">1</span>); <span style="color:#5c6370;font-style:italic">// Remove bar</span>
  ASSERT(baz.hasParent() == <span style="color:#56b6c2">false</span>);
  <span style="color:#5c6370;font-style:italic">// If parent would be a shared_ptr,</span>
  <span style="color:#5c6370;font-style:italic">// then bar and baz would keep eachother alive forever.</span>
  <span style="color:#c678dd">return</span> <span style="color:#d19a66">0</span>;
}</code></pre></pre><p>Use <span class="inline-code">weak_ptr</span> when:</p><ul><li>You absolutely must have a cyclic ownership graph</li></ul><h2 id="Introducing-value_ptr">Introducing value_ptr</h2><p>Value semantics make your code easier to reason about because unlike pointers, ownership must be strictly hierarchical and exclusive.</p><p><span class="inline-code">value_ptr</span> allows us to enforce those semantics on a copyable resource on the heap.</p><h3 id="How-it-Works">How it Works</h3><ul><li><span class="inline-code">value_ptr</span> has exclusive ownership of a resource on the heap.</li><li>When you assign one value<em>ptr to another, a new <span class="inline-code">value_ptr</span> object is constructed that points to its own copy of the previous `value</em>ptr`‚Äôs resource.</li><li>The resource is destroyed when the <span class="inline-code">value_ptr</span> leaves its lexical scope.</li><li>No memory is shared, so <span class="inline-code">value_ptr</span> is inherently thread-safe.</li><li>A modern compiler is smart enough to remove most redundant copies.</li></ul><h4 id="Example-1‚Ää‚Äî‚ÄäRecursive-Data-Types">Example 1‚Ää‚Äî‚ÄäRecursive Data Types</h4><p>Recursive types like trees must be implemented via a pointer in C++ so the layout in memory can be computed at compile-time. However, despite using a pointer, we might still want the simplicity of value-semantics:</p><pre><pre lang="cpp" class="code" style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span class="hljs-class"><span style="color:#c678dd">struct</span> <span style="color:#61aeee">Tree</span> {</span>
  <span style="color:#e6c07b">string</span> <span style="color:#c678dd">const</span> name;
  value_ptr&lt;Tree&gt; left;
  value_ptr&lt;Tree&gt; right;

  Tree(
    <span style="color:#e6c07b">string</span> <span style="color:#c678dd">const</span>&amp; name,
    value_ptr&lt;Tree&gt; <span style="color:#c678dd">const</span>&amp; left = value_ptr&lt;Tree&gt;{},
    value_ptr&lt;Tree&gt; <span style="color:#c678dd">const</span>&amp; right = value_ptr&lt;Tree&gt;{})
    : name{name}
    , left{left}
    , right{right}
  {}
};

<span class="hljs-function"><span style="color:#c678dd">int</span> <span style="color:#61aeee">main</span><span class="hljs-params">()</span> </span>{
  Tree root = Tree{
    <span style="color:#98c379">&quot;root&quot;</span>,
      Tree{<span style="color:#98c379">&quot;l0&quot;</span>}
      Tree{<span style="color:#98c379">&quot;r0&quot;</span>}
  };

  root.left = root; <span style="color:#5c6370;font-style:italic">// Copy of root assigned to left</span>
  root.right = root; <span style="color:#5c6370;font-style:italic">// and we don&#x27;t have cyclic references</span>
}</code></pre></pre><h4 id="Example-2‚Ää‚Äî‚ÄäThe-PImpl-Pattern">Example 2‚Ää‚Äî‚ÄäThe PImpl Pattern</h4><p>Sometimes we want to separate the interface of a class from its implementation. This might be to hide code behind a compiled library, or to enforce a constant stack-size.</p><p>Since the lifetime is bound to the owner, a smart-pointer is appropriate here, but what semantics do we want to have? Unlike <span class="inline-code">shared_ptr</span> and <span class="inline-code">unique_ptr</span>, <span class="inline-code">value_ptr</span> gives us value semantics.</p><pre><pre lang="cpp" class="code" style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span class="hljs-class"><span style="color:#c678dd">struct</span> <span style="color:#61aeee">Foo</span> {</span>
  <span class="hljs-function"><span style="color:#c678dd">int</span> <span style="color:#61aeee">bar</span><span class="hljs-params">()</span> </span>{
    <span style="color:#c678dd">return</span> ptr-&gt;bar();
  }

  Foo(<span style="color:#c678dd">int</span> x);

  <span style="color:#5c6370;font-style:italic">// Thanks to value_ptr we get value semantics for free</span>
  Foo(Foo <span style="color:#c678dd">const</span>&amp;) = <span style="color:#c678dd">default</span>;

  Foo&amp; <span style="color:#c678dd">operator</span>=(Foo <span style="color:#c678dd">const</span>&amp;) = <span style="color:#c678dd">default</span>;

  ~Foo() = <span style="color:#c678dd">default</span>;

  <span class="hljs-class"><span style="color:#c678dd">struct</span> <span style="color:#61aeee">Pimpl</span>;</span>

  value_ptr&lt;Pimpl&gt; ptr;
};</code></pre></pre><p><em>Header</em></p><pre><pre lang="cpp" class="code" style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span class="hljs-class"><span style="color:#c678dd">struct</span> <span style="color:#61aeee">Foo</span>:</span>:Pimpl {
  <span style="color:#c678dd">int</span> x;
  <span class="hljs-function"><span style="color:#c678dd">int</span> <span style="color:#61aeee">bar</span><span class="hljs-params">()</span> </span>{ <span style="color:#c678dd">return</span> ++x; }
};

Foo::Foo(<span style="color:#c678dd">int</span> x)
  : ptr{Foo::Pimpl{x}}
{}</code></pre></pre><p><em>Translation-unit</em></p><h5 id="More-Resources-About-the-PImpl-Pattern">More Resources About the PImpl Pattern</h5><ul><li><a href="http://oliora.github.io/2015/12/29/pimpl-and-rule-of-zero.html">PImpl, Rule of Zero and Scott Meyers</a></li><li><a href="http://www.gotw.ca/gotw/028.htm">The Fast PImpl Idiom</a></li><li><a href="https://anteru.net/blog/2009/03/14/385/">PImpl You C++ Code</a></li></ul><h2 id="Implementing-value_ptr">Implementing value_ptr</h2><p>You might have noticed that <span class="inline-code">value_ptr</span> is similar to <span class="inline-code">unique_ptr</span>, but with a different copy-constructor. Whilst copying a <span class="inline-code">unique_ptr</span> is forbidden, copying a <span class="inline-code">value_ptr</span> will create a copy of the resource. Thus, we can implement <span class="inline-code">value_ptr</span> by leveraging <span class="inline-code">unique_ptr</span> and a copy function.</p><p>This is what we have done; <a href="https://github.com/loopperfect/valuable">take a look on GitHub</a>, or test-drive our implementation with <a href="https://buckaroo.pm">Buckaroo</a>:</p><pre><pre lang="bash" class="code" style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>buckaroo add github.com/LoopPerfect/valuable</code></pre></pre><h2 id="Summary">Summary</h2><p>Value semantics are easy to reason about, and are often useful even for heap objects. The C++ standard library does not provide a smart-pointer with value semantics, but C++ has the features to allow us to roll-our-own.</p><p>Can‚Äôt decide which smart-pointer to use? Here‚Äôs a quick chart:</p><table><thead><tr><th>Name</th><th>Ownership</th><th>Copyable</th><th>Movable</th><th>Sharing</th><th>Lifetime</th><th>Semantics</th></tr></thead><tbody><tr><td><span class="inline-code">unique_ptr</span></td><td>Unique</td><td>‚ùå</td><td>‚úÖ</td><td>‚ùå</td><td>Lexical</td><td>Reference</td></tr><tr><td><span class="inline-code">shared_ptr</span></td><td>Shared</td><td>‚úÖ</td><td>‚úÖ</td><td>Reference</td><td>Reference-counted</td><td>Reference</td></tr><tr><td><span class="inline-code">weak_ptr</span></td><td>‚ùå</td><td>‚úÖ</td><td>‚úÖ</td><td>‚ùå</td><td>Non-extending</td><td>Optional-reference</td></tr><tr><td><span class="inline-code">value_ptr</span></td><td>Unique</td><td>‚úÖ</td><td>‚úÖ</td><td>Value</td><td>Lexical</td><td>Value</td></tr></tbody></table></div></div><hr/><p>üí¨¬†<a href="https://news.ycombinator.com/submitlink?u=https%3A%2F%2Fbuckaroo.pm%2Fposts%2Fvalue-ptr-the-missing-smart-ptr&amp;t=value_ptr%E2%80%8A%E2%80%94%E2%80%8AThe%20Missing%20C%2B%2B%20Smart-pointer">Discuss on Hacker News</a></p></div></div>
      </div>
      <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-98721445-1', 'buckaroo.pm');
ga('send', 'pageview');
</script>
      <script type="text/javascript" src="/main.js"></script>

      </body>
    </html>